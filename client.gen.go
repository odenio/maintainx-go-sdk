// Package maintainx provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package maintainx

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAssetcriticalities request
	GetAssetcriticalities(ctx context.Context, params *GetAssetcriticalitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetcriticalitiesId request
	GetAssetcriticalitiesId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetcustomstatuses request
	GetAssetcustomstatuses(ctx context.Context, params *GetAssetcustomstatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAssetcustomstatusesWithBody request with any body
	PostAssetcustomstatusesWithBody(ctx context.Context, params *PostAssetcustomstatusesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAssetcustomstatuses(ctx context.Context, params *PostAssetcustomstatusesParams, body PostAssetcustomstatusesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAssetcustomstatusesId request
	DeleteAssetcustomstatusesId(ctx context.Context, id int, params *DeleteAssetcustomstatusesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetcustomstatusesId request
	GetAssetcustomstatusesId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAssetcustomstatusesIdWithBody request with any body
	PatchAssetcustomstatusesIdWithBody(ctx context.Context, id int, params *PatchAssetcustomstatusesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchAssetcustomstatusesId(ctx context.Context, id int, params *PatchAssetcustomstatusesIdParams, body PatchAssetcustomstatusesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssets request
	GetAssets(ctx context.Context, params *GetAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAssetsWithBody request with any body
	PostAssetsWithBody(ctx context.Context, params *PostAssetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAssets(ctx context.Context, params *PostAssetsParams, body PostAssetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAssetsAssetIdStatusWithBody request with any body
	PostAssetsAssetIdStatusWithBody(ctx context.Context, assetId int, params *PostAssetsAssetIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAssetsAssetIdStatus(ctx context.Context, assetId int, params *PostAssetsAssetIdStatusParams, body PostAssetsAssetIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAssetsId request
	DeleteAssetsId(ctx context.Context, id int, params *DeleteAssetsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetsId request
	GetAssetsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAssetsIdWithBody request with any body
	PatchAssetsIdWithBody(ctx context.Context, id int, params *PatchAssetsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchAssetsId(ctx context.Context, id int, params *PatchAssetsIdParams, body PatchAssetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAssetsIdAttachmentsFilename request
	DeleteAssetsIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeleteAssetsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAssetsIdAttachmentsFilenameWithBody request with any body
	PutAssetsIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutAssetsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAssetsIdThumbnailFilenameWithBody request with any body
	PutAssetsIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutAssetsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetstatuses request
	GetAssetstatuses(ctx context.Context, params *GetAssetstatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAssetstatusesIdWithBody request with any body
	PatchAssetstatusesIdWithBody(ctx context.Context, id int, params *PatchAssetstatusesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchAssetstatusesId(ctx context.Context, id int, params *PatchAssetstatusesIdParams, body PatchAssetstatusesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategories request
	GetCategories(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCategoriesWithBody request with any body
	PostCategoriesWithBody(ctx context.Context, params *PostCategoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCategories(ctx context.Context, params *PostCategoriesParams, body PostCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCategoriesId request
	DeleteCategoriesId(ctx context.Context, id int, params *DeleteCategoriesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategoriesId request
	GetCategoriesId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchCategoriesIdWithBody request with any body
	PatchCategoriesIdWithBody(ctx context.Context, id int, params *PatchCategoriesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchCategoriesId(ctx context.Context, id int, params *PatchCategoriesIdParams, body PatchCategoriesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConversations request
	GetConversations(ctx context.Context, params *GetConversationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConversationsIdMembers request
	GetConversationsIdMembers(ctx context.Context, id int, params *GetConversationsIdMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostConversationsIdMessagesWithBody request with any body
	PostConversationsIdMessagesWithBody(ctx context.Context, id int, params *PostConversationsIdMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostConversationsIdMessages(ctx context.Context, id int, params *PostConversationsIdMessagesParams, body PostConversationsIdMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomfieldsEntity request
	GetCustomfieldsEntity(ctx context.Context, entity GetCustomfieldsEntityParamsEntity, params *GetCustomfieldsEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomfieldsEntityWithBody request with any body
	PostCustomfieldsEntityWithBody(ctx context.Context, entity PostCustomfieldsEntityParamsEntity, params *PostCustomfieldsEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomfieldsEntity(ctx context.Context, entity PostCustomfieldsEntityParamsEntity, params *PostCustomfieldsEntityParams, body PostCustomfieldsEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomfieldsEntityId request
	DeleteCustomfieldsEntityId(ctx context.Context, entity DeleteCustomfieldsEntityIdParamsEntity, id int, params *DeleteCustomfieldsEntityIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchCustomfieldsEntityIdWithBody request with any body
	PatchCustomfieldsEntityIdWithBody(ctx context.Context, entity PatchCustomfieldsEntityIdParamsEntity, id int, params *PatchCustomfieldsEntityIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchCustomfieldsEntityId(ctx context.Context, entity PatchCustomfieldsEntityIdParamsEntity, id int, params *PatchCustomfieldsEntityIdParams, body PatchCustomfieldsEntityIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocations request
	GetLocations(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLocationsWithBody request with any body
	PostLocationsWithBody(ctx context.Context, params *PostLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLocations(ctx context.Context, params *PostLocationsParams, body PostLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLocationsId request
	DeleteLocationsId(ctx context.Context, id int, params *DeleteLocationsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationsId request
	GetLocationsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLocationsIdWithBody request with any body
	PatchLocationsIdWithBody(ctx context.Context, id int, params *PatchLocationsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLocationsId(ctx context.Context, id int, params *PatchLocationsIdParams, body PatchLocationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLocationsIdAttachmentsFilename request
	DeleteLocationsIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeleteLocationsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutLocationsIdAttachmentsFilenameWithBody request with any body
	PutLocationsIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutLocationsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutLocationsIdThumbnailFilenameWithBody request with any body
	PutLocationsIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutLocationsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMeterreadingsWithBody request with any body
	PostMeterreadingsWithBody(ctx context.Context, params *PostMeterreadingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMeterreadings(ctx context.Context, params *PostMeterreadingsParams, body PostMeterreadingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeters request
	GetMeters(ctx context.Context, params *GetMetersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMetersWithBody request with any body
	PostMetersWithBody(ctx context.Context, params *PostMetersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMeters(ctx context.Context, params *PostMetersParams, body PostMetersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMetersId request
	DeleteMetersId(ctx context.Context, id int, params *DeleteMetersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetersId request
	GetMetersId(ctx context.Context, id int, params *GetMetersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchMetersIdWithBody request with any body
	PatchMetersIdWithBody(ctx context.Context, id int, params *PatchMetersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchMetersId(ctx context.Context, id int, params *PatchMetersIdParams, body PatchMetersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMetersMeterIdReadingsWithBody request with any body
	PostMetersMeterIdReadingsWithBody(ctx context.Context, meterId int, params *PostMetersMeterIdReadingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMetersMeterIdReadings(ctx context.Context, meterId int, params *PostMetersMeterIdReadingsParams, body PostMetersMeterIdReadingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetertriggers request
	GetMetertriggers(ctx context.Context, params *GetMetertriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMetertriggersWithBody request with any body
	PostMetertriggersWithBody(ctx context.Context, params *PostMetertriggersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMetertriggers(ctx context.Context, params *PostMetertriggersParams, body PostMetertriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMetertriggersId request
	DeleteMetertriggersId(ctx context.Context, id int, params *DeleteMetertriggersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetertriggersId request
	GetMetertriggersId(ctx context.Context, id int, params *GetMetertriggersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchMetertriggersIdWithBody request with any body
	PatchMetertriggersIdWithBody(ctx context.Context, id int, params *PatchMetertriggersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchMetertriggersId(ctx context.Context, id int, params *PatchMetertriggersIdParams, body PatchMetertriggersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutMetertriggersIdThumbnailFilenameWithBody request with any body
	PutMetertriggersIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutMetertriggersIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchMetertriggersIdWorkordertemplatesWithBody request with any body
	PatchMetertriggersIdWorkordertemplatesWithBody(ctx context.Context, id int, params *PatchMetertriggersIdWorkordertemplatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchMetertriggersIdWorkordertemplates(ctx context.Context, id int, params *PatchMetertriggersIdWorkordertemplatesParams, body PatchMetertriggersIdWorkordertemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMetertriggersIdWorkordertemplatesAttachmentsFilename request
	DeleteMetertriggersIdWorkordertemplatesAttachmentsFilename(ctx context.Context, id int, filename string, params *DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutMetertriggersIdWorkordertemplatesAttachmentsFilenameWithBody request with any body
	PutMetertriggersIdWorkordertemplatesAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutMetertriggersIdWorkordertemplatesAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizations request
	GetOrganizations(ctx context.Context, params *GetOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetParts request
	GetParts(ctx context.Context, params *GetPartsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPartsWithBody request with any body
	PostPartsWithBody(ctx context.Context, params *PostPartsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostParts(ctx context.Context, params *PostPartsParams, body PostPartsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePartsId request
	DeletePartsId(ctx context.Context, id int, params *DeletePartsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPartsId request
	GetPartsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPartsIdWithBody request with any body
	PatchPartsIdWithBody(ctx context.Context, id int, params *PatchPartsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchPartsId(ctx context.Context, id int, params *PatchPartsIdParams, body PatchPartsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePartsIdAttachmentsFilename request
	DeletePartsIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeletePartsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutPartsIdAttachmentsFilenameWithBody request with any body
	PutPartsIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutPartsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutPartsIdThumbnailFilenameWithBody request with any body
	PutPartsIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutPartsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetParttransferrequests request
	GetParttransferrequests(ctx context.Context, params *GetParttransferrequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostParttransferrequestsWithBody request with any body
	PostParttransferrequestsWithBody(ctx context.Context, params *PostParttransferrequestsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostParttransferrequests(ctx context.Context, params *PostParttransferrequestsParams, body PostParttransferrequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetParttransferrequestsId request
	GetParttransferrequestsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchParttransferrequestsIdWithBody request with any body
	PatchParttransferrequestsIdWithBody(ctx context.Context, id int, params *PatchParttransferrequestsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchParttransferrequestsId(ctx context.Context, id int, params *PatchParttransferrequestsIdParams, body PatchParttransferrequestsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProceduretemplaterowsId request
	DeleteProceduretemplaterowsId(ctx context.Context, id int, params *DeleteProceduretemplaterowsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchProceduretemplaterowsIdWithBody request with any body
	PatchProceduretemplaterowsIdWithBody(ctx context.Context, id int, params *PatchProceduretemplaterowsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchProceduretemplaterowsId(ctx context.Context, id int, params *PatchProceduretemplaterowsIdParams, body PatchProceduretemplaterowsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProceduretemplaterowsIdAttachments request
	DeleteProceduretemplaterowsIdAttachments(ctx context.Context, id int, params *DeleteProceduretemplaterowsIdAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutProceduretemplaterowsIdAttachmentsFilenameWithBody request with any body
	PutProceduretemplaterowsIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutProceduretemplaterowsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProceduretemplates request
	GetProceduretemplates(ctx context.Context, params *GetProceduretemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProceduretemplatesWithBody request with any body
	PostProceduretemplatesWithBody(ctx context.Context, params *PostProceduretemplatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProceduretemplates(ctx context.Context, params *PostProceduretemplatesParams, body PostProceduretemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProceduretemplatesId request
	DeleteProceduretemplatesId(ctx context.Context, id int, params *DeleteProceduretemplatesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProceduretemplatesId request
	GetProceduretemplatesId(ctx context.Context, id int, params *GetProceduretemplatesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchProceduretemplatesIdWithBody request with any body
	PatchProceduretemplatesIdWithBody(ctx context.Context, id int, params *PatchProceduretemplatesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchProceduretemplatesId(ctx context.Context, id int, params *PatchProceduretemplatesIdParams, body PatchProceduretemplatesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPurchaseorders request
	GetPurchaseorders(ctx context.Context, params *GetPurchaseordersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPurchaseordersWithBody request with any body
	PostPurchaseordersWithBody(ctx context.Context, params *PostPurchaseordersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPurchaseorders(ctx context.Context, params *PostPurchaseordersParams, body PostPurchaseordersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePurchaseordersId request
	DeletePurchaseordersId(ctx context.Context, id int, params *DeletePurchaseordersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPurchaseordersId request
	GetPurchaseordersId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPurchaseordersIdWithBody request with any body
	PatchPurchaseordersIdWithBody(ctx context.Context, id float32, params *PatchPurchaseordersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchPurchaseordersId(ctx context.Context, id float32, params *PatchPurchaseordersIdParams, body PatchPurchaseordersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePurchaseordersIdAttachmentsFilename request
	DeletePurchaseordersIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeletePurchaseordersIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutPurchaseordersIdAttachmentsFilenameWithBody request with any body
	PutPurchaseordersIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutPurchaseordersIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPurchaseordersIdCommentsWithBody request with any body
	PostPurchaseordersIdCommentsWithBody(ctx context.Context, id int, params *PostPurchaseordersIdCommentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPurchaseordersIdComments(ctx context.Context, id int, params *PostPurchaseordersIdCommentsParams, body PostPurchaseordersIdCommentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPurchaseordersIdEmailsWithBody request with any body
	PostPurchaseordersIdEmailsWithBody(ctx context.Context, id int, params *PostPurchaseordersIdEmailsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPurchaseordersIdEmails(ctx context.Context, id int, params *PostPurchaseordersIdEmailsParams, body PostPurchaseordersIdEmailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPurchaseordersIdFulfillmentWithBody request with any body
	PatchPurchaseordersIdFulfillmentWithBody(ctx context.Context, id float32, params *PatchPurchaseordersIdFulfillmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchPurchaseordersIdFulfillment(ctx context.Context, id float32, params *PatchPurchaseordersIdFulfillmentParams, body PatchPurchaseordersIdFulfillmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPurchaseordersIdStatusWithBody request with any body
	PatchPurchaseordersIdStatusWithBody(ctx context.Context, id float32, params *PatchPurchaseordersIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchPurchaseordersIdStatus(ctx context.Context, id float32, params *PatchPurchaseordersIdStatusParams, body PatchPurchaseordersIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutPurchaseordersIdThumbnailFilenameWithBody request with any body
	PutPurchaseordersIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutPurchaseordersIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSubscriptionsWithBody request with any body
	PostSubscriptionsWithBody(ctx context.Context, params *PostSubscriptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSubscriptions(ctx context.Context, params *PostSubscriptionsParams, body PostSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscriptionsId request
	DeleteSubscriptionsId(ctx context.Context, id int, params *DeleteSubscriptionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionsId request
	GetSubscriptionsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSubscriptionsIdWithBody request with any body
	PatchSubscriptionsIdWithBody(ctx context.Context, id int, params *PatchSubscriptionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSubscriptionsId(ctx context.Context, id int, params *PatchSubscriptionsIdParams, body PatchSubscriptionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionsIdSecret request
	GetSubscriptionsIdSecret(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeams request
	GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTeamsWithBody request with any body
	PostTeamsWithBody(ctx context.Context, params *PostTeamsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTeams(ctx context.Context, params *PostTeamsParams, body PostTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeamsId request
	DeleteTeamsId(ctx context.Context, id int, params *DeleteTeamsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsId request
	GetTeamsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchTeamsIdWithBody request with any body
	PatchTeamsIdWithBody(ctx context.Context, id int, params *PatchTeamsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchTeamsId(ctx context.Context, id int, params *PatchTeamsIdParams, body PatchTeamsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsIdMembers request
	GetTeamsIdMembers(ctx context.Context, id int, params *GetTeamsIdMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTeamsIdMembersWithBody request with any body
	PostTeamsIdMembersWithBody(ctx context.Context, id int, params *PostTeamsIdMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTeamsIdMembers(ctx context.Context, id int, params *PostTeamsIdMembersParams, body PostTeamsIdMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeamsTeamIdMembersUserId request
	DeleteTeamsTeamIdMembersUserId(ctx context.Context, teamId int, userId int, params *DeleteTeamsTeamIdMembersUserIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchTeamsTeamIdMembersUserIdWithBody request with any body
	PatchTeamsTeamIdMembersUserIdWithBody(ctx context.Context, teamId int, userId int, params *PatchTeamsTeamIdMembersUserIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchTeamsTeamIdMembersUserId(ctx context.Context, teamId int, userId int, params *PatchTeamsTeamIdMembersUserIdParams, body PatchTeamsTeamIdMembersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUsersWithBody request with any body
	PostUsersWithBody(ctx context.Context, params *PostUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUsers(ctx context.Context, params *PostUsersParams, body PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUsersId request
	DeleteUsersId(ctx context.Context, id int, params *DeleteUsersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersId request
	GetUsersId(ctx context.Context, id int, params *GetUsersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUsersIdWithBody request with any body
	PatchUsersIdWithBody(ctx context.Context, id int, params *PatchUsersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUsersId(ctx context.Context, id int, params *PatchUsersIdParams, body PatchUsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUsersIdMessagesWithBody request with any body
	PostUsersIdMessagesWithBody(ctx context.Context, id int, params *PostUsersIdMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUsersIdMessages(ctx context.Context, id int, params *PostUsersIdMessagesParams, body PostUsersIdMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVendors request
	GetVendors(ctx context.Context, params *GetVendorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVendorsWithBody request with any body
	PostVendorsWithBody(ctx context.Context, params *PostVendorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostVendors(ctx context.Context, params *PostVendorsParams, body PostVendorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVendorsId request
	DeleteVendorsId(ctx context.Context, id int, params *DeleteVendorsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVendorsId request
	GetVendorsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchVendorsIdWithBody request with any body
	PatchVendorsIdWithBody(ctx context.Context, id int, params *PatchVendorsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchVendorsId(ctx context.Context, id int, params *PatchVendorsIdParams, body PatchVendorsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVendorsIdAttachmentsFilename request
	DeleteVendorsIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeleteVendorsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutVendorsIdAttachmentsFilenameWithBody request with any body
	PutVendorsIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutVendorsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVendorsIdContacts request
	GetVendorsIdContacts(ctx context.Context, id int, params *GetVendorsIdContactsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVendorsIdContactsWithBody request with any body
	PostVendorsIdContactsWithBody(ctx context.Context, id int, params *PostVendorsIdContactsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostVendorsIdContacts(ctx context.Context, id int, params *PostVendorsIdContactsParams, body PostVendorsIdContactsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVendorsIdContactsContactId request
	DeleteVendorsIdContactsContactId(ctx context.Context, id int, contactId int, params *DeleteVendorsIdContactsContactIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVendorsIdContactsContactId request
	GetVendorsIdContactsContactId(ctx context.Context, id int, contactId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchVendorsIdContactsContactIdWithBody request with any body
	PatchVendorsIdContactsContactIdWithBody(ctx context.Context, id int, contactId int, params *PatchVendorsIdContactsContactIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchVendorsIdContactsContactId(ctx context.Context, id int, contactId int, params *PatchVendorsIdContactsContactIdParams, body PatchVendorsIdContactsContactIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutVendorsIdThumbnailFilenameWithBody request with any body
	PutVendorsIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutVendorsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersions request
	GetVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWorkPermitsIdSignWithBody request with any body
	PostWorkPermitsIdSignWithBody(ctx context.Context, id int, params *PostWorkPermitsIdSignParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWorkPermitsIdSign(ctx context.Context, id int, params *PostWorkPermitsIdSignParams, body PostWorkPermitsIdSignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkorders request
	GetWorkorders(ctx context.Context, params *GetWorkordersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWorkordersWithBody request with any body
	PostWorkordersWithBody(ctx context.Context, params *PostWorkordersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWorkorders(ctx context.Context, params *PostWorkordersParams, body PostWorkordersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkordersId request
	DeleteWorkordersId(ctx context.Context, id int, params *DeleteWorkordersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkordersId request
	GetWorkordersId(ctx context.Context, id int, params *GetWorkordersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchWorkordersIdWithBody request with any body
	PatchWorkordersIdWithBody(ctx context.Context, id int, params *PatchWorkordersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchWorkordersId(ctx context.Context, id int, params *PatchWorkordersIdParams, body PatchWorkordersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkordersIdAttachmentsFilename request
	DeleteWorkordersIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeleteWorkordersIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutWorkordersIdAttachmentsFilenameWithBody request with any body
	PutWorkordersIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutWorkordersIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkordersIdComments request
	GetWorkordersIdComments(ctx context.Context, id int, params *GetWorkordersIdCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWorkordersIdCommentsWithBody request with any body
	PostWorkordersIdCommentsWithBody(ctx context.Context, id int, params *PostWorkordersIdCommentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWorkordersIdComments(ctx context.Context, id int, params *PostWorkordersIdCommentsParams, body PostWorkordersIdCommentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkordersIdCosts request
	GetWorkordersIdCosts(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWorkordersIdCostsWithBody request with any body
	PostWorkordersIdCostsWithBody(ctx context.Context, id int, params *PostWorkordersIdCostsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWorkordersIdCosts(ctx context.Context, id int, params *PostWorkordersIdCostsParams, body PostWorkordersIdCostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWorkordersIdEmailsWithBody request with any body
	PostWorkordersIdEmailsWithBody(ctx context.Context, id int, params *PostWorkordersIdEmailsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWorkordersIdEmails(ctx context.Context, id int, params *PostWorkordersIdEmailsParams, body PostWorkordersIdEmailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkordersIdProcedure request
	DeleteWorkordersIdProcedure(ctx context.Context, id int, params *DeleteWorkordersIdProcedureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkordersIdProcedureFieldsIndexAttachment request
	DeleteWorkordersIdProcedureFieldsIndexAttachment(ctx context.Context, id int, index int, params *DeleteWorkordersIdProcedureFieldsIndexAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutWorkordersIdProcedureFieldsIndexAttachmentFilenameWithBody request with any body
	PutWorkordersIdProcedureFieldsIndexAttachmentFilenameWithBody(ctx context.Context, id int, index int, filename string, params *PutWorkordersIdProcedureFieldsIndexAttachmentFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchWorkordersIdStatusWithBody request with any body
	PatchWorkordersIdStatusWithBody(ctx context.Context, id int, params *PatchWorkordersIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchWorkordersIdStatus(ctx context.Context, id int, params *PatchWorkordersIdStatusParams, body PatchWorkordersIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkordersIdSubworkorders request
	GetWorkordersIdSubworkorders(ctx context.Context, id int, params *GetWorkordersIdSubworkordersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutWorkordersIdThumbnailFilenameWithBody request with any body
	PutWorkordersIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutWorkordersIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkrequestportals request
	GetWorkrequestportals(ctx context.Context, params *GetWorkrequestportalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWorkrequestportalsWithBody request with any body
	PostWorkrequestportalsWithBody(ctx context.Context, params *PostWorkrequestportalsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWorkrequestportals(ctx context.Context, params *PostWorkrequestportalsParams, body PostWorkrequestportalsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkrequestportalsId request
	DeleteWorkrequestportalsId(ctx context.Context, id int, params *DeleteWorkrequestportalsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkrequestportalsId request
	GetWorkrequestportalsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchWorkrequestportalsIdWithBody request with any body
	PatchWorkrequestportalsIdWithBody(ctx context.Context, id int, params *PatchWorkrequestportalsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchWorkrequestportalsId(ctx context.Context, id int, params *PatchWorkrequestportalsIdParams, body PatchWorkrequestportalsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkrequests request
	GetWorkrequests(ctx context.Context, params *GetWorkrequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWorkrequestsWithBody request with any body
	PostWorkrequestsWithBody(ctx context.Context, params *PostWorkrequestsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWorkrequests(ctx context.Context, params *PostWorkrequestsParams, body PostWorkrequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkrequestsId request
	DeleteWorkrequestsId(ctx context.Context, id int, params *DeleteWorkrequestsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkrequestsId request
	GetWorkrequestsId(ctx context.Context, id int, params *GetWorkrequestsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchWorkrequestsIdWithBody request with any body
	PatchWorkrequestsIdWithBody(ctx context.Context, id int, params *PatchWorkrequestsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchWorkrequestsId(ctx context.Context, id int, params *PatchWorkrequestsIdParams, body PatchWorkrequestsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkrequestsIdAttachmentsFilename request
	DeleteWorkrequestsIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeleteWorkrequestsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutWorkrequestsIdAttachmentsFilenameWithBody request with any body
	PutWorkrequestsIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutWorkrequestsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutWorkrequestsIdThumbnailFilenameWithBody request with any body
	PutWorkrequestsIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutWorkrequestsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAssetcriticalities(ctx context.Context, params *GetAssetcriticalitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetcriticalitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetcriticalitiesId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetcriticalitiesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetcustomstatuses(ctx context.Context, params *GetAssetcustomstatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetcustomstatusesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAssetcustomstatusesWithBody(ctx context.Context, params *PostAssetcustomstatusesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAssetcustomstatusesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAssetcustomstatuses(ctx context.Context, params *PostAssetcustomstatusesParams, body PostAssetcustomstatusesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAssetcustomstatusesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAssetcustomstatusesId(ctx context.Context, id int, params *DeleteAssetcustomstatusesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAssetcustomstatusesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetcustomstatusesId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetcustomstatusesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAssetcustomstatusesIdWithBody(ctx context.Context, id int, params *PatchAssetcustomstatusesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAssetcustomstatusesIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAssetcustomstatusesId(ctx context.Context, id int, params *PatchAssetcustomstatusesIdParams, body PatchAssetcustomstatusesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAssetcustomstatusesIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssets(ctx context.Context, params *GetAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAssetsWithBody(ctx context.Context, params *PostAssetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAssetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAssets(ctx context.Context, params *PostAssetsParams, body PostAssetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAssetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAssetsAssetIdStatusWithBody(ctx context.Context, assetId int, params *PostAssetsAssetIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAssetsAssetIdStatusRequestWithBody(c.Server, assetId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAssetsAssetIdStatus(ctx context.Context, assetId int, params *PostAssetsAssetIdStatusParams, body PostAssetsAssetIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAssetsAssetIdStatusRequest(c.Server, assetId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAssetsId(ctx context.Context, id int, params *DeleteAssetsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAssetsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAssetsIdWithBody(ctx context.Context, id int, params *PatchAssetsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAssetsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAssetsId(ctx context.Context, id int, params *PatchAssetsIdParams, body PatchAssetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAssetsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAssetsIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeleteAssetsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAssetsIdAttachmentsFilenameRequest(c.Server, id, filename, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAssetsIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutAssetsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAssetsIdAttachmentsFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAssetsIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutAssetsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAssetsIdThumbnailFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetstatuses(ctx context.Context, params *GetAssetstatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetstatusesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAssetstatusesIdWithBody(ctx context.Context, id int, params *PatchAssetstatusesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAssetstatusesIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAssetstatusesId(ctx context.Context, id int, params *PatchAssetstatusesIdParams, body PatchAssetstatusesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAssetstatusesIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategories(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCategoriesWithBody(ctx context.Context, params *PostCategoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCategoriesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCategories(ctx context.Context, params *PostCategoriesParams, body PostCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCategoriesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCategoriesId(ctx context.Context, id int, params *DeleteCategoriesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCategoriesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategoriesId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoriesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchCategoriesIdWithBody(ctx context.Context, id int, params *PatchCategoriesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchCategoriesIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchCategoriesId(ctx context.Context, id int, params *PatchCategoriesIdParams, body PatchCategoriesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchCategoriesIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConversations(ctx context.Context, params *GetConversationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConversationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConversationsIdMembers(ctx context.Context, id int, params *GetConversationsIdMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConversationsIdMembersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostConversationsIdMessagesWithBody(ctx context.Context, id int, params *PostConversationsIdMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostConversationsIdMessagesRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostConversationsIdMessages(ctx context.Context, id int, params *PostConversationsIdMessagesParams, body PostConversationsIdMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostConversationsIdMessagesRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomfieldsEntity(ctx context.Context, entity GetCustomfieldsEntityParamsEntity, params *GetCustomfieldsEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomfieldsEntityRequest(c.Server, entity, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomfieldsEntityWithBody(ctx context.Context, entity PostCustomfieldsEntityParamsEntity, params *PostCustomfieldsEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomfieldsEntityRequestWithBody(c.Server, entity, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomfieldsEntity(ctx context.Context, entity PostCustomfieldsEntityParamsEntity, params *PostCustomfieldsEntityParams, body PostCustomfieldsEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomfieldsEntityRequest(c.Server, entity, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomfieldsEntityId(ctx context.Context, entity DeleteCustomfieldsEntityIdParamsEntity, id int, params *DeleteCustomfieldsEntityIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomfieldsEntityIdRequest(c.Server, entity, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchCustomfieldsEntityIdWithBody(ctx context.Context, entity PatchCustomfieldsEntityIdParamsEntity, id int, params *PatchCustomfieldsEntityIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchCustomfieldsEntityIdRequestWithBody(c.Server, entity, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchCustomfieldsEntityId(ctx context.Context, entity PatchCustomfieldsEntityIdParamsEntity, id int, params *PatchCustomfieldsEntityIdParams, body PatchCustomfieldsEntityIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchCustomfieldsEntityIdRequest(c.Server, entity, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocations(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLocationsWithBody(ctx context.Context, params *PostLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLocationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLocations(ctx context.Context, params *PostLocationsParams, body PostLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLocationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLocationsId(ctx context.Context, id int, params *DeleteLocationsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLocationsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLocationsIdWithBody(ctx context.Context, id int, params *PatchLocationsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLocationsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLocationsId(ctx context.Context, id int, params *PatchLocationsIdParams, body PatchLocationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLocationsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLocationsIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeleteLocationsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLocationsIdAttachmentsFilenameRequest(c.Server, id, filename, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutLocationsIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutLocationsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutLocationsIdAttachmentsFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutLocationsIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutLocationsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutLocationsIdThumbnailFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMeterreadingsWithBody(ctx context.Context, params *PostMeterreadingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMeterreadingsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMeterreadings(ctx context.Context, params *PostMeterreadingsParams, body PostMeterreadingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMeterreadingsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeters(ctx context.Context, params *GetMetersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMetersWithBody(ctx context.Context, params *PostMetersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMetersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMeters(ctx context.Context, params *PostMetersParams, body PostMetersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMetersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMetersId(ctx context.Context, id int, params *DeleteMetersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMetersIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetersId(ctx context.Context, id int, params *GetMetersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetersIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchMetersIdWithBody(ctx context.Context, id int, params *PatchMetersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchMetersIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchMetersId(ctx context.Context, id int, params *PatchMetersIdParams, body PatchMetersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchMetersIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMetersMeterIdReadingsWithBody(ctx context.Context, meterId int, params *PostMetersMeterIdReadingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMetersMeterIdReadingsRequestWithBody(c.Server, meterId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMetersMeterIdReadings(ctx context.Context, meterId int, params *PostMetersMeterIdReadingsParams, body PostMetersMeterIdReadingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMetersMeterIdReadingsRequest(c.Server, meterId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetertriggers(ctx context.Context, params *GetMetertriggersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetertriggersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMetertriggersWithBody(ctx context.Context, params *PostMetertriggersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMetertriggersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMetertriggers(ctx context.Context, params *PostMetertriggersParams, body PostMetertriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMetertriggersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMetertriggersId(ctx context.Context, id int, params *DeleteMetertriggersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMetertriggersIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetertriggersId(ctx context.Context, id int, params *GetMetertriggersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetertriggersIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchMetertriggersIdWithBody(ctx context.Context, id int, params *PatchMetertriggersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchMetertriggersIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchMetertriggersId(ctx context.Context, id int, params *PatchMetertriggersIdParams, body PatchMetertriggersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchMetertriggersIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutMetertriggersIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutMetertriggersIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutMetertriggersIdThumbnailFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchMetertriggersIdWorkordertemplatesWithBody(ctx context.Context, id int, params *PatchMetertriggersIdWorkordertemplatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchMetertriggersIdWorkordertemplatesRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchMetertriggersIdWorkordertemplates(ctx context.Context, id int, params *PatchMetertriggersIdWorkordertemplatesParams, body PatchMetertriggersIdWorkordertemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchMetertriggersIdWorkordertemplatesRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMetertriggersIdWorkordertemplatesAttachmentsFilename(ctx context.Context, id int, filename string, params *DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameRequest(c.Server, id, filename, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutMetertriggersIdWorkordertemplatesAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutMetertriggersIdWorkordertemplatesAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutMetertriggersIdWorkordertemplatesAttachmentsFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizations(ctx context.Context, params *GetOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetParts(ctx context.Context, params *GetPartsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPartsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPartsWithBody(ctx context.Context, params *PostPartsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPartsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostParts(ctx context.Context, params *PostPartsParams, body PostPartsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPartsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePartsId(ctx context.Context, id int, params *DeletePartsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePartsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPartsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPartsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPartsIdWithBody(ctx context.Context, id int, params *PatchPartsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPartsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPartsId(ctx context.Context, id int, params *PatchPartsIdParams, body PatchPartsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPartsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePartsIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeletePartsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePartsIdAttachmentsFilenameRequest(c.Server, id, filename, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPartsIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutPartsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPartsIdAttachmentsFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPartsIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutPartsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPartsIdThumbnailFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetParttransferrequests(ctx context.Context, params *GetParttransferrequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetParttransferrequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostParttransferrequestsWithBody(ctx context.Context, params *PostParttransferrequestsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostParttransferrequestsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostParttransferrequests(ctx context.Context, params *PostParttransferrequestsParams, body PostParttransferrequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostParttransferrequestsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetParttransferrequestsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetParttransferrequestsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchParttransferrequestsIdWithBody(ctx context.Context, id int, params *PatchParttransferrequestsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchParttransferrequestsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchParttransferrequestsId(ctx context.Context, id int, params *PatchParttransferrequestsIdParams, body PatchParttransferrequestsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchParttransferrequestsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProceduretemplaterowsId(ctx context.Context, id int, params *DeleteProceduretemplaterowsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProceduretemplaterowsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchProceduretemplaterowsIdWithBody(ctx context.Context, id int, params *PatchProceduretemplaterowsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchProceduretemplaterowsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchProceduretemplaterowsId(ctx context.Context, id int, params *PatchProceduretemplaterowsIdParams, body PatchProceduretemplaterowsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchProceduretemplaterowsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProceduretemplaterowsIdAttachments(ctx context.Context, id int, params *DeleteProceduretemplaterowsIdAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProceduretemplaterowsIdAttachmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutProceduretemplaterowsIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutProceduretemplaterowsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutProceduretemplaterowsIdAttachmentsFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProceduretemplates(ctx context.Context, params *GetProceduretemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProceduretemplatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProceduretemplatesWithBody(ctx context.Context, params *PostProceduretemplatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProceduretemplatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProceduretemplates(ctx context.Context, params *PostProceduretemplatesParams, body PostProceduretemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProceduretemplatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProceduretemplatesId(ctx context.Context, id int, params *DeleteProceduretemplatesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProceduretemplatesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProceduretemplatesId(ctx context.Context, id int, params *GetProceduretemplatesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProceduretemplatesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchProceduretemplatesIdWithBody(ctx context.Context, id int, params *PatchProceduretemplatesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchProceduretemplatesIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchProceduretemplatesId(ctx context.Context, id int, params *PatchProceduretemplatesIdParams, body PatchProceduretemplatesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchProceduretemplatesIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPurchaseorders(ctx context.Context, params *GetPurchaseordersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPurchaseordersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPurchaseordersWithBody(ctx context.Context, params *PostPurchaseordersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPurchaseordersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPurchaseorders(ctx context.Context, params *PostPurchaseordersParams, body PostPurchaseordersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPurchaseordersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePurchaseordersId(ctx context.Context, id int, params *DeletePurchaseordersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePurchaseordersIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPurchaseordersId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPurchaseordersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPurchaseordersIdWithBody(ctx context.Context, id float32, params *PatchPurchaseordersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPurchaseordersIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPurchaseordersId(ctx context.Context, id float32, params *PatchPurchaseordersIdParams, body PatchPurchaseordersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPurchaseordersIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePurchaseordersIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeletePurchaseordersIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePurchaseordersIdAttachmentsFilenameRequest(c.Server, id, filename, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPurchaseordersIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutPurchaseordersIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPurchaseordersIdAttachmentsFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPurchaseordersIdCommentsWithBody(ctx context.Context, id int, params *PostPurchaseordersIdCommentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPurchaseordersIdCommentsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPurchaseordersIdComments(ctx context.Context, id int, params *PostPurchaseordersIdCommentsParams, body PostPurchaseordersIdCommentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPurchaseordersIdCommentsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPurchaseordersIdEmailsWithBody(ctx context.Context, id int, params *PostPurchaseordersIdEmailsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPurchaseordersIdEmailsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPurchaseordersIdEmails(ctx context.Context, id int, params *PostPurchaseordersIdEmailsParams, body PostPurchaseordersIdEmailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPurchaseordersIdEmailsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPurchaseordersIdFulfillmentWithBody(ctx context.Context, id float32, params *PatchPurchaseordersIdFulfillmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPurchaseordersIdFulfillmentRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPurchaseordersIdFulfillment(ctx context.Context, id float32, params *PatchPurchaseordersIdFulfillmentParams, body PatchPurchaseordersIdFulfillmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPurchaseordersIdFulfillmentRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPurchaseordersIdStatusWithBody(ctx context.Context, id float32, params *PatchPurchaseordersIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPurchaseordersIdStatusRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPurchaseordersIdStatus(ctx context.Context, id float32, params *PatchPurchaseordersIdStatusParams, body PatchPurchaseordersIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPurchaseordersIdStatusRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPurchaseordersIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutPurchaseordersIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPurchaseordersIdThumbnailFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSubscriptionsWithBody(ctx context.Context, params *PostSubscriptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSubscriptionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSubscriptions(ctx context.Context, params *PostSubscriptionsParams, body PostSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSubscriptionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscriptionsId(ctx context.Context, id int, params *DeleteSubscriptionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscriptionsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSubscriptionsIdWithBody(ctx context.Context, id int, params *PatchSubscriptionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSubscriptionsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSubscriptionsId(ctx context.Context, id int, params *PatchSubscriptionsIdParams, body PatchSubscriptionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSubscriptionsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionsIdSecret(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionsIdSecretRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTeamsWithBody(ctx context.Context, params *PostTeamsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTeamsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTeams(ctx context.Context, params *PostTeamsParams, body PostTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTeamsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamsId(ctx context.Context, id int, params *DeleteTeamsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTeamsIdWithBody(ctx context.Context, id int, params *PatchTeamsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTeamsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTeamsId(ctx context.Context, id int, params *PatchTeamsIdParams, body PatchTeamsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTeamsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsIdMembers(ctx context.Context, id int, params *GetTeamsIdMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsIdMembersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTeamsIdMembersWithBody(ctx context.Context, id int, params *PostTeamsIdMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTeamsIdMembersRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTeamsIdMembers(ctx context.Context, id int, params *PostTeamsIdMembersParams, body PostTeamsIdMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTeamsIdMembersRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamsTeamIdMembersUserId(ctx context.Context, teamId int, userId int, params *DeleteTeamsTeamIdMembersUserIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamsTeamIdMembersUserIdRequest(c.Server, teamId, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTeamsTeamIdMembersUserIdWithBody(ctx context.Context, teamId int, userId int, params *PatchTeamsTeamIdMembersUserIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTeamsTeamIdMembersUserIdRequestWithBody(c.Server, teamId, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTeamsTeamIdMembersUserId(ctx context.Context, teamId int, userId int, params *PatchTeamsTeamIdMembersUserIdParams, body PatchTeamsTeamIdMembersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTeamsTeamIdMembersUserIdRequest(c.Server, teamId, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersWithBody(ctx context.Context, params *PostUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsers(ctx context.Context, params *PostUsersParams, body PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUsersId(ctx context.Context, id int, params *DeleteUsersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUsersIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersId(ctx context.Context, id int, params *GetUsersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUsersIdWithBody(ctx context.Context, id int, params *PatchUsersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUsersIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUsersId(ctx context.Context, id int, params *PatchUsersIdParams, body PatchUsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUsersIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersIdMessagesWithBody(ctx context.Context, id int, params *PostUsersIdMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersIdMessagesRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersIdMessages(ctx context.Context, id int, params *PostUsersIdMessagesParams, body PostUsersIdMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersIdMessagesRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVendors(ctx context.Context, params *GetVendorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVendorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVendorsWithBody(ctx context.Context, params *PostVendorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVendorsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVendors(ctx context.Context, params *PostVendorsParams, body PostVendorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVendorsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVendorsId(ctx context.Context, id int, params *DeleteVendorsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVendorsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVendorsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVendorsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchVendorsIdWithBody(ctx context.Context, id int, params *PatchVendorsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchVendorsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchVendorsId(ctx context.Context, id int, params *PatchVendorsIdParams, body PatchVendorsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchVendorsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVendorsIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeleteVendorsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVendorsIdAttachmentsFilenameRequest(c.Server, id, filename, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutVendorsIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutVendorsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutVendorsIdAttachmentsFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVendorsIdContacts(ctx context.Context, id int, params *GetVendorsIdContactsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVendorsIdContactsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVendorsIdContactsWithBody(ctx context.Context, id int, params *PostVendorsIdContactsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVendorsIdContactsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVendorsIdContacts(ctx context.Context, id int, params *PostVendorsIdContactsParams, body PostVendorsIdContactsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVendorsIdContactsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVendorsIdContactsContactId(ctx context.Context, id int, contactId int, params *DeleteVendorsIdContactsContactIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVendorsIdContactsContactIdRequest(c.Server, id, contactId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVendorsIdContactsContactId(ctx context.Context, id int, contactId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVendorsIdContactsContactIdRequest(c.Server, id, contactId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchVendorsIdContactsContactIdWithBody(ctx context.Context, id int, contactId int, params *PatchVendorsIdContactsContactIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchVendorsIdContactsContactIdRequestWithBody(c.Server, id, contactId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchVendorsIdContactsContactId(ctx context.Context, id int, contactId int, params *PatchVendorsIdContactsContactIdParams, body PatchVendorsIdContactsContactIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchVendorsIdContactsContactIdRequest(c.Server, id, contactId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutVendorsIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutVendorsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutVendorsIdThumbnailFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkPermitsIdSignWithBody(ctx context.Context, id int, params *PostWorkPermitsIdSignParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkPermitsIdSignRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkPermitsIdSign(ctx context.Context, id int, params *PostWorkPermitsIdSignParams, body PostWorkPermitsIdSignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkPermitsIdSignRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkorders(ctx context.Context, params *GetWorkordersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkordersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkordersWithBody(ctx context.Context, params *PostWorkordersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkordersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkorders(ctx context.Context, params *PostWorkordersParams, body PostWorkordersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkordersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkordersId(ctx context.Context, id int, params *DeleteWorkordersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkordersIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkordersId(ctx context.Context, id int, params *GetWorkordersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkordersIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchWorkordersIdWithBody(ctx context.Context, id int, params *PatchWorkordersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchWorkordersIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchWorkordersId(ctx context.Context, id int, params *PatchWorkordersIdParams, body PatchWorkordersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchWorkordersIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkordersIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeleteWorkordersIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkordersIdAttachmentsFilenameRequest(c.Server, id, filename, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWorkordersIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutWorkordersIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWorkordersIdAttachmentsFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkordersIdComments(ctx context.Context, id int, params *GetWorkordersIdCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkordersIdCommentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkordersIdCommentsWithBody(ctx context.Context, id int, params *PostWorkordersIdCommentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkordersIdCommentsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkordersIdComments(ctx context.Context, id int, params *PostWorkordersIdCommentsParams, body PostWorkordersIdCommentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkordersIdCommentsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkordersIdCosts(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkordersIdCostsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkordersIdCostsWithBody(ctx context.Context, id int, params *PostWorkordersIdCostsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkordersIdCostsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkordersIdCosts(ctx context.Context, id int, params *PostWorkordersIdCostsParams, body PostWorkordersIdCostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkordersIdCostsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkordersIdEmailsWithBody(ctx context.Context, id int, params *PostWorkordersIdEmailsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkordersIdEmailsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkordersIdEmails(ctx context.Context, id int, params *PostWorkordersIdEmailsParams, body PostWorkordersIdEmailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkordersIdEmailsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkordersIdProcedure(ctx context.Context, id int, params *DeleteWorkordersIdProcedureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkordersIdProcedureRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkordersIdProcedureFieldsIndexAttachment(ctx context.Context, id int, index int, params *DeleteWorkordersIdProcedureFieldsIndexAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkordersIdProcedureFieldsIndexAttachmentRequest(c.Server, id, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWorkordersIdProcedureFieldsIndexAttachmentFilenameWithBody(ctx context.Context, id int, index int, filename string, params *PutWorkordersIdProcedureFieldsIndexAttachmentFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWorkordersIdProcedureFieldsIndexAttachmentFilenameRequestWithBody(c.Server, id, index, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchWorkordersIdStatusWithBody(ctx context.Context, id int, params *PatchWorkordersIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchWorkordersIdStatusRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchWorkordersIdStatus(ctx context.Context, id int, params *PatchWorkordersIdStatusParams, body PatchWorkordersIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchWorkordersIdStatusRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkordersIdSubworkorders(ctx context.Context, id int, params *GetWorkordersIdSubworkordersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkordersIdSubworkordersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWorkordersIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutWorkordersIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWorkordersIdThumbnailFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkrequestportals(ctx context.Context, params *GetWorkrequestportalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkrequestportalsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkrequestportalsWithBody(ctx context.Context, params *PostWorkrequestportalsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkrequestportalsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkrequestportals(ctx context.Context, params *PostWorkrequestportalsParams, body PostWorkrequestportalsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkrequestportalsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkrequestportalsId(ctx context.Context, id int, params *DeleteWorkrequestportalsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkrequestportalsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkrequestportalsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkrequestportalsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchWorkrequestportalsIdWithBody(ctx context.Context, id int, params *PatchWorkrequestportalsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchWorkrequestportalsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchWorkrequestportalsId(ctx context.Context, id int, params *PatchWorkrequestportalsIdParams, body PatchWorkrequestportalsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchWorkrequestportalsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkrequests(ctx context.Context, params *GetWorkrequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkrequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkrequestsWithBody(ctx context.Context, params *PostWorkrequestsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkrequestsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkrequests(ctx context.Context, params *PostWorkrequestsParams, body PostWorkrequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkrequestsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkrequestsId(ctx context.Context, id int, params *DeleteWorkrequestsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkrequestsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkrequestsId(ctx context.Context, id int, params *GetWorkrequestsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkrequestsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchWorkrequestsIdWithBody(ctx context.Context, id int, params *PatchWorkrequestsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchWorkrequestsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchWorkrequestsId(ctx context.Context, id int, params *PatchWorkrequestsIdParams, body PatchWorkrequestsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchWorkrequestsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkrequestsIdAttachmentsFilename(ctx context.Context, id int, filename string, params *DeleteWorkrequestsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkrequestsIdAttachmentsFilenameRequest(c.Server, id, filename, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWorkrequestsIdAttachmentsFilenameWithBody(ctx context.Context, id int, filename string, params *PutWorkrequestsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWorkrequestsIdAttachmentsFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWorkrequestsIdThumbnailFilenameWithBody(ctx context.Context, id int, filename string, params *PutWorkrequestsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWorkrequestsIdThumbnailFilenameRequestWithBody(c.Server, id, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAssetcriticalitiesRequest generates requests for GetAssetcriticalities
func NewGetAssetcriticalitiesRequest(server string, params *GetAssetcriticalitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assetcriticalities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Label != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "label", runtime.ParamLocationQuery, *params.Label); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewGetAssetcriticalitiesIdRequest generates requests for GetAssetcriticalitiesId
func NewGetAssetcriticalitiesIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assetcriticalities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetcustomstatusesRequest generates requests for GetAssetcustomstatuses
func NewGetAssetcustomstatusesRequest(server string, params *GetAssetcustomstatusesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assetcustomstatuses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostAssetcustomstatusesRequest calls the generic PostAssetcustomstatuses builder with application/json body
func NewPostAssetcustomstatusesRequest(server string, params *PostAssetcustomstatusesParams, body PostAssetcustomstatusesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAssetcustomstatusesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAssetcustomstatusesRequestWithBody generates requests for PostAssetcustomstatuses with any type of body
func NewPostAssetcustomstatusesRequestWithBody(server string, params *PostAssetcustomstatusesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assetcustomstatuses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAssetcustomstatusesIdRequest generates requests for DeleteAssetcustomstatusesId
func NewDeleteAssetcustomstatusesIdRequest(server string, id int, params *DeleteAssetcustomstatusesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assetcustomstatuses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetcustomstatusesIdRequest generates requests for GetAssetcustomstatusesId
func NewGetAssetcustomstatusesIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assetcustomstatuses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchAssetcustomstatusesIdRequest calls the generic PatchAssetcustomstatusesId builder with application/json body
func NewPatchAssetcustomstatusesIdRequest(server string, id int, params *PatchAssetcustomstatusesIdParams, body PatchAssetcustomstatusesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchAssetcustomstatusesIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchAssetcustomstatusesIdRequestWithBody generates requests for PatchAssetcustomstatusesId with any type of body
func NewPatchAssetcustomstatusesIdRequestWithBody(server string, id int, params *PatchAssetcustomstatusesIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assetcustomstatuses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewGetAssetsRequest generates requests for GetAssets
func NewGetAssetsRequest(server string, params *GetAssetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFieldName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customFieldName", runtime.ParamLocationQuery, *params.CustomFieldName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locationId", runtime.ParamLocationQuery, *params.LocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostAssetsRequest calls the generic PostAssets builder with application/json body
func NewPostAssetsRequest(server string, params *PostAssetsParams, body PostAssetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAssetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAssetsRequestWithBody generates requests for PostAssets with any type of body
func NewPostAssetsRequestWithBody(server string, params *PostAssetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostAssetsAssetIdStatusRequest calls the generic PostAssetsAssetIdStatus builder with application/json body
func NewPostAssetsAssetIdStatusRequest(server string, assetId int, params *PostAssetsAssetIdStatusParams, body PostAssetsAssetIdStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAssetsAssetIdStatusRequestWithBody(server, assetId, params, "application/json", bodyReader)
}

// NewPostAssetsAssetIdStatusRequestWithBody generates requests for PostAssetsAssetIdStatus with any type of body
func NewPostAssetsAssetIdStatusRequestWithBody(server string, assetId int, params *PostAssetsAssetIdStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assetId", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAssetsIdRequest generates requests for DeleteAssetsId
func NewDeleteAssetsIdRequest(server string, id int, params *DeleteAssetsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetsIdRequest generates requests for GetAssetsId
func NewGetAssetsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchAssetsIdRequest calls the generic PatchAssetsId builder with application/json body
func NewPatchAssetsIdRequest(server string, id int, params *PatchAssetsIdParams, body PatchAssetsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchAssetsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchAssetsIdRequestWithBody generates requests for PatchAssetsId with any type of body
func NewPatchAssetsIdRequestWithBody(server string, id int, params *PatchAssetsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAssetsIdAttachmentsFilenameRequest generates requests for DeleteAssetsIdAttachmentsFilename
func NewDeleteAssetsIdAttachmentsFilenameRequest(server string, id int, filename string, params *DeleteAssetsIdAttachmentsFilenameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutAssetsIdAttachmentsFilenameRequestWithBody generates requests for PutAssetsIdAttachmentsFilename with any type of body
func NewPutAssetsIdAttachmentsFilenameRequestWithBody(server string, id int, filename string, params *PutAssetsIdAttachmentsFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutAssetsIdThumbnailFilenameRequestWithBody generates requests for PutAssetsIdThumbnailFilename with any type of body
func NewPutAssetsIdThumbnailFilenameRequestWithBody(server string, id int, filename string, params *PutAssetsIdThumbnailFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s/thumbnail/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAssetstatusesRequest generates requests for GetAssetstatuses
func NewGetAssetstatusesRequest(server string, params *GetAssetstatusesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assetstatuses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AssetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assetId", runtime.ParamLocationQuery, *params.AssetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPatchAssetstatusesIdRequest calls the generic PatchAssetstatusesId builder with application/json body
func NewPatchAssetstatusesIdRequest(server string, id int, params *PatchAssetstatusesIdParams, body PatchAssetstatusesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchAssetstatusesIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchAssetstatusesIdRequestWithBody generates requests for PatchAssetstatusesId with any type of body
func NewPatchAssetstatusesIdRequestWithBody(server string, id int, params *PatchAssetstatusesIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assetstatuses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewGetCategoriesRequest generates requests for GetCategories
func NewGetCategoriesRequest(server string, params *GetCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostCategoriesRequest calls the generic PostCategories builder with application/json body
func NewPostCategoriesRequest(server string, params *PostCategoriesParams, body PostCategoriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCategoriesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostCategoriesRequestWithBody generates requests for PostCategories with any type of body
func NewPostCategoriesRequestWithBody(server string, params *PostCategoriesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteCategoriesIdRequest generates requests for DeleteCategoriesId
func NewDeleteCategoriesIdRequest(server string, id int, params *DeleteCategoriesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCategoriesIdRequest generates requests for GetCategoriesId
func NewGetCategoriesIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchCategoriesIdRequest calls the generic PatchCategoriesId builder with application/json body
func NewPatchCategoriesIdRequest(server string, id int, params *PatchCategoriesIdParams, body PatchCategoriesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchCategoriesIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchCategoriesIdRequestWithBody generates requests for PatchCategoriesId with any type of body
func NewPatchCategoriesIdRequestWithBody(server string, id int, params *PatchCategoriesIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConversationsRequest generates requests for GetConversations
func NewGetConversationsRequest(server string, params *GetConversationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyNamed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "onlyNamed", runtime.ParamLocationQuery, *params.OnlyNamed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewGetConversationsIdMembersRequest generates requests for GetConversationsIdMembers
func NewGetConversationsIdMembersRequest(server string, id int, params *GetConversationsIdMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostConversationsIdMessagesRequest calls the generic PostConversationsIdMessages builder with application/json body
func NewPostConversationsIdMessagesRequest(server string, id int, params *PostConversationsIdMessagesParams, body PostConversationsIdMessagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostConversationsIdMessagesRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostConversationsIdMessagesRequestWithBody generates requests for PostConversationsIdMessages with any type of body
func NewPostConversationsIdMessagesRequestWithBody(server string, id int, params *PostConversationsIdMessagesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conversations/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomfieldsEntityRequest generates requests for GetCustomfieldsEntity
func NewGetCustomfieldsEntityRequest(server string, entity GetCustomfieldsEntityParamsEntity, params *GetCustomfieldsEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entity", runtime.ParamLocationPath, entity)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customfields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostCustomfieldsEntityRequest calls the generic PostCustomfieldsEntity builder with application/json body
func NewPostCustomfieldsEntityRequest(server string, entity PostCustomfieldsEntityParamsEntity, params *PostCustomfieldsEntityParams, body PostCustomfieldsEntityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomfieldsEntityRequestWithBody(server, entity, params, "application/json", bodyReader)
}

// NewPostCustomfieldsEntityRequestWithBody generates requests for PostCustomfieldsEntity with any type of body
func NewPostCustomfieldsEntityRequestWithBody(server string, entity PostCustomfieldsEntityParamsEntity, params *PostCustomfieldsEntityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entity", runtime.ParamLocationPath, entity)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customfields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteCustomfieldsEntityIdRequest generates requests for DeleteCustomfieldsEntityId
func NewDeleteCustomfieldsEntityIdRequest(server string, entity DeleteCustomfieldsEntityIdParamsEntity, id int, params *DeleteCustomfieldsEntityIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entity", runtime.ParamLocationPath, entity)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customfields/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchCustomfieldsEntityIdRequest calls the generic PatchCustomfieldsEntityId builder with application/json body
func NewPatchCustomfieldsEntityIdRequest(server string, entity PatchCustomfieldsEntityIdParamsEntity, id int, params *PatchCustomfieldsEntityIdParams, body PatchCustomfieldsEntityIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchCustomfieldsEntityIdRequestWithBody(server, entity, id, params, "application/json", bodyReader)
}

// NewPatchCustomfieldsEntityIdRequestWithBody generates requests for PatchCustomfieldsEntityId with any type of body
func NewPatchCustomfieldsEntityIdRequestWithBody(server string, entity PatchCustomfieldsEntityIdParamsEntity, id int, params *PatchCustomfieldsEntityIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entity", runtime.ParamLocationPath, entity)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customfields/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLocationsRequest generates requests for GetLocations
func NewGetLocationsRequest(server string, params *GetLocationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFieldName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customFieldName", runtime.ParamLocationQuery, *params.CustomFieldName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostLocationsRequest calls the generic PostLocations builder with application/json body
func NewPostLocationsRequest(server string, params *PostLocationsParams, body PostLocationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLocationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostLocationsRequestWithBody generates requests for PostLocations with any type of body
func NewPostLocationsRequestWithBody(server string, params *PostLocationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteLocationsIdRequest generates requests for DeleteLocationsId
func NewDeleteLocationsIdRequest(server string, id int, params *DeleteLocationsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationsIdRequest generates requests for GetLocationsId
func NewGetLocationsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchLocationsIdRequest calls the generic PatchLocationsId builder with application/json body
func NewPatchLocationsIdRequest(server string, id int, params *PatchLocationsIdParams, body PatchLocationsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLocationsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchLocationsIdRequestWithBody generates requests for PatchLocationsId with any type of body
func NewPatchLocationsIdRequestWithBody(server string, id int, params *PatchLocationsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLocationsIdAttachmentsFilenameRequest generates requests for DeleteLocationsIdAttachmentsFilename
func NewDeleteLocationsIdAttachmentsFilenameRequest(server string, id int, filename string, params *DeleteLocationsIdAttachmentsFilenameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutLocationsIdAttachmentsFilenameRequestWithBody generates requests for PutLocationsIdAttachmentsFilename with any type of body
func NewPutLocationsIdAttachmentsFilenameRequestWithBody(server string, id int, filename string, params *PutLocationsIdAttachmentsFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutLocationsIdThumbnailFilenameRequestWithBody generates requests for PutLocationsIdThumbnailFilename with any type of body
func NewPutLocationsIdThumbnailFilenameRequestWithBody(server string, id int, filename string, params *PutLocationsIdThumbnailFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/%s/thumbnail/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostMeterreadingsRequest calls the generic PostMeterreadings builder with application/json body
func NewPostMeterreadingsRequest(server string, params *PostMeterreadingsParams, body PostMeterreadingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMeterreadingsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostMeterreadingsRequestWithBody generates requests for PostMeterreadings with any type of body
func NewPostMeterreadingsRequestWithBody(server string, params *PostMeterreadingsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meterreadings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMetersRequest generates requests for GetMeters
func NewGetMetersRequest(server string, params *GetMetersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MeasurementType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "measurementType", runtime.ParamLocationQuery, *params.MeasurementType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostMetersRequest calls the generic PostMeters builder with application/json body
func NewPostMetersRequest(server string, params *PostMetersParams, body PostMetersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMetersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostMetersRequestWithBody generates requests for PostMeters with any type of body
func NewPostMetersRequestWithBody(server string, params *PostMetersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteMetersIdRequest generates requests for DeleteMetersId
func NewDeleteMetersIdRequest(server string, id int, params *DeleteMetersIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetersIdRequest generates requests for GetMetersId
func NewGetMetersIdRequest(server string, id int, params *GetMetersIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchMetersIdRequest calls the generic PatchMetersId builder with application/json body
func NewPatchMetersIdRequest(server string, id int, params *PatchMetersIdParams, body PatchMetersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchMetersIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchMetersIdRequestWithBody generates requests for PatchMetersId with any type of body
func NewPatchMetersIdRequestWithBody(server string, id int, params *PatchMetersIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostMetersMeterIdReadingsRequest calls the generic PostMetersMeterIdReadings builder with application/json body
func NewPostMetersMeterIdReadingsRequest(server string, meterId int, params *PostMetersMeterIdReadingsParams, body PostMetersMeterIdReadingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMetersMeterIdReadingsRequestWithBody(server, meterId, params, "application/json", bodyReader)
}

// NewPostMetersMeterIdReadingsRequestWithBody generates requests for PostMetersMeterIdReadings with any type of body
func NewPostMetersMeterIdReadingsRequestWithBody(server string, meterId int, params *PostMetersMeterIdReadingsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meterId", runtime.ParamLocationPath, meterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meters/%s/readings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMetertriggersRequest generates requests for GetMetertriggers
func NewGetMetertriggersRequest(server string, params *GetMetertriggersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metertriggers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Meters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meters", runtime.ParamLocationQuery, *params.Meters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostMetertriggersRequest calls the generic PostMetertriggers builder with application/json body
func NewPostMetertriggersRequest(server string, params *PostMetertriggersParams, body PostMetertriggersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMetertriggersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostMetertriggersRequestWithBody generates requests for PostMetertriggers with any type of body
func NewPostMetertriggersRequestWithBody(server string, params *PostMetertriggersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metertriggers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteMetertriggersIdRequest generates requests for DeleteMetertriggersId
func NewDeleteMetertriggersIdRequest(server string, id int, params *DeleteMetertriggersIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metertriggers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetertriggersIdRequest generates requests for GetMetertriggersId
func NewGetMetertriggersIdRequest(server string, id int, params *GetMetertriggersIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metertriggers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchMetertriggersIdRequest calls the generic PatchMetertriggersId builder with application/json body
func NewPatchMetertriggersIdRequest(server string, id int, params *PatchMetertriggersIdParams, body PatchMetertriggersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchMetertriggersIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchMetertriggersIdRequestWithBody generates requests for PatchMetertriggersId with any type of body
func NewPatchMetertriggersIdRequestWithBody(server string, id int, params *PatchMetertriggersIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metertriggers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutMetertriggersIdThumbnailFilenameRequestWithBody generates requests for PutMetertriggersIdThumbnailFilename with any type of body
func NewPutMetertriggersIdThumbnailFilenameRequestWithBody(server string, id int, filename string, params *PutMetertriggersIdThumbnailFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metertriggers/%s/thumbnail/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchMetertriggersIdWorkordertemplatesRequest calls the generic PatchMetertriggersIdWorkordertemplates builder with application/json body
func NewPatchMetertriggersIdWorkordertemplatesRequest(server string, id int, params *PatchMetertriggersIdWorkordertemplatesParams, body PatchMetertriggersIdWorkordertemplatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchMetertriggersIdWorkordertemplatesRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchMetertriggersIdWorkordertemplatesRequestWithBody generates requests for PatchMetertriggersIdWorkordertemplates with any type of body
func NewPatchMetertriggersIdWorkordertemplatesRequestWithBody(server string, id int, params *PatchMetertriggersIdWorkordertemplatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metertriggers/%s/workordertemplates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameRequest generates requests for DeleteMetertriggersIdWorkordertemplatesAttachmentsFilename
func NewDeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameRequest(server string, id int, filename string, params *DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metertriggers/%s/workordertemplates/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutMetertriggersIdWorkordertemplatesAttachmentsFilenameRequestWithBody generates requests for PutMetertriggersIdWorkordertemplatesAttachmentsFilename with any type of body
func NewPutMetertriggersIdWorkordertemplatesAttachmentsFilenameRequestWithBody(server string, id int, filename string, params *PutMetertriggersIdWorkordertemplatesAttachmentsFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metertriggers/%s/workordertemplates/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrganizationsRequest generates requests for GetOrganizations
func NewGetOrganizationsRequest(server string, params *GetOrganizationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPartsRequest generates requests for GetParts
func NewGetPartsRequest(server string, params *GetPartsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFieldName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customFieldName", runtime.ParamLocationQuery, *params.CustomFieldName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PartNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partNumber", runtime.ParamLocationQuery, *params.PartNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostPartsRequest calls the generic PostParts builder with application/json body
func NewPostPartsRequest(server string, params *PostPartsParams, body PostPartsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPartsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostPartsRequestWithBody generates requests for PostParts with any type of body
func NewPostPartsRequestWithBody(server string, params *PostPartsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeletePartsIdRequest generates requests for DeletePartsId
func NewDeletePartsIdRequest(server string, id int, params *DeletePartsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPartsIdRequest generates requests for GetPartsId
func NewGetPartsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchPartsIdRequest calls the generic PatchPartsId builder with application/json body
func NewPatchPartsIdRequest(server string, id int, params *PatchPartsIdParams, body PatchPartsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchPartsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchPartsIdRequestWithBody generates requests for PatchPartsId with any type of body
func NewPatchPartsIdRequestWithBody(server string, id int, params *PatchPartsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePartsIdAttachmentsFilenameRequest generates requests for DeletePartsIdAttachmentsFilename
func NewDeletePartsIdAttachmentsFilenameRequest(server string, id int, filename string, params *DeletePartsIdAttachmentsFilenameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutPartsIdAttachmentsFilenameRequestWithBody generates requests for PutPartsIdAttachmentsFilename with any type of body
func NewPutPartsIdAttachmentsFilenameRequestWithBody(server string, id int, filename string, params *PutPartsIdAttachmentsFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutPartsIdThumbnailFilenameRequestWithBody generates requests for PutPartsIdThumbnailFilename with any type of body
func NewPutPartsIdThumbnailFilenameRequestWithBody(server string, id int, filename string, params *PutPartsIdThumbnailFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parts/%s/thumbnail/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetParttransferrequestsRequest generates requests for GetParttransferrequests
func NewGetParttransferrequestsRequest(server string, params *GetParttransferrequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parttransferrequests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostParttransferrequestsRequest calls the generic PostParttransferrequests builder with application/json body
func NewPostParttransferrequestsRequest(server string, params *PostParttransferrequestsParams, body PostParttransferrequestsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostParttransferrequestsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostParttransferrequestsRequestWithBody generates requests for PostParttransferrequests with any type of body
func NewPostParttransferrequestsRequestWithBody(server string, params *PostParttransferrequestsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parttransferrequests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetParttransferrequestsIdRequest generates requests for GetParttransferrequestsId
func NewGetParttransferrequestsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parttransferrequests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchParttransferrequestsIdRequest calls the generic PatchParttransferrequestsId builder with application/json body
func NewPatchParttransferrequestsIdRequest(server string, id int, params *PatchParttransferrequestsIdParams, body PatchParttransferrequestsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchParttransferrequestsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchParttransferrequestsIdRequestWithBody generates requests for PatchParttransferrequestsId with any type of body
func NewPatchParttransferrequestsIdRequestWithBody(server string, id int, params *PatchParttransferrequestsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parttransferrequests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProceduretemplaterowsIdRequest generates requests for DeleteProceduretemplaterowsId
func NewDeleteProceduretemplaterowsIdRequest(server string, id int, params *DeleteProceduretemplaterowsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proceduretemplaterows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchProceduretemplaterowsIdRequest calls the generic PatchProceduretemplaterowsId builder with application/json body
func NewPatchProceduretemplaterowsIdRequest(server string, id int, params *PatchProceduretemplaterowsIdParams, body PatchProceduretemplaterowsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchProceduretemplaterowsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchProceduretemplaterowsIdRequestWithBody generates requests for PatchProceduretemplaterowsId with any type of body
func NewPatchProceduretemplaterowsIdRequestWithBody(server string, id int, params *PatchProceduretemplaterowsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proceduretemplaterows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProceduretemplaterowsIdAttachmentsRequest generates requests for DeleteProceduretemplaterowsIdAttachments
func NewDeleteProceduretemplaterowsIdAttachmentsRequest(server string, id int, params *DeleteProceduretemplaterowsIdAttachmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proceduretemplaterows/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutProceduretemplaterowsIdAttachmentsFilenameRequestWithBody generates requests for PutProceduretemplaterowsIdAttachmentsFilename with any type of body
func NewPutProceduretemplaterowsIdAttachmentsFilenameRequestWithBody(server string, id int, filename string, params *PutProceduretemplaterowsIdAttachmentsFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proceduretemplaterows/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewGetProceduretemplatesRequest generates requests for GetProceduretemplates
func NewGetProceduretemplatesRequest(server string, params *GetProceduretemplatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proceduretemplates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostProceduretemplatesRequest calls the generic PostProceduretemplates builder with application/json body
func NewPostProceduretemplatesRequest(server string, params *PostProceduretemplatesParams, body PostProceduretemplatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProceduretemplatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostProceduretemplatesRequestWithBody generates requests for PostProceduretemplates with any type of body
func NewPostProceduretemplatesRequestWithBody(server string, params *PostProceduretemplatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proceduretemplates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteProceduretemplatesIdRequest generates requests for DeleteProceduretemplatesId
func NewDeleteProceduretemplatesIdRequest(server string, id int, params *DeleteProceduretemplatesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proceduretemplates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProceduretemplatesIdRequest generates requests for GetProceduretemplatesId
func NewGetProceduretemplatesIdRequest(server string, id int, params *GetProceduretemplatesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proceduretemplates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchProceduretemplatesIdRequest calls the generic PatchProceduretemplatesId builder with application/json body
func NewPatchProceduretemplatesIdRequest(server string, id int, params *PatchProceduretemplatesIdParams, body PatchProceduretemplatesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchProceduretemplatesIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchProceduretemplatesIdRequestWithBody generates requests for PatchProceduretemplatesId with any type of body
func NewPatchProceduretemplatesIdRequestWithBody(server string, id int, params *PatchProceduretemplatesIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/proceduretemplates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPurchaseordersRequest generates requests for GetPurchaseorders
func NewGetPurchaseordersRequest(server string, params *GetPurchaseordersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/purchaseorders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFieldName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customFieldName", runtime.ParamLocationQuery, *params.CustomFieldName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostPurchaseordersRequest calls the generic PostPurchaseorders builder with application/json body
func NewPostPurchaseordersRequest(server string, params *PostPurchaseordersParams, body PostPurchaseordersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPurchaseordersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostPurchaseordersRequestWithBody generates requests for PostPurchaseorders with any type of body
func NewPostPurchaseordersRequestWithBody(server string, params *PostPurchaseordersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/purchaseorders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeletePurchaseordersIdRequest generates requests for DeletePurchaseordersId
func NewDeletePurchaseordersIdRequest(server string, id int, params *DeletePurchaseordersIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/purchaseorders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPurchaseordersIdRequest generates requests for GetPurchaseordersId
func NewGetPurchaseordersIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/purchaseorders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchPurchaseordersIdRequest calls the generic PatchPurchaseordersId builder with application/json body
func NewPatchPurchaseordersIdRequest(server string, id float32, params *PatchPurchaseordersIdParams, body PatchPurchaseordersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchPurchaseordersIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchPurchaseordersIdRequestWithBody generates requests for PatchPurchaseordersId with any type of body
func NewPatchPurchaseordersIdRequestWithBody(server string, id float32, params *PatchPurchaseordersIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/purchaseorders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePurchaseordersIdAttachmentsFilenameRequest generates requests for DeletePurchaseordersIdAttachmentsFilename
func NewDeletePurchaseordersIdAttachmentsFilenameRequest(server string, id int, filename string, params *DeletePurchaseordersIdAttachmentsFilenameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/purchaseorders/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutPurchaseordersIdAttachmentsFilenameRequestWithBody generates requests for PutPurchaseordersIdAttachmentsFilename with any type of body
func NewPutPurchaseordersIdAttachmentsFilenameRequestWithBody(server string, id int, filename string, params *PutPurchaseordersIdAttachmentsFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/purchaseorders/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPurchaseordersIdCommentsRequest calls the generic PostPurchaseordersIdComments builder with application/json body
func NewPostPurchaseordersIdCommentsRequest(server string, id int, params *PostPurchaseordersIdCommentsParams, body PostPurchaseordersIdCommentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPurchaseordersIdCommentsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostPurchaseordersIdCommentsRequestWithBody generates requests for PostPurchaseordersIdComments with any type of body
func NewPostPurchaseordersIdCommentsRequestWithBody(server string, id int, params *PostPurchaseordersIdCommentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/purchaseorders/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPurchaseordersIdEmailsRequest calls the generic PostPurchaseordersIdEmails builder with application/json body
func NewPostPurchaseordersIdEmailsRequest(server string, id int, params *PostPurchaseordersIdEmailsParams, body PostPurchaseordersIdEmailsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPurchaseordersIdEmailsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostPurchaseordersIdEmailsRequestWithBody generates requests for PostPurchaseordersIdEmails with any type of body
func NewPostPurchaseordersIdEmailsRequestWithBody(server string, id int, params *PostPurchaseordersIdEmailsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/purchaseorders/%s/emails", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchPurchaseordersIdFulfillmentRequest calls the generic PatchPurchaseordersIdFulfillment builder with application/json body
func NewPatchPurchaseordersIdFulfillmentRequest(server string, id float32, params *PatchPurchaseordersIdFulfillmentParams, body PatchPurchaseordersIdFulfillmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchPurchaseordersIdFulfillmentRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchPurchaseordersIdFulfillmentRequestWithBody generates requests for PatchPurchaseordersIdFulfillment with any type of body
func NewPatchPurchaseordersIdFulfillmentRequestWithBody(server string, id float32, params *PatchPurchaseordersIdFulfillmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/purchaseorders/%s/fulfillment", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchPurchaseordersIdStatusRequest calls the generic PatchPurchaseordersIdStatus builder with application/json body
func NewPatchPurchaseordersIdStatusRequest(server string, id float32, params *PatchPurchaseordersIdStatusParams, body PatchPurchaseordersIdStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchPurchaseordersIdStatusRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchPurchaseordersIdStatusRequestWithBody generates requests for PatchPurchaseordersIdStatus with any type of body
func NewPatchPurchaseordersIdStatusRequestWithBody(server string, id float32, params *PatchPurchaseordersIdStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/purchaseorders/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutPurchaseordersIdThumbnailFilenameRequestWithBody generates requests for PutPurchaseordersIdThumbnailFilename with any type of body
func NewPutPurchaseordersIdThumbnailFilenameRequestWithBody(server string, id int, filename string, params *PutPurchaseordersIdThumbnailFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/purchaseorders/%s/thumbnail/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSubscriptionsRequest calls the generic PostSubscriptions builder with application/json body
func NewPostSubscriptionsRequest(server string, params *PostSubscriptionsParams, body PostSubscriptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSubscriptionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostSubscriptionsRequestWithBody generates requests for PostSubscriptions with any type of body
func NewPostSubscriptionsRequestWithBody(server string, params *PostSubscriptionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteSubscriptionsIdRequest generates requests for DeleteSubscriptionsId
func NewDeleteSubscriptionsIdRequest(server string, id int, params *DeleteSubscriptionsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewGetSubscriptionsIdRequest generates requests for GetSubscriptionsId
func NewGetSubscriptionsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSubscriptionsIdRequest calls the generic PatchSubscriptionsId builder with application/json body
func NewPatchSubscriptionsIdRequest(server string, id int, params *PatchSubscriptionsIdParams, body PatchSubscriptionsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSubscriptionsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchSubscriptionsIdRequestWithBody generates requests for PatchSubscriptionsId with any type of body
func NewPatchSubscriptionsIdRequestWithBody(server string, id int, params *PatchSubscriptionsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewGetSubscriptionsIdSecretRequest generates requests for GetSubscriptionsIdSecret
func NewGetSubscriptionsIdSecretRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s/secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsRequest generates requests for GetTeams
func NewGetTeamsRequest(server string, params *GetTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostTeamsRequest calls the generic PostTeams builder with application/json body
func NewPostTeamsRequest(server string, params *PostTeamsParams, body PostTeamsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTeamsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostTeamsRequestWithBody generates requests for PostTeams with any type of body
func NewPostTeamsRequestWithBody(server string, params *PostTeamsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteTeamsIdRequest generates requests for DeleteTeamsId
func NewDeleteTeamsIdRequest(server string, id int, params *DeleteTeamsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsIdRequest generates requests for GetTeamsId
func NewGetTeamsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchTeamsIdRequest calls the generic PatchTeamsId builder with application/json body
func NewPatchTeamsIdRequest(server string, id int, params *PatchTeamsIdParams, body PatchTeamsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchTeamsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchTeamsIdRequestWithBody generates requests for PatchTeamsId with any type of body
func NewPatchTeamsIdRequestWithBody(server string, id int, params *PatchTeamsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamsIdMembersRequest generates requests for GetTeamsIdMembers
func NewGetTeamsIdMembersRequest(server string, id int, params *GetTeamsIdMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTeamsIdMembersRequest calls the generic PostTeamsIdMembers builder with application/json body
func NewPostTeamsIdMembersRequest(server string, id int, params *PostTeamsIdMembersParams, body PostTeamsIdMembersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTeamsIdMembersRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostTeamsIdMembersRequestWithBody generates requests for PostTeamsIdMembers with any type of body
func NewPostTeamsIdMembersRequestWithBody(server string, id int, params *PostTeamsIdMembersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTeamsTeamIdMembersUserIdRequest generates requests for DeleteTeamsTeamIdMembersUserId
func NewDeleteTeamsTeamIdMembersUserIdRequest(server string, teamId int, userId int, params *DeleteTeamsTeamIdMembersUserIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchTeamsTeamIdMembersUserIdRequest calls the generic PatchTeamsTeamIdMembersUserId builder with application/json body
func NewPatchTeamsTeamIdMembersUserIdRequest(server string, teamId int, userId int, params *PatchTeamsTeamIdMembersUserIdParams, body PatchTeamsTeamIdMembersUserIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchTeamsTeamIdMembersUserIdRequestWithBody(server, teamId, userId, params, "application/json", bodyReader)
}

// NewPatchTeamsTeamIdMembersUserIdRequestWithBody generates requests for PatchTeamsTeamIdMembersUserId with any type of body
func NewPatchTeamsTeamIdMembersUserIdRequestWithBody(server string, teamId int, userId int, params *PatchTeamsTeamIdMembersUserIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyAssignable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "onlyAssignable", runtime.ParamLocationQuery, *params.OnlyAssignable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostUsersRequest calls the generic PostUsers builder with application/json body
func NewPostUsersRequest(server string, params *PostUsersParams, body PostUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUsersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostUsersRequestWithBody generates requests for PostUsers with any type of body
func NewPostUsersRequestWithBody(server string, params *PostUsersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteUsersIdRequest generates requests for DeleteUsersId
func NewDeleteUsersIdRequest(server string, id int, params *DeleteUsersIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewGetUsersIdRequest generates requests for GetUsersId
func NewGetUsersIdRequest(server string, id int, params *GetUsersIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPatchUsersIdRequest calls the generic PatchUsersId builder with application/json body
func NewPatchUsersIdRequest(server string, id int, params *PatchUsersIdParams, body PatchUsersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUsersIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchUsersIdRequestWithBody generates requests for PatchUsersId with any type of body
func NewPatchUsersIdRequestWithBody(server string, id int, params *PatchUsersIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostUsersIdMessagesRequest calls the generic PostUsersIdMessages builder with application/json body
func NewPostUsersIdMessagesRequest(server string, id int, params *PostUsersIdMessagesParams, body PostUsersIdMessagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUsersIdMessagesRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostUsersIdMessagesRequestWithBody generates requests for PostUsersIdMessages with any type of body
func NewPostUsersIdMessagesRequestWithBody(server string, id int, params *PostUsersIdMessagesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewGetVendorsRequest generates requests for GetVendors
func NewGetVendorsRequest(server string, params *GetVendorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomFieldName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customFieldName", runtime.ParamLocationQuery, *params.CustomFieldName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostVendorsRequest calls the generic PostVendors builder with application/json body
func NewPostVendorsRequest(server string, params *PostVendorsParams, body PostVendorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostVendorsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostVendorsRequestWithBody generates requests for PostVendors with any type of body
func NewPostVendorsRequestWithBody(server string, params *PostVendorsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteVendorsIdRequest generates requests for DeleteVendorsId
func NewDeleteVendorsIdRequest(server string, id int, params *DeleteVendorsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVendorsIdRequest generates requests for GetVendorsId
func NewGetVendorsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchVendorsIdRequest calls the generic PatchVendorsId builder with application/json body
func NewPatchVendorsIdRequest(server string, id int, params *PatchVendorsIdParams, body PatchVendorsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchVendorsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchVendorsIdRequestWithBody generates requests for PatchVendorsId with any type of body
func NewPatchVendorsIdRequestWithBody(server string, id int, params *PatchVendorsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVendorsIdAttachmentsFilenameRequest generates requests for DeleteVendorsIdAttachmentsFilename
func NewDeleteVendorsIdAttachmentsFilenameRequest(server string, id int, filename string, params *DeleteVendorsIdAttachmentsFilenameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendors/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutVendorsIdAttachmentsFilenameRequestWithBody generates requests for PutVendorsIdAttachmentsFilename with any type of body
func NewPutVendorsIdAttachmentsFilenameRequestWithBody(server string, id int, filename string, params *PutVendorsIdAttachmentsFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendors/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVendorsIdContactsRequest generates requests for GetVendorsIdContacts
func NewGetVendorsIdContactsRequest(server string, id int, params *GetVendorsIdContactsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendors/%s/contacts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostVendorsIdContactsRequest calls the generic PostVendorsIdContacts builder with application/json body
func NewPostVendorsIdContactsRequest(server string, id int, params *PostVendorsIdContactsParams, body PostVendorsIdContactsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostVendorsIdContactsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostVendorsIdContactsRequestWithBody generates requests for PostVendorsIdContacts with any type of body
func NewPostVendorsIdContactsRequestWithBody(server string, id int, params *PostVendorsIdContactsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendors/%s/contacts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVendorsIdContactsContactIdRequest generates requests for DeleteVendorsIdContactsContactId
func NewDeleteVendorsIdContactsContactIdRequest(server string, id int, contactId int, params *DeleteVendorsIdContactsContactIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contactId", runtime.ParamLocationPath, contactId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendors/%s/contacts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVendorsIdContactsContactIdRequest generates requests for GetVendorsIdContactsContactId
func NewGetVendorsIdContactsContactIdRequest(server string, id int, contactId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contactId", runtime.ParamLocationPath, contactId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendors/%s/contacts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchVendorsIdContactsContactIdRequest calls the generic PatchVendorsIdContactsContactId builder with application/json body
func NewPatchVendorsIdContactsContactIdRequest(server string, id int, contactId int, params *PatchVendorsIdContactsContactIdParams, body PatchVendorsIdContactsContactIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchVendorsIdContactsContactIdRequestWithBody(server, id, contactId, params, "application/json", bodyReader)
}

// NewPatchVendorsIdContactsContactIdRequestWithBody generates requests for PatchVendorsIdContactsContactId with any type of body
func NewPatchVendorsIdContactsContactIdRequestWithBody(server string, id int, contactId int, params *PatchVendorsIdContactsContactIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contactId", runtime.ParamLocationPath, contactId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendors/%s/contacts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutVendorsIdThumbnailFilenameRequestWithBody generates requests for PutVendorsIdThumbnailFilename with any type of body
func NewPutVendorsIdThumbnailFilenameRequestWithBody(server string, id int, filename string, params *PutVendorsIdThumbnailFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendors/%s/thumbnail/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVersionsRequest generates requests for GetVersions
func NewGetVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostWorkPermitsIdSignRequest calls the generic PostWorkPermitsIdSign builder with application/json body
func NewPostWorkPermitsIdSignRequest(server string, id int, params *PostWorkPermitsIdSignParams, body PostWorkPermitsIdSignJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWorkPermitsIdSignRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostWorkPermitsIdSignRequestWithBody generates requests for PostWorkPermitsIdSign with any type of body
func NewPostWorkPermitsIdSignRequestWithBody(server string, id int, params *PostWorkPermitsIdSignParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workPermits/%s/sign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkordersRequest generates requests for GetWorkorders
func NewGetWorkordersRequest(server string, params *GetWorkordersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Assets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assets", runtime.ParamLocationQuery, *params.Assets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Assignees != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assignees", runtime.ParamLocationQuery, *params.Assignees); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Categories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories", runtime.ParamLocationQuery, *params.Categories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Locations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locations", runtime.ParamLocationQuery, *params.Locations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NotAssets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notAssets", runtime.ParamLocationQuery, *params.NotAssets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NotCategories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notCategories", runtime.ParamLocationQuery, *params.NotCategories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NotLocations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notLocations", runtime.ParamLocationQuery, *params.NotLocations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NotParts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notParts", runtime.ParamLocationQuery, *params.NotParts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NotVendors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notVendors", runtime.ParamLocationQuery, *params.NotVendors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Parts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parts", runtime.ParamLocationQuery, *params.Parts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Priorities != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "priorities", runtime.ParamLocationQuery, *params.Priorities); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowUpcoming != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_upcoming", runtime.ParamLocationQuery, *params.ShowUpcoming); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Teams != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "teams", runtime.ParamLocationQuery, *params.Teams); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Vendors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vendors", runtime.ParamLocationQuery, *params.Vendors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostWorkordersRequest calls the generic PostWorkorders builder with application/json body
func NewPostWorkordersRequest(server string, params *PostWorkordersParams, body PostWorkordersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWorkordersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostWorkordersRequestWithBody generates requests for PostWorkorders with any type of body
func NewPostWorkordersRequestWithBody(server string, params *PostWorkordersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteWorkordersIdRequest generates requests for DeleteWorkordersId
func NewDeleteWorkordersIdRequest(server string, id int, params *DeleteWorkordersIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkordersIdRequest generates requests for GetWorkordersId
func NewGetWorkordersIdRequest(server string, id int, params *GetWorkordersIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UseSequentialId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useSequentialId", runtime.ParamLocationQuery, *params.UseSequentialId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchWorkordersIdRequest calls the generic PatchWorkordersId builder with application/json body
func NewPatchWorkordersIdRequest(server string, id int, params *PatchWorkordersIdParams, body PatchWorkordersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchWorkordersIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchWorkordersIdRequestWithBody generates requests for PatchWorkordersId with any type of body
func NewPatchWorkordersIdRequestWithBody(server string, id int, params *PatchWorkordersIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkordersIdAttachmentsFilenameRequest generates requests for DeleteWorkordersIdAttachmentsFilename
func NewDeleteWorkordersIdAttachmentsFilenameRequest(server string, id int, filename string, params *DeleteWorkordersIdAttachmentsFilenameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutWorkordersIdAttachmentsFilenameRequestWithBody generates requests for PutWorkordersIdAttachmentsFilename with any type of body
func NewPutWorkordersIdAttachmentsFilenameRequestWithBody(server string, id int, filename string, params *PutWorkordersIdAttachmentsFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkordersIdCommentsRequest generates requests for GetWorkordersIdComments
func NewGetWorkordersIdCommentsRequest(server string, id int, params *GetWorkordersIdCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostWorkordersIdCommentsRequest calls the generic PostWorkordersIdComments builder with application/json body
func NewPostWorkordersIdCommentsRequest(server string, id int, params *PostWorkordersIdCommentsParams, body PostWorkordersIdCommentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWorkordersIdCommentsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostWorkordersIdCommentsRequestWithBody generates requests for PostWorkordersIdComments with any type of body
func NewPostWorkordersIdCommentsRequestWithBody(server string, id int, params *PostWorkordersIdCommentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkordersIdCostsRequest generates requests for GetWorkordersIdCosts
func NewGetWorkordersIdCostsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s/costs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostWorkordersIdCostsRequest calls the generic PostWorkordersIdCosts builder with application/json body
func NewPostWorkordersIdCostsRequest(server string, id int, params *PostWorkordersIdCostsParams, body PostWorkordersIdCostsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWorkordersIdCostsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostWorkordersIdCostsRequestWithBody generates requests for PostWorkordersIdCosts with any type of body
func NewPostWorkordersIdCostsRequestWithBody(server string, id int, params *PostWorkordersIdCostsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s/costs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostWorkordersIdEmailsRequest calls the generic PostWorkordersIdEmails builder with application/json body
func NewPostWorkordersIdEmailsRequest(server string, id int, params *PostWorkordersIdEmailsParams, body PostWorkordersIdEmailsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWorkordersIdEmailsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostWorkordersIdEmailsRequestWithBody generates requests for PostWorkordersIdEmails with any type of body
func NewPostWorkordersIdEmailsRequestWithBody(server string, id int, params *PostWorkordersIdEmailsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s/emails", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkordersIdProcedureRequest generates requests for DeleteWorkordersIdProcedure
func NewDeleteWorkordersIdProcedureRequest(server string, id int, params *DeleteWorkordersIdProcedureParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s/procedure", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteWorkordersIdProcedureFieldsIndexAttachmentRequest generates requests for DeleteWorkordersIdProcedureFieldsIndexAttachment
func NewDeleteWorkordersIdProcedureFieldsIndexAttachmentRequest(server string, id int, index int, params *DeleteWorkordersIdProcedureFieldsIndexAttachmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s/procedure/fields/%s/attachment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutWorkordersIdProcedureFieldsIndexAttachmentFilenameRequestWithBody generates requests for PutWorkordersIdProcedureFieldsIndexAttachmentFilename with any type of body
func NewPutWorkordersIdProcedureFieldsIndexAttachmentFilenameRequestWithBody(server string, id int, index int, filename string, params *PutWorkordersIdProcedureFieldsIndexAttachmentFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s/procedure/fields/%s/attachment/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchWorkordersIdStatusRequest calls the generic PatchWorkordersIdStatus builder with application/json body
func NewPatchWorkordersIdStatusRequest(server string, id int, params *PatchWorkordersIdStatusParams, body PatchWorkordersIdStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchWorkordersIdStatusRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchWorkordersIdStatusRequestWithBody generates requests for PatchWorkordersIdStatus with any type of body
func NewPatchWorkordersIdStatusRequestWithBody(server string, id int, params *PatchWorkordersIdStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkordersIdSubworkordersRequest generates requests for GetWorkordersIdSubworkorders
func NewGetWorkordersIdSubworkordersRequest(server string, id int, params *GetWorkordersIdSubworkordersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s/subworkorders", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutWorkordersIdThumbnailFilenameRequestWithBody generates requests for PutWorkordersIdThumbnailFilename with any type of body
func NewPutWorkordersIdThumbnailFilenameRequestWithBody(server string, id int, filename string, params *PutWorkordersIdThumbnailFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workorders/%s/thumbnail/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkrequestportalsRequest generates requests for GetWorkrequestportals
func NewGetWorkrequestportalsRequest(server string, params *GetWorkrequestportalsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workrequestportals")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostWorkrequestportalsRequest calls the generic PostWorkrequestportals builder with application/json body
func NewPostWorkrequestportalsRequest(server string, params *PostWorkrequestportalsParams, body PostWorkrequestportalsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWorkrequestportalsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostWorkrequestportalsRequestWithBody generates requests for PostWorkrequestportals with any type of body
func NewPostWorkrequestportalsRequestWithBody(server string, params *PostWorkrequestportalsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workrequestportals")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteWorkrequestportalsIdRequest generates requests for DeleteWorkrequestportalsId
func NewDeleteWorkrequestportalsIdRequest(server string, id int, params *DeleteWorkrequestportalsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workrequestportals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkrequestportalsIdRequest generates requests for GetWorkrequestportalsId
func NewGetWorkrequestportalsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workrequestportals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchWorkrequestportalsIdRequest calls the generic PatchWorkrequestportalsId builder with application/json body
func NewPatchWorkrequestportalsIdRequest(server string, id int, params *PatchWorkrequestportalsIdParams, body PatchWorkrequestportalsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchWorkrequestportalsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchWorkrequestportalsIdRequestWithBody generates requests for PatchWorkrequestportalsId with any type of body
func NewPatchWorkrequestportalsIdRequestWithBody(server string, id int, params *PatchWorkrequestportalsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workrequestportals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkrequestsRequest generates requests for GetWorkrequests
func NewGetWorkrequestsRequest(server string, params *GetWorkrequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workrequests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Assets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assets", runtime.ParamLocationQuery, *params.Assets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Locations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locations", runtime.ParamLocationQuery, *params.Locations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Priorities != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "priorities", runtime.ParamLocationQuery, *params.Priorities); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewPostWorkrequestsRequest calls the generic PostWorkrequests builder with application/json body
func NewPostWorkrequestsRequest(server string, params *PostWorkrequestsParams, body PostWorkrequestsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWorkrequestsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostWorkrequestsRequestWithBody generates requests for PostWorkrequests with any type of body
func NewPostWorkrequestsRequestWithBody(server string, params *PostWorkrequestsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workrequests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XOrganizationId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-organization-id", runtime.ParamLocationHeader, *params.XOrganizationId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-organization-id", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteWorkrequestsIdRequest generates requests for DeleteWorkrequestsId
func NewDeleteWorkrequestsIdRequest(server string, id int, params *DeleteWorkrequestsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workrequests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkrequestsIdRequest generates requests for GetWorkrequestsId
func NewGetWorkrequestsIdRequest(server string, id int, params *GetWorkrequestsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workrequests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchWorkrequestsIdRequest calls the generic PatchWorkrequestsId builder with application/json body
func NewPatchWorkrequestsIdRequest(server string, id int, params *PatchWorkrequestsIdParams, body PatchWorkrequestsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchWorkrequestsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchWorkrequestsIdRequestWithBody generates requests for PatchWorkrequestsId with any type of body
func NewPatchWorkrequestsIdRequestWithBody(server string, id int, params *PatchWorkrequestsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workrequests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkrequestsIdAttachmentsFilenameRequest generates requests for DeleteWorkrequestsIdAttachmentsFilename
func NewDeleteWorkrequestsIdAttachmentsFilenameRequest(server string, id int, filename string, params *DeleteWorkrequestsIdAttachmentsFilenameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workrequests/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutWorkrequestsIdAttachmentsFilenameRequestWithBody generates requests for PutWorkrequestsIdAttachmentsFilename with any type of body
func NewPutWorkrequestsIdAttachmentsFilenameRequestWithBody(server string, id int, filename string, params *PutWorkrequestsIdAttachmentsFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workrequests/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutWorkrequestsIdThumbnailFilenameRequestWithBody generates requests for PutWorkrequestsIdThumbnailFilename with any type of body
func NewPutWorkrequestsIdThumbnailFilenameRequestWithBody(server string, id int, filename string, params *PutWorkrequestsIdThumbnailFilenameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workrequests/%s/thumbnail/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipWebhook != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipWebhook", runtime.ParamLocationQuery, *params.SkipWebhook); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAssetcriticalitiesWithResponse request
	GetAssetcriticalitiesWithResponse(ctx context.Context, params *GetAssetcriticalitiesParams, reqEditors ...RequestEditorFn) (*GetAssetcriticalitiesResponse, error)

	// GetAssetcriticalitiesIdWithResponse request
	GetAssetcriticalitiesIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAssetcriticalitiesIdResponse, error)

	// GetAssetcustomstatusesWithResponse request
	GetAssetcustomstatusesWithResponse(ctx context.Context, params *GetAssetcustomstatusesParams, reqEditors ...RequestEditorFn) (*GetAssetcustomstatusesResponse, error)

	// PostAssetcustomstatusesWithBodyWithResponse request with any body
	PostAssetcustomstatusesWithBodyWithResponse(ctx context.Context, params *PostAssetcustomstatusesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAssetcustomstatusesResponse, error)

	PostAssetcustomstatusesWithResponse(ctx context.Context, params *PostAssetcustomstatusesParams, body PostAssetcustomstatusesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAssetcustomstatusesResponse, error)

	// DeleteAssetcustomstatusesIdWithResponse request
	DeleteAssetcustomstatusesIdWithResponse(ctx context.Context, id int, params *DeleteAssetcustomstatusesIdParams, reqEditors ...RequestEditorFn) (*DeleteAssetcustomstatusesIdResponse, error)

	// GetAssetcustomstatusesIdWithResponse request
	GetAssetcustomstatusesIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAssetcustomstatusesIdResponse, error)

	// PatchAssetcustomstatusesIdWithBodyWithResponse request with any body
	PatchAssetcustomstatusesIdWithBodyWithResponse(ctx context.Context, id int, params *PatchAssetcustomstatusesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAssetcustomstatusesIdResponse, error)

	PatchAssetcustomstatusesIdWithResponse(ctx context.Context, id int, params *PatchAssetcustomstatusesIdParams, body PatchAssetcustomstatusesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAssetcustomstatusesIdResponse, error)

	// GetAssetsWithResponse request
	GetAssetsWithResponse(ctx context.Context, params *GetAssetsParams, reqEditors ...RequestEditorFn) (*GetAssetsResponse, error)

	// PostAssetsWithBodyWithResponse request with any body
	PostAssetsWithBodyWithResponse(ctx context.Context, params *PostAssetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAssetsResponse, error)

	PostAssetsWithResponse(ctx context.Context, params *PostAssetsParams, body PostAssetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAssetsResponse, error)

	// PostAssetsAssetIdStatusWithBodyWithResponse request with any body
	PostAssetsAssetIdStatusWithBodyWithResponse(ctx context.Context, assetId int, params *PostAssetsAssetIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAssetsAssetIdStatusResponse, error)

	PostAssetsAssetIdStatusWithResponse(ctx context.Context, assetId int, params *PostAssetsAssetIdStatusParams, body PostAssetsAssetIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAssetsAssetIdStatusResponse, error)

	// DeleteAssetsIdWithResponse request
	DeleteAssetsIdWithResponse(ctx context.Context, id int, params *DeleteAssetsIdParams, reqEditors ...RequestEditorFn) (*DeleteAssetsIdResponse, error)

	// GetAssetsIdWithResponse request
	GetAssetsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAssetsIdResponse, error)

	// PatchAssetsIdWithBodyWithResponse request with any body
	PatchAssetsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchAssetsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAssetsIdResponse, error)

	PatchAssetsIdWithResponse(ctx context.Context, id int, params *PatchAssetsIdParams, body PatchAssetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAssetsIdResponse, error)

	// DeleteAssetsIdAttachmentsFilenameWithResponse request
	DeleteAssetsIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeleteAssetsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeleteAssetsIdAttachmentsFilenameResponse, error)

	// PutAssetsIdAttachmentsFilenameWithBodyWithResponse request with any body
	PutAssetsIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutAssetsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAssetsIdAttachmentsFilenameResponse, error)

	// PutAssetsIdThumbnailFilenameWithBodyWithResponse request with any body
	PutAssetsIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutAssetsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAssetsIdThumbnailFilenameResponse, error)

	// GetAssetstatusesWithResponse request
	GetAssetstatusesWithResponse(ctx context.Context, params *GetAssetstatusesParams, reqEditors ...RequestEditorFn) (*GetAssetstatusesResponse, error)

	// PatchAssetstatusesIdWithBodyWithResponse request with any body
	PatchAssetstatusesIdWithBodyWithResponse(ctx context.Context, id int, params *PatchAssetstatusesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAssetstatusesIdResponse, error)

	PatchAssetstatusesIdWithResponse(ctx context.Context, id int, params *PatchAssetstatusesIdParams, body PatchAssetstatusesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAssetstatusesIdResponse, error)

	// GetCategoriesWithResponse request
	GetCategoriesWithResponse(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*GetCategoriesResponse, error)

	// PostCategoriesWithBodyWithResponse request with any body
	PostCategoriesWithBodyWithResponse(ctx context.Context, params *PostCategoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCategoriesResponse, error)

	PostCategoriesWithResponse(ctx context.Context, params *PostCategoriesParams, body PostCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCategoriesResponse, error)

	// DeleteCategoriesIdWithResponse request
	DeleteCategoriesIdWithResponse(ctx context.Context, id int, params *DeleteCategoriesIdParams, reqEditors ...RequestEditorFn) (*DeleteCategoriesIdResponse, error)

	// GetCategoriesIdWithResponse request
	GetCategoriesIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCategoriesIdResponse, error)

	// PatchCategoriesIdWithBodyWithResponse request with any body
	PatchCategoriesIdWithBodyWithResponse(ctx context.Context, id int, params *PatchCategoriesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchCategoriesIdResponse, error)

	PatchCategoriesIdWithResponse(ctx context.Context, id int, params *PatchCategoriesIdParams, body PatchCategoriesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchCategoriesIdResponse, error)

	// GetConversationsWithResponse request
	GetConversationsWithResponse(ctx context.Context, params *GetConversationsParams, reqEditors ...RequestEditorFn) (*GetConversationsResponse, error)

	// GetConversationsIdMembersWithResponse request
	GetConversationsIdMembersWithResponse(ctx context.Context, id int, params *GetConversationsIdMembersParams, reqEditors ...RequestEditorFn) (*GetConversationsIdMembersResponse, error)

	// PostConversationsIdMessagesWithBodyWithResponse request with any body
	PostConversationsIdMessagesWithBodyWithResponse(ctx context.Context, id int, params *PostConversationsIdMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostConversationsIdMessagesResponse, error)

	PostConversationsIdMessagesWithResponse(ctx context.Context, id int, params *PostConversationsIdMessagesParams, body PostConversationsIdMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostConversationsIdMessagesResponse, error)

	// GetCustomfieldsEntityWithResponse request
	GetCustomfieldsEntityWithResponse(ctx context.Context, entity GetCustomfieldsEntityParamsEntity, params *GetCustomfieldsEntityParams, reqEditors ...RequestEditorFn) (*GetCustomfieldsEntityResponse, error)

	// PostCustomfieldsEntityWithBodyWithResponse request with any body
	PostCustomfieldsEntityWithBodyWithResponse(ctx context.Context, entity PostCustomfieldsEntityParamsEntity, params *PostCustomfieldsEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomfieldsEntityResponse, error)

	PostCustomfieldsEntityWithResponse(ctx context.Context, entity PostCustomfieldsEntityParamsEntity, params *PostCustomfieldsEntityParams, body PostCustomfieldsEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomfieldsEntityResponse, error)

	// DeleteCustomfieldsEntityIdWithResponse request
	DeleteCustomfieldsEntityIdWithResponse(ctx context.Context, entity DeleteCustomfieldsEntityIdParamsEntity, id int, params *DeleteCustomfieldsEntityIdParams, reqEditors ...RequestEditorFn) (*DeleteCustomfieldsEntityIdResponse, error)

	// PatchCustomfieldsEntityIdWithBodyWithResponse request with any body
	PatchCustomfieldsEntityIdWithBodyWithResponse(ctx context.Context, entity PatchCustomfieldsEntityIdParamsEntity, id int, params *PatchCustomfieldsEntityIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchCustomfieldsEntityIdResponse, error)

	PatchCustomfieldsEntityIdWithResponse(ctx context.Context, entity PatchCustomfieldsEntityIdParamsEntity, id int, params *PatchCustomfieldsEntityIdParams, body PatchCustomfieldsEntityIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchCustomfieldsEntityIdResponse, error)

	// GetLocationsWithResponse request
	GetLocationsWithResponse(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*GetLocationsResponse, error)

	// PostLocationsWithBodyWithResponse request with any body
	PostLocationsWithBodyWithResponse(ctx context.Context, params *PostLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLocationsResponse, error)

	PostLocationsWithResponse(ctx context.Context, params *PostLocationsParams, body PostLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLocationsResponse, error)

	// DeleteLocationsIdWithResponse request
	DeleteLocationsIdWithResponse(ctx context.Context, id int, params *DeleteLocationsIdParams, reqEditors ...RequestEditorFn) (*DeleteLocationsIdResponse, error)

	// GetLocationsIdWithResponse request
	GetLocationsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetLocationsIdResponse, error)

	// PatchLocationsIdWithBodyWithResponse request with any body
	PatchLocationsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchLocationsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLocationsIdResponse, error)

	PatchLocationsIdWithResponse(ctx context.Context, id int, params *PatchLocationsIdParams, body PatchLocationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLocationsIdResponse, error)

	// DeleteLocationsIdAttachmentsFilenameWithResponse request
	DeleteLocationsIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeleteLocationsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeleteLocationsIdAttachmentsFilenameResponse, error)

	// PutLocationsIdAttachmentsFilenameWithBodyWithResponse request with any body
	PutLocationsIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutLocationsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutLocationsIdAttachmentsFilenameResponse, error)

	// PutLocationsIdThumbnailFilenameWithBodyWithResponse request with any body
	PutLocationsIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutLocationsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutLocationsIdThumbnailFilenameResponse, error)

	// PostMeterreadingsWithBodyWithResponse request with any body
	PostMeterreadingsWithBodyWithResponse(ctx context.Context, params *PostMeterreadingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMeterreadingsResponse, error)

	PostMeterreadingsWithResponse(ctx context.Context, params *PostMeterreadingsParams, body PostMeterreadingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMeterreadingsResponse, error)

	// GetMetersWithResponse request
	GetMetersWithResponse(ctx context.Context, params *GetMetersParams, reqEditors ...RequestEditorFn) (*GetMetersResponse, error)

	// PostMetersWithBodyWithResponse request with any body
	PostMetersWithBodyWithResponse(ctx context.Context, params *PostMetersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMetersResponse, error)

	PostMetersWithResponse(ctx context.Context, params *PostMetersParams, body PostMetersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMetersResponse, error)

	// DeleteMetersIdWithResponse request
	DeleteMetersIdWithResponse(ctx context.Context, id int, params *DeleteMetersIdParams, reqEditors ...RequestEditorFn) (*DeleteMetersIdResponse, error)

	// GetMetersIdWithResponse request
	GetMetersIdWithResponse(ctx context.Context, id int, params *GetMetersIdParams, reqEditors ...RequestEditorFn) (*GetMetersIdResponse, error)

	// PatchMetersIdWithBodyWithResponse request with any body
	PatchMetersIdWithBodyWithResponse(ctx context.Context, id int, params *PatchMetersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchMetersIdResponse, error)

	PatchMetersIdWithResponse(ctx context.Context, id int, params *PatchMetersIdParams, body PatchMetersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchMetersIdResponse, error)

	// PostMetersMeterIdReadingsWithBodyWithResponse request with any body
	PostMetersMeterIdReadingsWithBodyWithResponse(ctx context.Context, meterId int, params *PostMetersMeterIdReadingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMetersMeterIdReadingsResponse, error)

	PostMetersMeterIdReadingsWithResponse(ctx context.Context, meterId int, params *PostMetersMeterIdReadingsParams, body PostMetersMeterIdReadingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMetersMeterIdReadingsResponse, error)

	// GetMetertriggersWithResponse request
	GetMetertriggersWithResponse(ctx context.Context, params *GetMetertriggersParams, reqEditors ...RequestEditorFn) (*GetMetertriggersResponse, error)

	// PostMetertriggersWithBodyWithResponse request with any body
	PostMetertriggersWithBodyWithResponse(ctx context.Context, params *PostMetertriggersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMetertriggersResponse, error)

	PostMetertriggersWithResponse(ctx context.Context, params *PostMetertriggersParams, body PostMetertriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMetertriggersResponse, error)

	// DeleteMetertriggersIdWithResponse request
	DeleteMetertriggersIdWithResponse(ctx context.Context, id int, params *DeleteMetertriggersIdParams, reqEditors ...RequestEditorFn) (*DeleteMetertriggersIdResponse, error)

	// GetMetertriggersIdWithResponse request
	GetMetertriggersIdWithResponse(ctx context.Context, id int, params *GetMetertriggersIdParams, reqEditors ...RequestEditorFn) (*GetMetertriggersIdResponse, error)

	// PatchMetertriggersIdWithBodyWithResponse request with any body
	PatchMetertriggersIdWithBodyWithResponse(ctx context.Context, id int, params *PatchMetertriggersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchMetertriggersIdResponse, error)

	PatchMetertriggersIdWithResponse(ctx context.Context, id int, params *PatchMetertriggersIdParams, body PatchMetertriggersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchMetertriggersIdResponse, error)

	// PutMetertriggersIdThumbnailFilenameWithBodyWithResponse request with any body
	PutMetertriggersIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutMetertriggersIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutMetertriggersIdThumbnailFilenameResponse, error)

	// PatchMetertriggersIdWorkordertemplatesWithBodyWithResponse request with any body
	PatchMetertriggersIdWorkordertemplatesWithBodyWithResponse(ctx context.Context, id int, params *PatchMetertriggersIdWorkordertemplatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchMetertriggersIdWorkordertemplatesResponse, error)

	PatchMetertriggersIdWorkordertemplatesWithResponse(ctx context.Context, id int, params *PatchMetertriggersIdWorkordertemplatesParams, body PatchMetertriggersIdWorkordertemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchMetertriggersIdWorkordertemplatesResponse, error)

	// DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameWithResponse request
	DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse, error)

	// PutMetertriggersIdWorkordertemplatesAttachmentsFilenameWithBodyWithResponse request with any body
	PutMetertriggersIdWorkordertemplatesAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutMetertriggersIdWorkordertemplatesAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse, error)

	// GetOrganizationsWithResponse request
	GetOrganizationsWithResponse(ctx context.Context, params *GetOrganizationsParams, reqEditors ...RequestEditorFn) (*GetOrganizationsResponse, error)

	// GetPartsWithResponse request
	GetPartsWithResponse(ctx context.Context, params *GetPartsParams, reqEditors ...RequestEditorFn) (*GetPartsResponse, error)

	// PostPartsWithBodyWithResponse request with any body
	PostPartsWithBodyWithResponse(ctx context.Context, params *PostPartsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPartsResponse, error)

	PostPartsWithResponse(ctx context.Context, params *PostPartsParams, body PostPartsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPartsResponse, error)

	// DeletePartsIdWithResponse request
	DeletePartsIdWithResponse(ctx context.Context, id int, params *DeletePartsIdParams, reqEditors ...RequestEditorFn) (*DeletePartsIdResponse, error)

	// GetPartsIdWithResponse request
	GetPartsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPartsIdResponse, error)

	// PatchPartsIdWithBodyWithResponse request with any body
	PatchPartsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchPartsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPartsIdResponse, error)

	PatchPartsIdWithResponse(ctx context.Context, id int, params *PatchPartsIdParams, body PatchPartsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPartsIdResponse, error)

	// DeletePartsIdAttachmentsFilenameWithResponse request
	DeletePartsIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeletePartsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeletePartsIdAttachmentsFilenameResponse, error)

	// PutPartsIdAttachmentsFilenameWithBodyWithResponse request with any body
	PutPartsIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutPartsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPartsIdAttachmentsFilenameResponse, error)

	// PutPartsIdThumbnailFilenameWithBodyWithResponse request with any body
	PutPartsIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutPartsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPartsIdThumbnailFilenameResponse, error)

	// GetParttransferrequestsWithResponse request
	GetParttransferrequestsWithResponse(ctx context.Context, params *GetParttransferrequestsParams, reqEditors ...RequestEditorFn) (*GetParttransferrequestsResponse, error)

	// PostParttransferrequestsWithBodyWithResponse request with any body
	PostParttransferrequestsWithBodyWithResponse(ctx context.Context, params *PostParttransferrequestsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostParttransferrequestsResponse, error)

	PostParttransferrequestsWithResponse(ctx context.Context, params *PostParttransferrequestsParams, body PostParttransferrequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostParttransferrequestsResponse, error)

	// GetParttransferrequestsIdWithResponse request
	GetParttransferrequestsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetParttransferrequestsIdResponse, error)

	// PatchParttransferrequestsIdWithBodyWithResponse request with any body
	PatchParttransferrequestsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchParttransferrequestsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchParttransferrequestsIdResponse, error)

	PatchParttransferrequestsIdWithResponse(ctx context.Context, id int, params *PatchParttransferrequestsIdParams, body PatchParttransferrequestsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchParttransferrequestsIdResponse, error)

	// DeleteProceduretemplaterowsIdWithResponse request
	DeleteProceduretemplaterowsIdWithResponse(ctx context.Context, id int, params *DeleteProceduretemplaterowsIdParams, reqEditors ...RequestEditorFn) (*DeleteProceduretemplaterowsIdResponse, error)

	// PatchProceduretemplaterowsIdWithBodyWithResponse request with any body
	PatchProceduretemplaterowsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchProceduretemplaterowsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchProceduretemplaterowsIdResponse, error)

	PatchProceduretemplaterowsIdWithResponse(ctx context.Context, id int, params *PatchProceduretemplaterowsIdParams, body PatchProceduretemplaterowsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchProceduretemplaterowsIdResponse, error)

	// DeleteProceduretemplaterowsIdAttachmentsWithResponse request
	DeleteProceduretemplaterowsIdAttachmentsWithResponse(ctx context.Context, id int, params *DeleteProceduretemplaterowsIdAttachmentsParams, reqEditors ...RequestEditorFn) (*DeleteProceduretemplaterowsIdAttachmentsResponse, error)

	// PutProceduretemplaterowsIdAttachmentsFilenameWithBodyWithResponse request with any body
	PutProceduretemplaterowsIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutProceduretemplaterowsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutProceduretemplaterowsIdAttachmentsFilenameResponse, error)

	// GetProceduretemplatesWithResponse request
	GetProceduretemplatesWithResponse(ctx context.Context, params *GetProceduretemplatesParams, reqEditors ...RequestEditorFn) (*GetProceduretemplatesResponse, error)

	// PostProceduretemplatesWithBodyWithResponse request with any body
	PostProceduretemplatesWithBodyWithResponse(ctx context.Context, params *PostProceduretemplatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProceduretemplatesResponse, error)

	PostProceduretemplatesWithResponse(ctx context.Context, params *PostProceduretemplatesParams, body PostProceduretemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProceduretemplatesResponse, error)

	// DeleteProceduretemplatesIdWithResponse request
	DeleteProceduretemplatesIdWithResponse(ctx context.Context, id int, params *DeleteProceduretemplatesIdParams, reqEditors ...RequestEditorFn) (*DeleteProceduretemplatesIdResponse, error)

	// GetProceduretemplatesIdWithResponse request
	GetProceduretemplatesIdWithResponse(ctx context.Context, id int, params *GetProceduretemplatesIdParams, reqEditors ...RequestEditorFn) (*GetProceduretemplatesIdResponse, error)

	// PatchProceduretemplatesIdWithBodyWithResponse request with any body
	PatchProceduretemplatesIdWithBodyWithResponse(ctx context.Context, id int, params *PatchProceduretemplatesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchProceduretemplatesIdResponse, error)

	PatchProceduretemplatesIdWithResponse(ctx context.Context, id int, params *PatchProceduretemplatesIdParams, body PatchProceduretemplatesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchProceduretemplatesIdResponse, error)

	// GetPurchaseordersWithResponse request
	GetPurchaseordersWithResponse(ctx context.Context, params *GetPurchaseordersParams, reqEditors ...RequestEditorFn) (*GetPurchaseordersResponse, error)

	// PostPurchaseordersWithBodyWithResponse request with any body
	PostPurchaseordersWithBodyWithResponse(ctx context.Context, params *PostPurchaseordersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPurchaseordersResponse, error)

	PostPurchaseordersWithResponse(ctx context.Context, params *PostPurchaseordersParams, body PostPurchaseordersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPurchaseordersResponse, error)

	// DeletePurchaseordersIdWithResponse request
	DeletePurchaseordersIdWithResponse(ctx context.Context, id int, params *DeletePurchaseordersIdParams, reqEditors ...RequestEditorFn) (*DeletePurchaseordersIdResponse, error)

	// GetPurchaseordersIdWithResponse request
	GetPurchaseordersIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPurchaseordersIdResponse, error)

	// PatchPurchaseordersIdWithBodyWithResponse request with any body
	PatchPurchaseordersIdWithBodyWithResponse(ctx context.Context, id float32, params *PatchPurchaseordersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPurchaseordersIdResponse, error)

	PatchPurchaseordersIdWithResponse(ctx context.Context, id float32, params *PatchPurchaseordersIdParams, body PatchPurchaseordersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPurchaseordersIdResponse, error)

	// DeletePurchaseordersIdAttachmentsFilenameWithResponse request
	DeletePurchaseordersIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeletePurchaseordersIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeletePurchaseordersIdAttachmentsFilenameResponse, error)

	// PutPurchaseordersIdAttachmentsFilenameWithBodyWithResponse request with any body
	PutPurchaseordersIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutPurchaseordersIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPurchaseordersIdAttachmentsFilenameResponse, error)

	// PostPurchaseordersIdCommentsWithBodyWithResponse request with any body
	PostPurchaseordersIdCommentsWithBodyWithResponse(ctx context.Context, id int, params *PostPurchaseordersIdCommentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPurchaseordersIdCommentsResponse, error)

	PostPurchaseordersIdCommentsWithResponse(ctx context.Context, id int, params *PostPurchaseordersIdCommentsParams, body PostPurchaseordersIdCommentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPurchaseordersIdCommentsResponse, error)

	// PostPurchaseordersIdEmailsWithBodyWithResponse request with any body
	PostPurchaseordersIdEmailsWithBodyWithResponse(ctx context.Context, id int, params *PostPurchaseordersIdEmailsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPurchaseordersIdEmailsResponse, error)

	PostPurchaseordersIdEmailsWithResponse(ctx context.Context, id int, params *PostPurchaseordersIdEmailsParams, body PostPurchaseordersIdEmailsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPurchaseordersIdEmailsResponse, error)

	// PatchPurchaseordersIdFulfillmentWithBodyWithResponse request with any body
	PatchPurchaseordersIdFulfillmentWithBodyWithResponse(ctx context.Context, id float32, params *PatchPurchaseordersIdFulfillmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPurchaseordersIdFulfillmentResponse, error)

	PatchPurchaseordersIdFulfillmentWithResponse(ctx context.Context, id float32, params *PatchPurchaseordersIdFulfillmentParams, body PatchPurchaseordersIdFulfillmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPurchaseordersIdFulfillmentResponse, error)

	// PatchPurchaseordersIdStatusWithBodyWithResponse request with any body
	PatchPurchaseordersIdStatusWithBodyWithResponse(ctx context.Context, id float32, params *PatchPurchaseordersIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPurchaseordersIdStatusResponse, error)

	PatchPurchaseordersIdStatusWithResponse(ctx context.Context, id float32, params *PatchPurchaseordersIdStatusParams, body PatchPurchaseordersIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPurchaseordersIdStatusResponse, error)

	// PutPurchaseordersIdThumbnailFilenameWithBodyWithResponse request with any body
	PutPurchaseordersIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutPurchaseordersIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPurchaseordersIdThumbnailFilenameResponse, error)

	// PostSubscriptionsWithBodyWithResponse request with any body
	PostSubscriptionsWithBodyWithResponse(ctx context.Context, params *PostSubscriptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSubscriptionsResponse, error)

	PostSubscriptionsWithResponse(ctx context.Context, params *PostSubscriptionsParams, body PostSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSubscriptionsResponse, error)

	// DeleteSubscriptionsIdWithResponse request
	DeleteSubscriptionsIdWithResponse(ctx context.Context, id int, params *DeleteSubscriptionsIdParams, reqEditors ...RequestEditorFn) (*DeleteSubscriptionsIdResponse, error)

	// GetSubscriptionsIdWithResponse request
	GetSubscriptionsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetSubscriptionsIdResponse, error)

	// PatchSubscriptionsIdWithBodyWithResponse request with any body
	PatchSubscriptionsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchSubscriptionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSubscriptionsIdResponse, error)

	PatchSubscriptionsIdWithResponse(ctx context.Context, id int, params *PatchSubscriptionsIdParams, body PatchSubscriptionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSubscriptionsIdResponse, error)

	// GetSubscriptionsIdSecretWithResponse request
	GetSubscriptionsIdSecretWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetSubscriptionsIdSecretResponse, error)

	// GetTeamsWithResponse request
	GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error)

	// PostTeamsWithBodyWithResponse request with any body
	PostTeamsWithBodyWithResponse(ctx context.Context, params *PostTeamsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTeamsResponse, error)

	PostTeamsWithResponse(ctx context.Context, params *PostTeamsParams, body PostTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTeamsResponse, error)

	// DeleteTeamsIdWithResponse request
	DeleteTeamsIdWithResponse(ctx context.Context, id int, params *DeleteTeamsIdParams, reqEditors ...RequestEditorFn) (*DeleteTeamsIdResponse, error)

	// GetTeamsIdWithResponse request
	GetTeamsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTeamsIdResponse, error)

	// PatchTeamsIdWithBodyWithResponse request with any body
	PatchTeamsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchTeamsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTeamsIdResponse, error)

	PatchTeamsIdWithResponse(ctx context.Context, id int, params *PatchTeamsIdParams, body PatchTeamsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTeamsIdResponse, error)

	// GetTeamsIdMembersWithResponse request
	GetTeamsIdMembersWithResponse(ctx context.Context, id int, params *GetTeamsIdMembersParams, reqEditors ...RequestEditorFn) (*GetTeamsIdMembersResponse, error)

	// PostTeamsIdMembersWithBodyWithResponse request with any body
	PostTeamsIdMembersWithBodyWithResponse(ctx context.Context, id int, params *PostTeamsIdMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTeamsIdMembersResponse, error)

	PostTeamsIdMembersWithResponse(ctx context.Context, id int, params *PostTeamsIdMembersParams, body PostTeamsIdMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTeamsIdMembersResponse, error)

	// DeleteTeamsTeamIdMembersUserIdWithResponse request
	DeleteTeamsTeamIdMembersUserIdWithResponse(ctx context.Context, teamId int, userId int, params *DeleteTeamsTeamIdMembersUserIdParams, reqEditors ...RequestEditorFn) (*DeleteTeamsTeamIdMembersUserIdResponse, error)

	// PatchTeamsTeamIdMembersUserIdWithBodyWithResponse request with any body
	PatchTeamsTeamIdMembersUserIdWithBodyWithResponse(ctx context.Context, teamId int, userId int, params *PatchTeamsTeamIdMembersUserIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTeamsTeamIdMembersUserIdResponse, error)

	PatchTeamsTeamIdMembersUserIdWithResponse(ctx context.Context, teamId int, userId int, params *PatchTeamsTeamIdMembersUserIdParams, body PatchTeamsTeamIdMembersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTeamsTeamIdMembersUserIdResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// PostUsersWithBodyWithResponse request with any body
	PostUsersWithBodyWithResponse(ctx context.Context, params *PostUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersResponse, error)

	PostUsersWithResponse(ctx context.Context, params *PostUsersParams, body PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersResponse, error)

	// DeleteUsersIdWithResponse request
	DeleteUsersIdWithResponse(ctx context.Context, id int, params *DeleteUsersIdParams, reqEditors ...RequestEditorFn) (*DeleteUsersIdResponse, error)

	// GetUsersIdWithResponse request
	GetUsersIdWithResponse(ctx context.Context, id int, params *GetUsersIdParams, reqEditors ...RequestEditorFn) (*GetUsersIdResponse, error)

	// PatchUsersIdWithBodyWithResponse request with any body
	PatchUsersIdWithBodyWithResponse(ctx context.Context, id int, params *PatchUsersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUsersIdResponse, error)

	PatchUsersIdWithResponse(ctx context.Context, id int, params *PatchUsersIdParams, body PatchUsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUsersIdResponse, error)

	// PostUsersIdMessagesWithBodyWithResponse request with any body
	PostUsersIdMessagesWithBodyWithResponse(ctx context.Context, id int, params *PostUsersIdMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersIdMessagesResponse, error)

	PostUsersIdMessagesWithResponse(ctx context.Context, id int, params *PostUsersIdMessagesParams, body PostUsersIdMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersIdMessagesResponse, error)

	// GetVendorsWithResponse request
	GetVendorsWithResponse(ctx context.Context, params *GetVendorsParams, reqEditors ...RequestEditorFn) (*GetVendorsResponse, error)

	// PostVendorsWithBodyWithResponse request with any body
	PostVendorsWithBodyWithResponse(ctx context.Context, params *PostVendorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVendorsResponse, error)

	PostVendorsWithResponse(ctx context.Context, params *PostVendorsParams, body PostVendorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVendorsResponse, error)

	// DeleteVendorsIdWithResponse request
	DeleteVendorsIdWithResponse(ctx context.Context, id int, params *DeleteVendorsIdParams, reqEditors ...RequestEditorFn) (*DeleteVendorsIdResponse, error)

	// GetVendorsIdWithResponse request
	GetVendorsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetVendorsIdResponse, error)

	// PatchVendorsIdWithBodyWithResponse request with any body
	PatchVendorsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchVendorsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchVendorsIdResponse, error)

	PatchVendorsIdWithResponse(ctx context.Context, id int, params *PatchVendorsIdParams, body PatchVendorsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchVendorsIdResponse, error)

	// DeleteVendorsIdAttachmentsFilenameWithResponse request
	DeleteVendorsIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeleteVendorsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeleteVendorsIdAttachmentsFilenameResponse, error)

	// PutVendorsIdAttachmentsFilenameWithBodyWithResponse request with any body
	PutVendorsIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutVendorsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutVendorsIdAttachmentsFilenameResponse, error)

	// GetVendorsIdContactsWithResponse request
	GetVendorsIdContactsWithResponse(ctx context.Context, id int, params *GetVendorsIdContactsParams, reqEditors ...RequestEditorFn) (*GetVendorsIdContactsResponse, error)

	// PostVendorsIdContactsWithBodyWithResponse request with any body
	PostVendorsIdContactsWithBodyWithResponse(ctx context.Context, id int, params *PostVendorsIdContactsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVendorsIdContactsResponse, error)

	PostVendorsIdContactsWithResponse(ctx context.Context, id int, params *PostVendorsIdContactsParams, body PostVendorsIdContactsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVendorsIdContactsResponse, error)

	// DeleteVendorsIdContactsContactIdWithResponse request
	DeleteVendorsIdContactsContactIdWithResponse(ctx context.Context, id int, contactId int, params *DeleteVendorsIdContactsContactIdParams, reqEditors ...RequestEditorFn) (*DeleteVendorsIdContactsContactIdResponse, error)

	// GetVendorsIdContactsContactIdWithResponse request
	GetVendorsIdContactsContactIdWithResponse(ctx context.Context, id int, contactId int, reqEditors ...RequestEditorFn) (*GetVendorsIdContactsContactIdResponse, error)

	// PatchVendorsIdContactsContactIdWithBodyWithResponse request with any body
	PatchVendorsIdContactsContactIdWithBodyWithResponse(ctx context.Context, id int, contactId int, params *PatchVendorsIdContactsContactIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchVendorsIdContactsContactIdResponse, error)

	PatchVendorsIdContactsContactIdWithResponse(ctx context.Context, id int, contactId int, params *PatchVendorsIdContactsContactIdParams, body PatchVendorsIdContactsContactIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchVendorsIdContactsContactIdResponse, error)

	// PutVendorsIdThumbnailFilenameWithBodyWithResponse request with any body
	PutVendorsIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutVendorsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutVendorsIdThumbnailFilenameResponse, error)

	// GetVersionsWithResponse request
	GetVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionsResponse, error)

	// PostWorkPermitsIdSignWithBodyWithResponse request with any body
	PostWorkPermitsIdSignWithBodyWithResponse(ctx context.Context, id int, params *PostWorkPermitsIdSignParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkPermitsIdSignResponse, error)

	PostWorkPermitsIdSignWithResponse(ctx context.Context, id int, params *PostWorkPermitsIdSignParams, body PostWorkPermitsIdSignJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkPermitsIdSignResponse, error)

	// GetWorkordersWithResponse request
	GetWorkordersWithResponse(ctx context.Context, params *GetWorkordersParams, reqEditors ...RequestEditorFn) (*GetWorkordersResponse, error)

	// PostWorkordersWithBodyWithResponse request with any body
	PostWorkordersWithBodyWithResponse(ctx context.Context, params *PostWorkordersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkordersResponse, error)

	PostWorkordersWithResponse(ctx context.Context, params *PostWorkordersParams, body PostWorkordersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkordersResponse, error)

	// DeleteWorkordersIdWithResponse request
	DeleteWorkordersIdWithResponse(ctx context.Context, id int, params *DeleteWorkordersIdParams, reqEditors ...RequestEditorFn) (*DeleteWorkordersIdResponse, error)

	// GetWorkordersIdWithResponse request
	GetWorkordersIdWithResponse(ctx context.Context, id int, params *GetWorkordersIdParams, reqEditors ...RequestEditorFn) (*GetWorkordersIdResponse, error)

	// PatchWorkordersIdWithBodyWithResponse request with any body
	PatchWorkordersIdWithBodyWithResponse(ctx context.Context, id int, params *PatchWorkordersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchWorkordersIdResponse, error)

	PatchWorkordersIdWithResponse(ctx context.Context, id int, params *PatchWorkordersIdParams, body PatchWorkordersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchWorkordersIdResponse, error)

	// DeleteWorkordersIdAttachmentsFilenameWithResponse request
	DeleteWorkordersIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeleteWorkordersIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeleteWorkordersIdAttachmentsFilenameResponse, error)

	// PutWorkordersIdAttachmentsFilenameWithBodyWithResponse request with any body
	PutWorkordersIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutWorkordersIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWorkordersIdAttachmentsFilenameResponse, error)

	// GetWorkordersIdCommentsWithResponse request
	GetWorkordersIdCommentsWithResponse(ctx context.Context, id int, params *GetWorkordersIdCommentsParams, reqEditors ...RequestEditorFn) (*GetWorkordersIdCommentsResponse, error)

	// PostWorkordersIdCommentsWithBodyWithResponse request with any body
	PostWorkordersIdCommentsWithBodyWithResponse(ctx context.Context, id int, params *PostWorkordersIdCommentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkordersIdCommentsResponse, error)

	PostWorkordersIdCommentsWithResponse(ctx context.Context, id int, params *PostWorkordersIdCommentsParams, body PostWorkordersIdCommentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkordersIdCommentsResponse, error)

	// GetWorkordersIdCostsWithResponse request
	GetWorkordersIdCostsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetWorkordersIdCostsResponse, error)

	// PostWorkordersIdCostsWithBodyWithResponse request with any body
	PostWorkordersIdCostsWithBodyWithResponse(ctx context.Context, id int, params *PostWorkordersIdCostsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkordersIdCostsResponse, error)

	PostWorkordersIdCostsWithResponse(ctx context.Context, id int, params *PostWorkordersIdCostsParams, body PostWorkordersIdCostsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkordersIdCostsResponse, error)

	// PostWorkordersIdEmailsWithBodyWithResponse request with any body
	PostWorkordersIdEmailsWithBodyWithResponse(ctx context.Context, id int, params *PostWorkordersIdEmailsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkordersIdEmailsResponse, error)

	PostWorkordersIdEmailsWithResponse(ctx context.Context, id int, params *PostWorkordersIdEmailsParams, body PostWorkordersIdEmailsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkordersIdEmailsResponse, error)

	// DeleteWorkordersIdProcedureWithResponse request
	DeleteWorkordersIdProcedureWithResponse(ctx context.Context, id int, params *DeleteWorkordersIdProcedureParams, reqEditors ...RequestEditorFn) (*DeleteWorkordersIdProcedureResponse, error)

	// DeleteWorkordersIdProcedureFieldsIndexAttachmentWithResponse request
	DeleteWorkordersIdProcedureFieldsIndexAttachmentWithResponse(ctx context.Context, id int, index int, params *DeleteWorkordersIdProcedureFieldsIndexAttachmentParams, reqEditors ...RequestEditorFn) (*DeleteWorkordersIdProcedureFieldsIndexAttachmentResponse, error)

	// PutWorkordersIdProcedureFieldsIndexAttachmentFilenameWithBodyWithResponse request with any body
	PutWorkordersIdProcedureFieldsIndexAttachmentFilenameWithBodyWithResponse(ctx context.Context, id int, index int, filename string, params *PutWorkordersIdProcedureFieldsIndexAttachmentFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWorkordersIdProcedureFieldsIndexAttachmentFilenameResponse, error)

	// PatchWorkordersIdStatusWithBodyWithResponse request with any body
	PatchWorkordersIdStatusWithBodyWithResponse(ctx context.Context, id int, params *PatchWorkordersIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchWorkordersIdStatusResponse, error)

	PatchWorkordersIdStatusWithResponse(ctx context.Context, id int, params *PatchWorkordersIdStatusParams, body PatchWorkordersIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchWorkordersIdStatusResponse, error)

	// GetWorkordersIdSubworkordersWithResponse request
	GetWorkordersIdSubworkordersWithResponse(ctx context.Context, id int, params *GetWorkordersIdSubworkordersParams, reqEditors ...RequestEditorFn) (*GetWorkordersIdSubworkordersResponse, error)

	// PutWorkordersIdThumbnailFilenameWithBodyWithResponse request with any body
	PutWorkordersIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutWorkordersIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWorkordersIdThumbnailFilenameResponse, error)

	// GetWorkrequestportalsWithResponse request
	GetWorkrequestportalsWithResponse(ctx context.Context, params *GetWorkrequestportalsParams, reqEditors ...RequestEditorFn) (*GetWorkrequestportalsResponse, error)

	// PostWorkrequestportalsWithBodyWithResponse request with any body
	PostWorkrequestportalsWithBodyWithResponse(ctx context.Context, params *PostWorkrequestportalsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkrequestportalsResponse, error)

	PostWorkrequestportalsWithResponse(ctx context.Context, params *PostWorkrequestportalsParams, body PostWorkrequestportalsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkrequestportalsResponse, error)

	// DeleteWorkrequestportalsIdWithResponse request
	DeleteWorkrequestportalsIdWithResponse(ctx context.Context, id int, params *DeleteWorkrequestportalsIdParams, reqEditors ...RequestEditorFn) (*DeleteWorkrequestportalsIdResponse, error)

	// GetWorkrequestportalsIdWithResponse request
	GetWorkrequestportalsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetWorkrequestportalsIdResponse, error)

	// PatchWorkrequestportalsIdWithBodyWithResponse request with any body
	PatchWorkrequestportalsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchWorkrequestportalsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchWorkrequestportalsIdResponse, error)

	PatchWorkrequestportalsIdWithResponse(ctx context.Context, id int, params *PatchWorkrequestportalsIdParams, body PatchWorkrequestportalsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchWorkrequestportalsIdResponse, error)

	// GetWorkrequestsWithResponse request
	GetWorkrequestsWithResponse(ctx context.Context, params *GetWorkrequestsParams, reqEditors ...RequestEditorFn) (*GetWorkrequestsResponse, error)

	// PostWorkrequestsWithBodyWithResponse request with any body
	PostWorkrequestsWithBodyWithResponse(ctx context.Context, params *PostWorkrequestsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkrequestsResponse, error)

	PostWorkrequestsWithResponse(ctx context.Context, params *PostWorkrequestsParams, body PostWorkrequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkrequestsResponse, error)

	// DeleteWorkrequestsIdWithResponse request
	DeleteWorkrequestsIdWithResponse(ctx context.Context, id int, params *DeleteWorkrequestsIdParams, reqEditors ...RequestEditorFn) (*DeleteWorkrequestsIdResponse, error)

	// GetWorkrequestsIdWithResponse request
	GetWorkrequestsIdWithResponse(ctx context.Context, id int, params *GetWorkrequestsIdParams, reqEditors ...RequestEditorFn) (*GetWorkrequestsIdResponse, error)

	// PatchWorkrequestsIdWithBodyWithResponse request with any body
	PatchWorkrequestsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchWorkrequestsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchWorkrequestsIdResponse, error)

	PatchWorkrequestsIdWithResponse(ctx context.Context, id int, params *PatchWorkrequestsIdParams, body PatchWorkrequestsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchWorkrequestsIdResponse, error)

	// DeleteWorkrequestsIdAttachmentsFilenameWithResponse request
	DeleteWorkrequestsIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeleteWorkrequestsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeleteWorkrequestsIdAttachmentsFilenameResponse, error)

	// PutWorkrequestsIdAttachmentsFilenameWithBodyWithResponse request with any body
	PutWorkrequestsIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutWorkrequestsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWorkrequestsIdAttachmentsFilenameResponse, error)

	// PutWorkrequestsIdThumbnailFilenameWithBodyWithResponse request with any body
	PutWorkrequestsIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutWorkrequestsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWorkrequestsIdThumbnailFilenameResponse, error)
}

type GetAssetcriticalitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AssetCriticalities []struct {
			// Id Global ID of the criticality. <a href='https://help.getmaintainx.com/about-assets#criticality' target='_blank'>Learn more</a>
			Id int `json:"id"`

			// Label The label of the criticality. <a href='https://help.getmaintainx.com/about-assets#criticality' target='_blank'>Learn more</a>
			Label string `json:"label"`

			// Level The level of the criticality. <a href='https://help.getmaintainx.com/about-assets#criticality' target='_blank'>Learn more</a>
			Level int `json:"level"`
		} `json:"assetCriticalities"`

		// NextCursor The cursor to retrieve the next page of Asset Criticalities.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Asset Criticalities.
		NextPageUrl *string `json:"nextPageUrl"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAssetcriticalitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetcriticalitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetcriticalitiesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AssetCriticality struct {
			// Id Global ID of the criticality. <a href='https://help.getmaintainx.com/about-assets#criticality' target='_blank'>Learn more</a>
			Id int `json:"id"`

			// Label The label of the criticality. <a href='https://help.getmaintainx.com/about-assets#criticality' target='_blank'>Learn more</a>
			Label string `json:"label"`

			// Level The level of the criticality. <a href='https://help.getmaintainx.com/about-assets#criticality' target='_blank'>Learn more</a>
			Level int `json:"level"`
		} `json:"assetCriticality"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAssetcriticalitiesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetcriticalitiesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetcustomstatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AssetCustomStatuses []struct {
			BaseAssetStatus GetAssetcustomstatuses200AssetCustomStatusesBaseAssetStatus `json:"baseAssetStatus"`

			// CreatedAt Date & time at which the asset custom status was created.
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// DowntimeType Downtime type on asset custom statuses will always return null. Use downtime type on asset status instead.
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			DowntimeType *GetAssetcustomstatuses200AssetCustomStatusesDowntimeType `json:"downtimeType"`
			Id           float32                                                   `json:"id"`
			Label        string                                                    `json:"label"`

			// UpdatedAt Date & time at which the asset custom status was last updated.
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`
		} `json:"assetCustomStatuses"`

		// NextCursor The cursor to retrieve the next page of Asset Custom Statuses.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Asset Custom Statuses.
		NextPageUrl *string `json:"nextPageUrl"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}
type GetAssetcustomstatuses200AssetCustomStatusesBaseAssetStatus string
type GetAssetcustomstatuses200AssetCustomStatusesDowntimeType string

// Status returns HTTPResponse.Status
func (r GetAssetcustomstatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetcustomstatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAssetcustomstatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Id float32 `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                         `json:"error"`
			FieldPath  *string                                        `json:"fieldPath"`
			FieldValue *PostAssetcustomstatuses_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostAssetcustomstatuses400ErrorsFieldValue0 = string
type PostAssetcustomstatuses400ErrorsFieldValue1 = float32
type PostAssetcustomstatuses400ErrorsFieldValue2 = bool
type PostAssetcustomstatuses_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostAssetcustomstatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAssetcustomstatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAssetcustomstatusesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                             `json:"error"`
			FieldPath  *string                                            `json:"fieldPath"`
			FieldValue *DeleteAssetcustomstatusesId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteAssetcustomstatusesId400ErrorsFieldValue0 = string
type DeleteAssetcustomstatusesId400ErrorsFieldValue1 = float32
type DeleteAssetcustomstatusesId400ErrorsFieldValue2 = bool
type DeleteAssetcustomstatusesId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteAssetcustomstatusesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAssetcustomstatusesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetcustomstatusesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AssetCustomStatus struct {
			BaseAssetStatus GetAssetcustomstatusesId200AssetCustomStatusBaseAssetStatus `json:"baseAssetStatus"`

			// CreatedAt Date & time at which the asset custom status was created.
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// DeletedAt Date at which the asset custom status was deleted.
			DeletedAt *time.Time `json:"deletedAt"`

			// DowntimeType Downtime type on asset custom statuses will always return null. Use downtime type on asset status instead.
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			DowntimeType *GetAssetcustomstatusesId200AssetCustomStatusDowntimeType `json:"downtimeType"`
			Id           *float32                                                  `json:"id,omitempty"`
			Label        string                                                    `json:"label"`

			// UpdatedAt Date & time at which the asset custom status was last updated.
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`
		} `json:"assetCustomStatus"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetAssetcustomstatusesId200AssetCustomStatusBaseAssetStatus string
type GetAssetcustomstatusesId200AssetCustomStatusDowntimeType string

// Status returns HTTPResponse.Status
func (r GetAssetcustomstatusesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetcustomstatusesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAssetcustomstatusesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Assetcustomstatus *struct {
			BaseAssetStatus *PatchAssetcustomstatusesId200AssetcustomstatusBaseAssetStatus `json:"baseAssetStatus,omitempty"`

			// CreatedAt Date & time at which the asset custom status was created.
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// DeletedAt Date at which the asset custom status was deleted.
			DeletedAt *time.Time `json:"deletedAt"`
			Id        float32    `json:"id"`
			Label     *string    `json:"label,omitempty"`

			// UpdatedAt Date & time at which the asset custom status was last updated.
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`
		} `json:"assetcustomstatus,omitempty"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchAssetcustomstatusesId200AssetcustomstatusBaseAssetStatus string

// Status returns HTTPResponse.Status
func (r PatchAssetcustomstatusesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAssetcustomstatusesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Assets []struct {
			// AssetTypes List of asset types (expand with query parameter)
			AssetTypes *[]string `json:"assetTypes,omitempty"`

			// Barcode String encoded barcode (expand with query parameter)
			Barcode *string `json:"barcode,omitempty"`

			// CreatedAt Date & time at which the asset was created
			CreatedAt time.Time `json:"createdAt"`

			// CreatorId ID of the asset creator
			CreatorId *int `json:"creatorId"`

			// CriticalityId ID of the criticality of the asset
			CriticalityId *int `json:"criticalityId"`

			// Depreciation Depreciation information of the asset (expand with query parameter)
			Depreciation *struct {
				// AccumulatedDepreciation Accumulated depreciation of the asset.
				AccumulatedDepreciation *float64 `json:"accumulatedDepreciation"`

				// AnnualDepreciation Annual depreciation of the asset.
				AnnualDepreciation *float64 `json:"annualDepreciation"`

				// ArchivedAt Date & time at which the asset depreciation was archived.
				ArchivedAt *time.Time `json:"archivedAt"`

				// CreatedAt Date & time at which the asset depreciation was created.
				CreatedAt *time.Time `json:"createdAt"`

				// CurrentBookValue Current book value of the asset.
				CurrentBookValue *float64 `json:"currentBookValue"`

				// DepreciationStartDate Date at which the asset depreciation started.
				DepreciationStartDate *time.Time `json:"depreciationStartDate"`

				// Id Global ID of the asset depreciation.
				Id *float32 `json:"id,omitempty"`

				// PurchaseDate Date & time at which the asset was purchased.
				PurchaseDate *time.Time `json:"purchaseDate"`

				// PurchasePrice Purchase price of the asset.
				PurchasePrice *float64 `json:"purchasePrice"`

				// SalvageValue Salvage value of the asset.
				SalvageValue *float64 `json:"salvageValue"`

				// UsefulLifeYears Useful life of the asset in years.
				UsefulLifeYears *float64 `json:"usefulLifeYears"`

				// YearsDepreciated Years depreciated of the asset.
				YearsDepreciated *float64 `json:"yearsDepreciated"`
			} `json:"depreciation,omitempty"`
			Description *string `json:"description"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "My Custom Field") (expand with query parameter)
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the asset
			Id int `json:"id"`

			// LocationId ID of the location where the asset is located
			LocationId *int `json:"locationId"`

			// Manufacturer Name of the manufacturer of the asset (expand with query parameter)
			Manufacturer *string `json:"manufacturer,omitempty"`

			// Model Name of the model of the asset (expand with query parameter)
			Model *string `json:"model,omitempty"`
			Name  string  `json:"name"`

			// ParentId ID of the parent asset
			ParentId *int `json:"parentId"`

			// SerialNumber Serial number of the asset
			SerialNumber *string `json:"serialNumber"`

			// Status Status information of the asset (expand with query parameter)
			Status *struct {
				// CreatedAt Date & time at which the asset status was created.
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// CustomStatus Custom status assigned to asset.
				CustomStatus *struct {
					// CreatedAt Date & time at which the asset custom status was created.
					CreatedAt *time.Time `json:"createdAt,omitempty"`

					// DeletedAt Date at which the asset custom status was deleted.
					DeletedAt *time.Time `json:"deletedAt"`
					Id        *float32   `json:"id,omitempty"`
					Label     string     `json:"label"`

					// UpdatedAt Date & time at which the asset custom status was last updated.
					UpdatedAt *time.Time `json:"updatedAt,omitempty"`
				} `json:"customStatus"`

				// DeletedAt Date & time at which the asset status was deleted.
				DeletedAt    *time.Time                            `json:"deletedAt"`
				Description  *string                               `json:"description"`
				DowntimeType *GetAssets200AssetsStatusDowntimeType `json:"downtimeType"`

				// EndedAt Asset status effective end date.
				EndedAt *time.Time `json:"endedAt"`

				// Id Global ID of the asset status.
				Id *float32 `json:"id,omitempty"`

				// StartedAt Asset status effective start date.
				StartedAt *time.Time `json:"startedAt,omitempty"`

				// Status Asset status value.
				Status *GetAssets200AssetsStatusStatus `json:"status,omitempty"`

				// UpdatedAt Date & time at which the asset status was last updated.
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"status,omitempty"`

			// TeamIds List of teams responsible for the asset (expand with query parameter)
			TeamIds *[]int `json:"teamIds,omitempty"`

			// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
			UpdatedAt time.Time `json:"updatedAt"`

			// VendorIds Vendor IDs (expand with query parameter)
			VendorIds *[]float32 `json:"vendorIds,omitempty"`
		} `json:"assets"`

		// NextCursor The cursor to retrieve the next page of Assets.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Assets.
		NextPageUrl *string `json:"nextPageUrl"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}
type GetAssets200AssetsStatusDowntimeType string
type GetAssets200AssetsStatusStatus string

// Status returns HTTPResponse.Status
func (r GetAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the asset
		Id int `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                            `json:"error"`
			FieldPath  *string                           `json:"fieldPath"`
			FieldValue *PostAssets_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostAssets400ErrorsFieldValue0 = string
type PostAssets400ErrorsFieldValue1 = float32
type PostAssets400ErrorsFieldValue2 = bool
type PostAssets_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAssetsAssetIdStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		AssetStatus struct {
			// CustomStatusId Id of the custom status assigned to asset.
			CustomStatusId *float32                                           `json:"customStatusId"`
			DowntimeType   *PostAssetsAssetIdStatus201AssetStatusDowntimeType `json:"downtimeType"`

			// Id Global ID of the asset status.
			Id float32 `json:"id"`

			// StartedAt Asset status effective start date.
			StartedAt time.Time `json:"startedAt"`

			// Status Asset status value.
			Status PostAssetsAssetIdStatus201AssetStatusStatus `json:"status"`

			// UpdatedAt Date & time at which the asset status was last updated.
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`
		} `json:"assetStatus"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                         `json:"error"`
			FieldPath  *string                                        `json:"fieldPath"`
			FieldValue *PostAssetsAssetIdStatus_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PostAssetsAssetIdStatus201AssetStatusDowntimeType string
type PostAssetsAssetIdStatus201AssetStatusStatus string
type PostAssetsAssetIdStatus400ErrorsFieldValue0 = string
type PostAssetsAssetIdStatus400ErrorsFieldValue1 = float32
type PostAssetsAssetIdStatus400ErrorsFieldValue2 = bool
type PostAssetsAssetIdStatus_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostAssetsAssetIdStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAssetsAssetIdStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAssetsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                `json:"error"`
			FieldPath  *string                               `json:"fieldPath"`
			FieldValue *DeleteAssetsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteAssetsId400ErrorsFieldValue0 = string
type DeleteAssetsId400ErrorsFieldValue1 = float32
type DeleteAssetsId400ErrorsFieldValue2 = bool
type DeleteAssetsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteAssetsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAssetsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Asset struct {
			// AssetTypes List of asset types
			AssetTypes *[]string `json:"assetTypes,omitempty"`

			// Attachments List of attachments linked to the asset
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// Barcode String encoded barcode
			Barcode *string `json:"barcode"`

			// ChildrenIds IDs of the asset's children
			ChildrenIds *[]float32 `json:"childrenIds"`

			// CreatedAt Date & time at which the asset was created
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// CreatorId ID of the asset creator
			CreatorId *int `json:"creatorId"`

			// CriticalityId ID of the criticality of the asset
			CriticalityId *int `json:"criticalityId"`

			// CurrentOwnerId Organization id that currently has the active version of this asset
			CurrentOwnerId *float32 `json:"currentOwnerId,omitempty"`

			// DeletedAt Date at which the asset was deleted
			DeletedAt *time.Time `json:"deletedAt"`

			// Depreciation Depreciation information of the asset
			Depreciation *struct {
				// AccumulatedDepreciation Accumulated depreciation of the asset.
				AccumulatedDepreciation *float64 `json:"accumulatedDepreciation"`

				// AnnualDepreciation Annual depreciation of the asset.
				AnnualDepreciation *float64 `json:"annualDepreciation"`

				// ArchivedAt Date & time at which the asset depreciation was archived.
				ArchivedAt *time.Time `json:"archivedAt"`

				// CreatedAt Date & time at which the asset depreciation was created.
				CreatedAt *time.Time `json:"createdAt"`

				// CurrentBookValue Current book value of the asset.
				CurrentBookValue *float64 `json:"currentBookValue"`

				// DepreciationStartDate Date at which the asset depreciation started.
				DepreciationStartDate *time.Time `json:"depreciationStartDate"`

				// Id Global ID of the asset depreciation.
				Id *float32 `json:"id,omitempty"`

				// PurchaseDate Date & time at which the asset was purchased.
				PurchaseDate *time.Time `json:"purchaseDate"`

				// PurchasePrice Purchase price of the asset.
				PurchasePrice *float64 `json:"purchasePrice"`

				// SalvageValue Salvage value of the asset.
				SalvageValue *float64 `json:"salvageValue"`

				// UsefulLifeYears Useful life of the asset in years.
				UsefulLifeYears *float64 `json:"usefulLifeYears"`

				// YearsDepreciated Years depreciated of the asset.
				YearsDepreciated *float64 `json:"yearsDepreciated"`
			} `json:"depreciation"`
			Description *string `json:"description"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "My Custom Field")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// GlobalUuid Global unique identifier of the asset used to identify assets as they are being transferred
			GlobalUuid *string `json:"globalUuid"`

			// Id Global ID of the asset
			Id int `json:"id"`

			// LocationId ID of the location where the asset is located
			LocationId *int `json:"locationId"`

			// Manufacturer Name of the manufacturer of the asset
			Manufacturer *string `json:"manufacturer"`

			// Model Name of the model of the asset
			Model *string `json:"model"`
			Name  string  `json:"name"`

			// ParentId ID of the parent asset
			ParentId *int `json:"parentId"`

			// SerialNumber Serial number of the asset
			SerialNumber *string `json:"serialNumber"`

			// Status Status information of the asset
			Status *struct {
				// CreatedAt Date & time at which the asset status was created.
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// CustomStatus Custom status assigned to asset.
				CustomStatus *struct {
					// CreatedAt Date & time at which the asset custom status was created.
					CreatedAt *time.Time `json:"createdAt,omitempty"`

					// DeletedAt Date at which the asset custom status was deleted.
					DeletedAt *time.Time `json:"deletedAt"`

					// DowntimeType Downtime type on asset custom statuses will always return null. Use downtime type on asset status instead.
					// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
					DowntimeType *GetAssetsId200AssetStatusCustomStatusDowntimeType `json:"downtimeType"`
					Id           *float32                                           `json:"id,omitempty"`
					Label        string                                             `json:"label"`

					// UpdatedAt Date & time at which the asset custom status was last updated.
					UpdatedAt *time.Time `json:"updatedAt,omitempty"`
				} `json:"customStatus"`

				// CustomStatusId Please use customStatus instead.
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				CustomStatusId *float32 `json:"customStatusId"`

				// DeletedAt Date & time at which the asset status was deleted.
				DeletedAt    *time.Time                             `json:"deletedAt"`
				Description  *string                                `json:"description"`
				DowntimeType *GetAssetsId200AssetStatusDowntimeType `json:"downtimeType"`

				// EndedAt Asset status effective end date.
				EndedAt *time.Time `json:"endedAt"`

				// Id Global ID of the asset status.
				Id *float32 `json:"id,omitempty"`

				// StartedAt Asset status effective start date.
				StartedAt *time.Time `json:"startedAt,omitempty"`

				// Status Asset status value.
				Status *GetAssetsId200AssetStatusStatus `json:"status,omitempty"`

				// UpdatedAt Date & time at which the asset status was last updated.
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"status"`

			// TeamIds List of teams responsible for the asset
			TeamIds   *[]int `json:"teamIds,omitempty"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`

			// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`

			// VendorIds Vendor IDs
			VendorIds *[]float32 `json:"vendorIds,omitempty"`
		} `json:"asset"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetAssetsId200AssetStatusCustomStatusDowntimeType string
type GetAssetsId200AssetStatusDowntimeType string
type GetAssetsId200AssetStatusStatus string

// Status returns HTTPResponse.Status
func (r GetAssetsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAssetsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Asset struct {
			// AssetTypes List of asset types
			AssetTypes *[]string `json:"assetTypes,omitempty"`

			// Attachments List of attachments linked to the asset
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// Barcode String encoded barcode
			Barcode *string `json:"barcode"`

			// ChildrenIds IDs of the asset's children
			ChildrenIds *[]float32 `json:"childrenIds"`

			// CreatedAt Date & time at which the asset was created
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// CreatorId ID of the asset creator
			CreatorId *int `json:"creatorId"`

			// CriticalityId ID of the criticality of the asset
			CriticalityId *int `json:"criticalityId"`

			// CurrentOwnerId Organization id that currently has the active version of this asset
			CurrentOwnerId *float32 `json:"currentOwnerId,omitempty"`

			// DeletedAt Date at which the asset was deleted
			DeletedAt *time.Time `json:"deletedAt"`

			// Depreciation Depreciation information of the asset
			Depreciation *struct {
				// AccumulatedDepreciation Accumulated depreciation of the asset.
				AccumulatedDepreciation *float64 `json:"accumulatedDepreciation"`

				// AnnualDepreciation Annual depreciation of the asset.
				AnnualDepreciation *float64 `json:"annualDepreciation"`

				// ArchivedAt Date & time at which the asset depreciation was archived.
				ArchivedAt *time.Time `json:"archivedAt"`

				// CreatedAt Date & time at which the asset depreciation was created.
				CreatedAt *time.Time `json:"createdAt"`

				// CurrentBookValue Current book value of the asset.
				CurrentBookValue *float64 `json:"currentBookValue"`

				// DepreciationStartDate Date at which the asset depreciation started.
				DepreciationStartDate *time.Time `json:"depreciationStartDate"`

				// Id Global ID of the asset depreciation.
				Id *float32 `json:"id,omitempty"`

				// PurchaseDate Date & time at which the asset was purchased.
				PurchaseDate *time.Time `json:"purchaseDate"`

				// PurchasePrice Purchase price of the asset.
				PurchasePrice *float64 `json:"purchasePrice"`

				// SalvageValue Salvage value of the asset.
				SalvageValue *float64 `json:"salvageValue"`

				// UsefulLifeYears Useful life of the asset in years.
				UsefulLifeYears *float64 `json:"usefulLifeYears"`

				// YearsDepreciated Years depreciated of the asset.
				YearsDepreciated *float64 `json:"yearsDepreciated"`
			} `json:"depreciation"`
			Description *string `json:"description"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "My Custom Field")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// GlobalUuid Global unique identifier of the asset used to identify assets as they are being transferred
			GlobalUuid *string `json:"globalUuid"`

			// Id Global ID of the asset
			Id int `json:"id"`

			// LocationId ID of the location where the asset is located
			LocationId *int `json:"locationId"`

			// Manufacturer Name of the manufacturer of the asset
			Manufacturer *string `json:"manufacturer"`

			// Model Name of the model of the asset
			Model *string `json:"model"`
			Name  string  `json:"name"`

			// ParentId ID of the parent asset
			ParentId *int `json:"parentId"`

			// SerialNumber Serial number of the asset
			SerialNumber *string `json:"serialNumber"`

			// TeamIds List of teams responsible for the asset
			TeamIds   *[]int `json:"teamIds,omitempty"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`

			// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`

			// VendorIds Vendor IDs
			VendorIds *[]float32 `json:"vendorIds,omitempty"`
		} `json:"asset"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                               `json:"error"`
			FieldPath  *string                              `json:"fieldPath"`
			FieldValue *PatchAssetsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchAssetsId400ErrorsFieldValue0 = string
type PatchAssetsId400ErrorsFieldValue1 = float32
type PatchAssetsId400ErrorsFieldValue2 = bool
type PatchAssetsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchAssetsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAssetsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAssetsIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAssetsIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAssetsIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAssetsIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *string
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r PutAssetsIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAssetsIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAssetsIdThumbnailFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                              `json:"error"`
			FieldPath  *string                                             `json:"fieldPath"`
			FieldValue *PutAssetsIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}
type PutAssetsIdThumbnailFilename400ErrorsFieldValue0 = string
type PutAssetsIdThumbnailFilename400ErrorsFieldValue1 = float32
type PutAssetsIdThumbnailFilename400ErrorsFieldValue2 = bool
type PutAssetsIdThumbnailFilename_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PutAssetsIdThumbnailFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAssetsIdThumbnailFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetstatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AssetStatuses []struct {
			// AssetId Global Parent asset ID of the asset status.
			AssetId *float32 `json:"assetId,omitempty"`

			// CreatedAt Date & time at which the asset status was created. This is the default sort by field, by descending (newest firsts)
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// CreatorId The Creator ID of the asset status.
			CreatorId *float32 `json:"creatorId,omitempty"`

			// CustomStatusId Id of the custom status assigned to asset.
			CustomStatusId *float32 `json:"customStatusId"`

			// DeletedAt Date & time at which the asset status was deleted.
			DeletedAt *time.Time `json:"deletedAt"`

			// Description Description of the asset status.
			Description *string `json:"description"`

			// DowntimeType Downtime type of the asset status.
			DowntimeType *GetAssetstatuses200AssetStatusesDowntimeType `json:"downtimeType"`

			// EndedAt Date & time at which the asset status ended at. Null means this status is still active, and is the current one.
			EndedAt *time.Time `json:"endedAt"`

			// Id Global ID of the asset status.
			Id *float32 `json:"id,omitempty"`

			// OrganizationId The Organization ID of the asset status.
			OrganizationId *float32 `json:"organizationId,omitempty"`

			// StartedAt Date & time at which the asset status was started at.
			StartedAt *time.Time `json:"startedAt,omitempty"`

			// Status Asset status value.
			Status *GetAssetstatuses200AssetStatusesStatus `json:"status,omitempty"`

			// UpdatedAt Date & time at which the asset status was last updated.
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`

			// UpdaterId The Updater ID of the asset status.
			UpdaterId *float32 `json:"updaterId"`
		} `json:"assetStatuses"`

		// NextCursor The cursor to retrieve the next page of Asset Statuses.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Asset Statuses.
		NextPageUrl *string `json:"nextPageUrl"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}
type GetAssetstatuses200AssetStatusesDowntimeType string
type GetAssetstatuses200AssetStatusesStatus string

// Status returns HTTPResponse.Status
func (r GetAssetstatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetstatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAssetstatusesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AssetStatus struct {
			// CreatedAt Date & time at which the asset status was created.
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// CustomStatusId Id of the custom status assigned to asset.
			CustomStatusId *float32 `json:"customStatusId"`

			// DeletedAt Date & time at which the asset status was deleted.
			DeletedAt    *time.Time                                      `json:"deletedAt"`
			Description  *string                                         `json:"description"`
			DowntimeType *PatchAssetstatusesId200AssetStatusDowntimeType `json:"downtimeType"`

			// EndedAt Asset status effective end date.
			EndedAt *time.Time `json:"endedAt"`

			// Id Global ID of the asset status.
			Id float32 `json:"id"`

			// StartedAt Asset status effective start date.
			StartedAt time.Time `json:"startedAt"`

			// Status Asset status value.
			Status *PatchAssetstatusesId200AssetStatusStatus `json:"status,omitempty"`

			// UpdatedAt Date & time at which the asset status was last updated.
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`
		} `json:"assetStatus"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                      `json:"error"`
			FieldPath  *string                                     `json:"fieldPath"`
			FieldValue *PatchAssetstatusesId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                      `json:"error"`
			FieldPath  *string                                     `json:"fieldPath"`
			FieldValue *PatchAssetstatusesId_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchAssetstatusesId200AssetStatusDowntimeType string
type PatchAssetstatusesId200AssetStatusStatus string
type PatchAssetstatusesId400ErrorsFieldValue0 = string
type PatchAssetstatusesId400ErrorsFieldValue1 = float32
type PatchAssetstatusesId400ErrorsFieldValue2 = bool
type PatchAssetstatusesId_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PatchAssetstatusesId403ErrorsFieldValue0 = string
type PatchAssetstatusesId403ErrorsFieldValue1 = float32
type PatchAssetstatusesId403ErrorsFieldValue2 = bool
type PatchAssetstatusesId_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchAssetstatusesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAssetstatusesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Categories []struct {
			// Description Description field for additional information.
			Description *string `json:"description,omitempty"`

			// Id Global ID of the category.
			Id int `json:"id"`

			// Label Label used when displaying the category.
			Label string `json:"label"`
		} `json:"categories"`

		// NextCursor The cursor to retrieve the next page of Categories.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Categories.
		NextPageUrl *string `json:"nextPageUrl"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the category.
		Id int `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                `json:"error"`
			FieldPath  *string                               `json:"fieldPath"`
			FieldValue *PostCategories_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostCategories400ErrorsFieldValue0 = string
type PostCategories400ErrorsFieldValue1 = float32
type PostCategories400ErrorsFieldValue2 = bool
type PostCategories_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCategoriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                    `json:"error"`
			FieldPath  *string                                   `json:"fieldPath"`
			FieldValue *DeleteCategoriesId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteCategoriesId400ErrorsFieldValue0 = string
type DeleteCategoriesId400ErrorsFieldValue1 = float32
type DeleteCategoriesId400ErrorsFieldValue2 = bool
type DeleteCategoriesId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteCategoriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCategoriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Category struct {
			// Description Description field for additional information.
			Description *string `json:"description,omitempty"`

			// Id Global ID of the category.
			Id int `json:"id"`

			// Label Label used when displaying the category.
			Label string `json:"label"`

			// UpdatedAt Date & time at which the category was last updated.
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`

			// WorkOrderCount The amount of work order using that category in your organization.
			WorkOrderCount *int `json:"workOrderCount,omitempty"`
		} `json:"category"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCategoriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchCategoriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Category struct {
			// Description Description field for additional information.
			Description *string `json:"description,omitempty"`

			// Id Global ID of the category.
			Id *int `json:"id,omitempty"`

			// Label Label used when displaying the category.
			Label string `json:"label"`

			// UpdatedAt Date & time at which the category was last updated.
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`

			// WorkOrderCount The amount of work order using that category in your organization.
			WorkOrderCount *int `json:"workOrderCount,omitempty"`
		} `json:"category"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                   `json:"error"`
			FieldPath  *string                                  `json:"fieldPath"`
			FieldValue *PatchCategoriesId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchCategoriesId400ErrorsFieldValue0 = string
type PatchCategoriesId400ErrorsFieldValue1 = float32
type PatchCategoriesId400ErrorsFieldValue2 = bool
type PatchCategoriesId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchCategoriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchCategoriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConversationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Conversations []struct {
			// Id Global ID of the conversation
			Id float32 `json:"id"`

			// Name Display name of the conversation
			Name *string `json:"name"`

			// Type Type of conversation
			Type GetConversations200ConversationsType `json:"type"`
		} `json:"conversations"`

		// NextCursor The cursor to retrieve the next page of Conversations.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Conversations.
		NextPageUrl *string `json:"nextPageUrl"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}
type GetConversations200ConversationsType string

// Status returns HTTPResponse.Status
func (r GetConversationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConversationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConversationsIdMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Members []struct {
			FirstName string `json:"firstName"`

			// Id Global ID of the user
			Id       int    `json:"id"`
			LastName string `json:"lastName"`
		} `json:"members"`

		// NextCursor The cursor to retrieve the next page of Members.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Members.
		NextPageUrl *string `json:"nextPageUrl"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetConversationsIdMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConversationsIdMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostConversationsIdMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the message
		Id float32 `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                             `json:"error"`
			FieldPath  *string                                            `json:"fieldPath"`
			FieldValue *PostConversationsIdMessages_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PostConversationsIdMessages400ErrorsFieldValue0 = string
type PostConversationsIdMessages400ErrorsFieldValue1 = float32
type PostConversationsIdMessages400ErrorsFieldValue2 = bool
type PostConversationsIdMessages_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostConversationsIdMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostConversationsIdMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomfieldsEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Id ID of the custom field
		Id float32 `json:"id"`

		// Label The label of the custom field
		Label string `json:"label"`

		// Options The possible choices to the field (if applicable).
		Options *[]string `json:"options,omitempty"`

		// Required This field is marked as required. This only affect the frontend.
		Required *bool `json:"required"`

		// SortOrder A weighted value used to sort the custom fields. Fields are sorted lowest to highest. This is different from sortIndex.
		SortOrder int                          `json:"sortOrder"`
		Type      GetCustomfieldsEntity200Type `json:"type"`

		// Unlisted This field is marked as unlisted. Once unlisted it will only be editable through the Rest API. When the custom field contains data, it will be displayed in the frontend; otherwise, it will remain hidden.
		Unlisted *bool `json:"unlisted"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                       `json:"error"`
			FieldPath  *string                                      `json:"fieldPath"`
			FieldValue *GetCustomfieldsEntity_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetCustomfieldsEntity200Type string
type GetCustomfieldsEntity400ErrorsFieldValue0 = string
type GetCustomfieldsEntity400ErrorsFieldValue1 = float32
type GetCustomfieldsEntity400ErrorsFieldValue2 = bool
type GetCustomfieldsEntity_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r GetCustomfieldsEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomfieldsEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomfieldsEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Id ID of the custom field
		Id float32 `json:"id"`

		// Label The label of the custom field
		Label string `json:"label"`

		// Options The possible choices to the field (if applicable).
		Options *[]string `json:"options,omitempty"`

		// SortOrder The order which the field will be displayed in the UI
		SortOrder int                           `json:"sortOrder"`
		Type      PostCustomfieldsEntity200Type `json:"type"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                        `json:"error"`
			FieldPath  *string                                       `json:"fieldPath"`
			FieldValue *PostCustomfieldsEntity_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                        `json:"error"`
			FieldPath  *string                                       `json:"fieldPath"`
			FieldValue *PostCustomfieldsEntity_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PostCustomfieldsEntity200Type string
type PostCustomfieldsEntity400ErrorsFieldValue0 = string
type PostCustomfieldsEntity400ErrorsFieldValue1 = float32
type PostCustomfieldsEntity400ErrorsFieldValue2 = bool
type PostCustomfieldsEntity_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PostCustomfieldsEntity403ErrorsFieldValue0 = string
type PostCustomfieldsEntity403ErrorsFieldValue1 = float32
type PostCustomfieldsEntity403ErrorsFieldValue2 = bool
type PostCustomfieldsEntity_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostCustomfieldsEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomfieldsEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomfieldsEntityIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                            `json:"error"`
			FieldPath  *string                                           `json:"fieldPath"`
			FieldValue *DeleteCustomfieldsEntityId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteCustomfieldsEntityId400ErrorsFieldValue0 = string
type DeleteCustomfieldsEntityId400ErrorsFieldValue1 = float32
type DeleteCustomfieldsEntityId400ErrorsFieldValue2 = bool
type DeleteCustomfieldsEntityId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteCustomfieldsEntityIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomfieldsEntityIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchCustomfieldsEntityIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                           `json:"error"`
			FieldPath  *string                                          `json:"fieldPath"`
			FieldValue *PatchCustomfieldsEntityId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                           `json:"error"`
			FieldPath  *string                                          `json:"fieldPath"`
			FieldValue *PatchCustomfieldsEntityId_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchCustomfieldsEntityId400ErrorsFieldValue0 = string
type PatchCustomfieldsEntityId400ErrorsFieldValue1 = float32
type PatchCustomfieldsEntityId400ErrorsFieldValue2 = bool
type PatchCustomfieldsEntityId_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PatchCustomfieldsEntityId403ErrorsFieldValue0 = string
type PatchCustomfieldsEntityId403ErrorsFieldValue1 = float32
type PatchCustomfieldsEntityId403ErrorsFieldValue2 = bool
type PatchCustomfieldsEntityId_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchCustomfieldsEntityIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchCustomfieldsEntityIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Locations []struct {
			// Address Postal address of the location
			Address *string `json:"address"`

			// Barcode String encoded barcode (expand with query parameter)
			Barcode *string `json:"barcode,omitempty"`

			// CreatedAt Date & time at which the location was created
			CreatedAt   *time.Time `json:"createdAt,omitempty"`
			Description *string    `json:"description"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Department") (expand with query parameter)
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the location
			Id   int    `json:"id"`
			Name string `json:"name"`

			// ParentId ID of the parent location
			ParentId *int `json:"parentId"`

			// TeamIds Team IDs (expand with query parameter)
			TeamIds *[]float32 `json:"teamIds,omitempty"`

			// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`

			// VendorIds Vendor IDs (expand with query parameter)
			VendorIds *[]float32 `json:"vendorIds,omitempty"`
		} `json:"locations"`

		// NextCursor The cursor to retrieve the next page of Locations.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Locations.
		NextPageUrl *string `json:"nextPageUrl"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id Global ID of the location
		Id int `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                               `json:"error"`
			FieldPath  *string                              `json:"fieldPath"`
			FieldValue *PostLocations_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostLocations400ErrorsFieldValue0 = string
type PostLocations400ErrorsFieldValue1 = float32
type PostLocations400ErrorsFieldValue2 = bool
type PostLocations_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLocationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                   `json:"error"`
			FieldPath  *string                                  `json:"fieldPath"`
			FieldValue *DeleteLocationsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteLocationsId400ErrorsFieldValue0 = string
type DeleteLocationsId400ErrorsFieldValue1 = float32
type DeleteLocationsId400ErrorsFieldValue2 = bool
type DeleteLocationsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteLocationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLocationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Location struct {
			// Address Postal address of the location
			Address *string `json:"address"`

			// Attachments List of attachments linked to the location
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// Barcode String encoded barcode
			Barcode *string `json:"barcode"`

			// ChildrenIds IDs of the location's children
			ChildrenIds *[]float32 `json:"childrenIds"`

			// CreatedAt Date & time at which the location was created
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// DeletedAt Date at which the location was deleted
			DeletedAt   *time.Time `json:"deletedAt"`
			Description *string    `json:"description"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Department")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the location
			Id   int    `json:"id"`
			Name string `json:"name"`

			// ParentId ID of the parent location
			ParentId *int `json:"parentId"`

			// TeamIds Team IDs
			TeamIds   *[]float32 `json:"teamIds,omitempty"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`

			// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`

			// VendorIds Vendor IDs
			VendorIds *[]float32 `json:"vendorIds,omitempty"`
		} `json:"location"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLocationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLocationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Location struct {
			// Address Postal address of the location
			Address *string `json:"address"`

			// Attachments List of attachments linked to the location
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// Barcode String encoded barcode
			Barcode *string `json:"barcode"`

			// ChildrenIds IDs of the location's children
			ChildrenIds *[]float32 `json:"childrenIds"`

			// CreatedAt Date & time at which the location was created
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// DeletedAt Date at which the location was deleted
			DeletedAt   *time.Time `json:"deletedAt"`
			Description *string    `json:"description"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Department")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the location
			Id   int    `json:"id"`
			Name string `json:"name"`

			// ParentId ID of the parent location
			ParentId *int `json:"parentId"`

			// TeamIds Team IDs
			TeamIds   *[]float32 `json:"teamIds,omitempty"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`

			// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`

			// VendorIds Vendor IDs
			VendorIds *[]float32 `json:"vendorIds,omitempty"`
		} `json:"location"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                  `json:"error"`
			FieldPath  *string                                 `json:"fieldPath"`
			FieldValue *PatchLocationsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchLocationsId400ErrorsFieldValue0 = string
type PatchLocationsId400ErrorsFieldValue1 = float32
type PatchLocationsId400ErrorsFieldValue2 = bool
type PatchLocationsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchLocationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLocationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLocationsIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteLocationsIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLocationsIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutLocationsIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *string
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r PutLocationsIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutLocationsIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutLocationsIdThumbnailFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                                 `json:"error"`
			FieldPath  *string                                                `json:"fieldPath"`
			FieldValue *PutLocationsIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}
type PutLocationsIdThumbnailFilename400ErrorsFieldValue0 = string
type PutLocationsIdThumbnailFilename400ErrorsFieldValue1 = float32
type PutLocationsIdThumbnailFilename400ErrorsFieldValue2 = bool
type PutLocationsIdThumbnailFilename_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PutLocationsIdThumbnailFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutLocationsIdThumbnailFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMeterreadingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]struct {
		// CreatedAt Meter Reading creation/processing date.
		CreatedAt string `json:"createdAt"`

		// MeterId Global ID of the meter.
		MeterId float32 `json:"meterId"`

		// ReadingDate Date at which the meter was read. This date can be set in the past, but cannot be further than 3 days for IoT meters.
		ReadingDate *string `json:"readingDate"`

		// Value The reading value given by the meter.
		Value float32 `json:"value"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                   `json:"error"`
			FieldPath  *string                                  `json:"fieldPath"`
			FieldValue *PostMeterreadings_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                   `json:"error"`
			FieldPath  *string                                  `json:"fieldPath"`
			FieldValue *PostMeterreadings_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON429 *struct {
		Error string `json:"error"`
	}
}
type PostMeterreadings400ErrorsFieldValue0 = string
type PostMeterreadings400ErrorsFieldValue1 = float32
type PostMeterreadings400ErrorsFieldValue2 = bool
type PostMeterreadings_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PostMeterreadings403ErrorsFieldValue0 = string
type PostMeterreadings403ErrorsFieldValue1 = float32
type PostMeterreadings403ErrorsFieldValue2 = bool
type PostMeterreadings_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostMeterreadingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMeterreadingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meters []struct {
			// Asset Asset linked to the element (expand with query parameter)
			Asset *struct {
				// CreatedAt Date & time at which the asset was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId ID of the asset creator
				CreatorId *int `json:"creatorId"`

				// CriticalityId ID of the criticality of the asset
				CriticalityId *int    `json:"criticalityId"`
				Description   *string `json:"description"`

				// Id Global ID of the asset
				Id int `json:"id"`

				// LocationId ID of the location where the asset is located
				LocationId *int   `json:"locationId"`
				Name       string `json:"name"`

				// ParentId ID of the parent asset
				ParentId *int `json:"parentId"`

				// SerialNumber Serial number of the asset
				SerialNumber *string `json:"serialNumber"`

				// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"asset"`

			// Id Global ID of the meter.
			Id float32 `json:"id"`

			// LastReading Last reading of a meter (expand with query parameter)
			LastReading *struct {
				// CreatedAt Meter Reading creation/processing date.
				CreatedAt string `json:"createdAt"`

				// Id Global ID of the reading.
				// IoT meters will produce IDs with the format '{meterId}-{uuid}', while manual meters will produce numbered IDs.
				Id string `json:"id"`

				// MeterId Global ID of the meter.
				MeterId float32 `json:"meterId"`

				// ReadingDate Date at which the meter was read. This date can be set in the past, but cannot be further than 3 days for IoT meters.
				ReadingDate *string `json:"readingDate"`

				// Value The reading value given by the meter.
				Value float32 `json:"value"`
			} `json:"lastReading"`

			// Location Location linked to the element (expand with query parameter)
			Location *struct {
				// Address Postal address of the location
				Address *string `json:"address"`

				// CreatedAt Date & time at which the location was created
				CreatedAt   *time.Time `json:"createdAt,omitempty"`
				Description *string    `json:"description"`

				// Id Global ID of the location
				Id   int    `json:"id"`
				Name string `json:"name"`

				// ParentId ID of the parent location
				ParentId *int `json:"parentId"`

				// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"location"`

			// MeasurementType Represents the Type of meter. <br><br><code>Manual</code>: They are made to be used in the MaintainX app and to retain manually entered values and are limited to 10 distinct readings creation requests per 24 hours over REST API. Batched readings requests only count as one toward the rate limit. <br><br><code>Automated</code>: (Enterprise Plan) Automated meters store high frequency readings sent from integrations and have normal rate limiting. <br><br>~~<code>IoT Device</code>~~: IoT Device meters are deprecated and should no longer be used in the future. Creating an IoT Device meter will mimic automated meters in terms of behavior to avoid breaking changes.
			MeasurementType GetMeters200MetersMeasurementType `json:"measurementType"`

			// Name Name of the meters
			Name string `json:"name"`

			// Unit Measurement unit for the readings. Any string is accepted. However, if applicable, we recommed you to use the following units as it may carry extra functionality: <br><ul>
			//             <li>Distance:
			//               <ul>
			//                 <li><code>Miles</code></li><li><code>Feet</code></li><li><code>Inches</code></li><li><code>Kilometers</code></li><li><code>Meters</code></li><li><code>Centimeters</code></li><li><code>Millimeters</code></li>
			//               </ul>
			//             </li>
			//             <li>Volume:
			//               <ul>
			//                 <li><code>Gallons</code></li><li><code>Liters</code></li><li><code>Milliliters</code></li><li><code>Cubic Meters</code></li>
			//               </ul>
			//             </li>
			//             <li>Temperature:
			//               <ul>
			//                 <li><code>Celsius</code></li><li><code>Fahrenheit</code></li><li><code>Kelvin</code></li>
			//               </ul>
			//             </li>
			//             <li>Other:
			//               <ul>
			//                 <li><code>Hours</code></li><li><code>Cycles</code></li><li><code>PSI</code></li><li><code>Kilograms</code></li><li><code>Grams</code></li><li><code>dBm</code></li><li><code>Nm</code></li>
			//               </ul>
			//             </li>
			//             <li>Velocity:
			//               <ul>
			//                 <li><code>MetersPerSecond</code></li><li><code>InchesPerSecond</code></li><li><code>MillimetersPerSecond</code></li>
			//               </ul>
			//             </li>
			//             <li>Acceleration:
			//               <ul>
			//                 <li><code>G-Force</code></li><li><code>MetersPerSecondSquared</code></li><li><code>FeetPerSecondSquared</code></li>
			//               </ul>
			//             </li>
			//             <li>Electrical:
			//               <ul>
			//                 <li><code>Volts</code></li><li><code>Amps</code></li>
			//               </ul>
			//             </li>
			//       </ul>
			//
			Unit string `json:"unit"`
		} `json:"meters"`

		// NextCursor The cursor to retrieve the next page of Meters.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Meters.
		NextPageUrl *string `json:"nextPageUrl"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}
type GetMeters200MetersMeasurementType string

// Status returns HTTPResponse.Status
func (r GetMetersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMetersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the meter.
		Id float32 `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                            `json:"error"`
			FieldPath  *string                           `json:"fieldPath"`
			FieldValue *PostMeters_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON502 *struct {
		Error string `json:"error"`
	}
}
type PostMeters400ErrorsFieldValue0 = string
type PostMeters400ErrorsFieldValue1 = float32
type PostMeters400ErrorsFieldValue2 = bool
type PostMeters_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostMetersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMetersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMetersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                `json:"error"`
			FieldPath  *string                               `json:"fieldPath"`
			FieldValue *DeleteMetersId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteMetersId400ErrorsFieldValue0 = string
type DeleteMetersId400ErrorsFieldValue1 = float32
type DeleteMetersId400ErrorsFieldValue2 = bool
type DeleteMetersId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteMetersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMetersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meter struct {
			// Asset Asset linked to the element (expand with query parameter)
			Asset *struct {
				// CreatedAt Date & time at which the asset was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId ID of the asset creator
				CreatorId *int `json:"creatorId"`

				// CriticalityId ID of the criticality of the asset
				CriticalityId *int    `json:"criticalityId"`
				Description   *string `json:"description"`

				// Id Global ID of the asset
				Id int `json:"id"`

				// LocationId ID of the location where the asset is located
				LocationId *int   `json:"locationId"`
				Name       string `json:"name"`

				// ParentId ID of the parent asset
				ParentId *int `json:"parentId"`

				// SerialNumber Serial number of the asset
				SerialNumber *string `json:"serialNumber"`

				// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"asset"`

			// AssetId Global ID of the asset tied to the meter
			AssetId *int `json:"assetId"`

			// CreatedAt Meter creation date.
			CreatedAt string `json:"createdAt"`

			// CreatorId Global ID of the user who created the meter
			CreatorId int `json:"creatorId"`

			// Description Description of the meter
			Description *string `json:"description"`

			// Id Global ID of the meter.
			Id float32 `json:"id"`

			// LastReading Last reading of a meter (expand with query parameter)
			LastReading *struct {
				// CreatedAt Meter Reading creation/processing date.
				CreatedAt string `json:"createdAt"`

				// Id Global ID of the reading.
				// IoT meters will produce IDs with the format '{meterId}-{uuid}', while manual meters will produce numbered IDs.
				Id string `json:"id"`

				// MeterId Global ID of the meter.
				MeterId float32 `json:"meterId"`

				// ReadingDate Date at which the meter was read. This date can be set in the past, but cannot be further than 3 days for IoT meters.
				ReadingDate *string `json:"readingDate"`

				// Value The reading value given by the meter.
				Value float32 `json:"value"`
			} `json:"lastReading"`

			// Location Location linked to the element (expand with query parameter)
			Location *struct {
				// Address Postal address of the location
				Address *string `json:"address"`

				// CreatedAt Date & time at which the location was created
				CreatedAt   *time.Time `json:"createdAt,omitempty"`
				Description *string    `json:"description"`

				// Id Global ID of the location
				Id   int    `json:"id"`
				Name string `json:"name"`

				// ParentId ID of the parent location
				ParentId *int `json:"parentId"`

				// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"location"`

			// LocationId Global ID of the location tied to the meter
			LocationId *int `json:"locationId"`

			// MeasurementType Represents the Type of meter. <br><br><code>Manual</code>: They are made to be used in the MaintainX app and to retain manually entered values and are limited to 10 distinct readings creation requests per 24 hours over REST API. Batched readings requests only count as one toward the rate limit. <br><br><code>Automated</code>: (Enterprise Plan) Automated meters store high frequency readings sent from integrations and have normal rate limiting. <br><br>~~<code>IoT Device</code>~~: IoT Device meters are deprecated and should no longer be used in the future. Creating an IoT Device meter will mimic automated meters in terms of behavior to avoid breaking changes.
			MeasurementType GetMetersId200MeterMeasurementType `json:"measurementType"`

			// Name Name of the meters
			Name string `json:"name"`

			// ReadingFrequency Expected reading frequency of the meter. Mostly useful for manual meters.
			ReadingFrequency *GetMetersId_200_Meter_ReadingFrequency `json:"readingFrequency"`

			// Unit Measurement unit for the readings. Any string is accepted. However, if applicable, we recommed you to use the following units as it may carry extra functionality: <br><ul>
			//             <li>Distance:
			//               <ul>
			//                 <li><code>Miles</code></li><li><code>Feet</code></li><li><code>Inches</code></li><li><code>Kilometers</code></li><li><code>Meters</code></li><li><code>Centimeters</code></li><li><code>Millimeters</code></li>
			//               </ul>
			//             </li>
			//             <li>Volume:
			//               <ul>
			//                 <li><code>Gallons</code></li><li><code>Liters</code></li><li><code>Milliliters</code></li><li><code>Cubic Meters</code></li>
			//               </ul>
			//             </li>
			//             <li>Temperature:
			//               <ul>
			//                 <li><code>Celsius</code></li><li><code>Fahrenheit</code></li><li><code>Kelvin</code></li>
			//               </ul>
			//             </li>
			//             <li>Other:
			//               <ul>
			//                 <li><code>Hours</code></li><li><code>Cycles</code></li><li><code>PSI</code></li><li><code>Kilograms</code></li><li><code>Grams</code></li><li><code>dBm</code></li><li><code>Nm</code></li>
			//               </ul>
			//             </li>
			//             <li>Velocity:
			//               <ul>
			//                 <li><code>MetersPerSecond</code></li><li><code>InchesPerSecond</code></li><li><code>MillimetersPerSecond</code></li>
			//               </ul>
			//             </li>
			//             <li>Acceleration:
			//               <ul>
			//                 <li><code>G-Force</code></li><li><code>MetersPerSecondSquared</code></li><li><code>FeetPerSecondSquared</code></li>
			//               </ul>
			//             </li>
			//             <li>Electrical:
			//               <ul>
			//                 <li><code>Volts</code></li><li><code>Amps</code></li>
			//               </ul>
			//             </li>
			//       </ul>
			//
			Unit string `json:"unit"`

			// UpdatedAt Date that Meter was last modified.
			UpdatedAt string `json:"updatedAt"`

			// UpdaterId Global ID of the last user who updated the meter
			UpdaterId *int `json:"updaterId"`

			// Uuid Universally unique identifier of the meter in the UUID format
			Uuid string `json:"uuid"`
		} `json:"meter"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetMetersId200MeterMeasurementType string
type GetMetersId200MeterReadingFrequency0 struct {
	// Interval Number of seconds between readings. Minimum 10s for IOT_DEVICE, 86400s for MANUAL
	Interval *int                                     `json:"interval,omitempty"`
	Type     GetMetersId200MeterReadingFrequency0Type `json:"type"`
}
type GetMetersId200MeterReadingFrequency0Type string
type GetMetersId200MeterReadingFrequency1 struct {
	// Interval Number of minutes between readings
	Interval *int                                     `json:"interval,omitempty"`
	Type     GetMetersId200MeterReadingFrequency1Type `json:"type"`
}
type GetMetersId200MeterReadingFrequency1Type string
type GetMetersId200MeterReadingFrequency2 struct {
	// Interval Number of hours between readings
	Interval *int                                     `json:"interval,omitempty"`
	Type     GetMetersId200MeterReadingFrequency2Type `json:"type"`
}
type GetMetersId200MeterReadingFrequency2Type string
type GetMetersId200MeterReadingFrequency3 struct {
	// Interval Number of days between readings
	Interval *int                                     `json:"interval,omitempty"`
	Type     GetMetersId200MeterReadingFrequency3Type `json:"type"`
}
type GetMetersId200MeterReadingFrequency3Type string
type GetMetersId200MeterReadingFrequency4 struct {
	// Days Days of the week the event will occur
	Days *[]GetMetersId200MeterReadingFrequency4Days `json:"days,omitempty"`

	// Interval Number of weeks between readings
	Interval *int                                     `json:"interval,omitempty"`
	Type     GetMetersId200MeterReadingFrequency4Type `json:"type"`
}
type GetMetersId200MeterReadingFrequency4Days string
type GetMetersId200MeterReadingFrequency4Type string
type GetMetersId200MeterReadingFrequency5 struct {
	// Day Day of the month the event will occur
	Day *int `json:"day,omitempty"`

	// Interval Number of months between readings
	Interval *int                                     `json:"interval,omitempty"`
	Type     GetMetersId200MeterReadingFrequency5Type `json:"type"`
}
type GetMetersId200MeterReadingFrequency5Type string
type GetMetersId200MeterReadingFrequency6 struct {
	// Interval Number of years between readings
	Interval *int                                     `json:"interval,omitempty"`
	Type     GetMetersId200MeterReadingFrequency6Type `json:"type"`
}
type GetMetersId200MeterReadingFrequency6Type string
type GetMetersId_200_Meter_ReadingFrequency struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r GetMetersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchMetersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meter struct {
			// AssetId Global ID of the asset tied to the meter
			AssetId *int `json:"assetId"`

			// CreatedAt Meter creation date.
			CreatedAt *string `json:"createdAt,omitempty"`

			// CreatorId Global ID of the user who created the meter
			CreatorId *int `json:"creatorId,omitempty"`

			// Description Description of the meter
			Description *string `json:"description"`

			// Id Global ID of the meter.
			Id float32 `json:"id"`

			// LocationId Global ID of the location tied to the meter
			LocationId *int `json:"locationId"`

			// MeasurementType Represents the Type of meter. <br><br><code>Manual</code>: They are made to be used in the MaintainX app and to retain manually entered values and are limited to 10 distinct readings creation requests per 24 hours over REST API. Batched readings requests only count as one toward the rate limit. <br><br><code>Automated</code>: (Enterprise Plan) Automated meters store high frequency readings sent from integrations and have normal rate limiting. <br><br>~~<code>IoT Device</code>~~: IoT Device meters are deprecated and should no longer be used in the future. Creating an IoT Device meter will mimic automated meters in terms of behavior to avoid breaking changes.
			MeasurementType *PatchMetersId200MeterMeasurementType `json:"measurementType,omitempty"`

			// Name Name of the meters
			Name string `json:"name"`

			// ReadingFrequency Expected reading frequency of the meter. Mostly useful for manual meters.
			ReadingFrequency *PatchMetersId_200_Meter_ReadingFrequency `json:"readingFrequency"`

			// Unit Measurement unit for the readings. Any string is accepted. However, if applicable, we recommed you to use the following units as it may carry extra functionality: <br><ul>
			//             <li>Distance:
			//               <ul>
			//                 <li><code>Miles</code></li><li><code>Feet</code></li><li><code>Inches</code></li><li><code>Kilometers</code></li><li><code>Meters</code></li><li><code>Centimeters</code></li><li><code>Millimeters</code></li>
			//               </ul>
			//             </li>
			//             <li>Volume:
			//               <ul>
			//                 <li><code>Gallons</code></li><li><code>Liters</code></li><li><code>Milliliters</code></li><li><code>Cubic Meters</code></li>
			//               </ul>
			//             </li>
			//             <li>Temperature:
			//               <ul>
			//                 <li><code>Celsius</code></li><li><code>Fahrenheit</code></li><li><code>Kelvin</code></li>
			//               </ul>
			//             </li>
			//             <li>Other:
			//               <ul>
			//                 <li><code>Hours</code></li><li><code>Cycles</code></li><li><code>PSI</code></li><li><code>Kilograms</code></li><li><code>Grams</code></li><li><code>dBm</code></li><li><code>Nm</code></li>
			//               </ul>
			//             </li>
			//             <li>Velocity:
			//               <ul>
			//                 <li><code>MetersPerSecond</code></li><li><code>InchesPerSecond</code></li><li><code>MillimetersPerSecond</code></li>
			//               </ul>
			//             </li>
			//             <li>Acceleration:
			//               <ul>
			//                 <li><code>G-Force</code></li><li><code>MetersPerSecondSquared</code></li><li><code>FeetPerSecondSquared</code></li>
			//               </ul>
			//             </li>
			//             <li>Electrical:
			//               <ul>
			//                 <li><code>Volts</code></li><li><code>Amps</code></li>
			//               </ul>
			//             </li>
			//       </ul>
			//
			Unit *string `json:"unit,omitempty"`

			// UpdatedAt Date that Meter was last modified.
			UpdatedAt *string `json:"updatedAt,omitempty"`

			// UpdaterId Global ID of the last user who updated the meter
			UpdaterId *int `json:"updaterId"`

			// Uuid Universally unique identifier of the meter in the UUID format
			Uuid *string `json:"uuid,omitempty"`
		} `json:"meter"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchMetersId200MeterMeasurementType string
type PatchMetersId200MeterReadingFrequency0 struct {
	// Interval Number of seconds between readings. Minimum 10s for IOT_DEVICE, 86400s for MANUAL
	Interval *int                                       `json:"interval,omitempty"`
	Type     PatchMetersId200MeterReadingFrequency0Type `json:"type"`
}
type PatchMetersId200MeterReadingFrequency0Type string
type PatchMetersId200MeterReadingFrequency1 struct {
	// Interval Number of minutes between readings
	Interval *int                                       `json:"interval,omitempty"`
	Type     PatchMetersId200MeterReadingFrequency1Type `json:"type"`
}
type PatchMetersId200MeterReadingFrequency1Type string
type PatchMetersId200MeterReadingFrequency2 struct {
	// Interval Number of hours between readings
	Interval *int                                       `json:"interval,omitempty"`
	Type     PatchMetersId200MeterReadingFrequency2Type `json:"type"`
}
type PatchMetersId200MeterReadingFrequency2Type string
type PatchMetersId200MeterReadingFrequency3 struct {
	// Interval Number of days between readings
	Interval *int                                       `json:"interval,omitempty"`
	Type     PatchMetersId200MeterReadingFrequency3Type `json:"type"`
}
type PatchMetersId200MeterReadingFrequency3Type string
type PatchMetersId200MeterReadingFrequency4 struct {
	// Days Days of the week the event will occur
	Days *[]PatchMetersId200MeterReadingFrequency4Days `json:"days,omitempty"`

	// Interval Number of weeks between readings
	Interval *int                                       `json:"interval,omitempty"`
	Type     PatchMetersId200MeterReadingFrequency4Type `json:"type"`
}
type PatchMetersId200MeterReadingFrequency4Days string
type PatchMetersId200MeterReadingFrequency4Type string
type PatchMetersId200MeterReadingFrequency5 struct {
	// Day Day of the month the event will occur
	Day *int `json:"day,omitempty"`

	// Interval Number of months between readings
	Interval *int                                       `json:"interval,omitempty"`
	Type     PatchMetersId200MeterReadingFrequency5Type `json:"type"`
}
type PatchMetersId200MeterReadingFrequency5Type string
type PatchMetersId200MeterReadingFrequency6 struct {
	// Interval Number of years between readings
	Interval *int                                       `json:"interval,omitempty"`
	Type     PatchMetersId200MeterReadingFrequency6Type `json:"type"`
}
type PatchMetersId200MeterReadingFrequency6Type string
type PatchMetersId_200_Meter_ReadingFrequency struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchMetersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchMetersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMetersMeterIdReadingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// CreatedAt Reading creation or processing date.
		CreatedAt *string `json:"createdAt,omitempty"`

		// Id Global ID of the reading.
		// IoT meters will produce IDs with the format '{meterId}-{uuid}', while manual meters will produce numbered IDs.
		Id string `json:"id"`

		// ReadingDate Reading date when the meter was read. This date can be set in the past, but cannot go further than 3 days for IoT meters.
		ReadingDate *string `json:"readingDate"`

		// ReadingValue The reading value given by the meter.
		ReadingValue float32 `json:"readingValue"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                           `json:"error"`
			FieldPath  *string                                          `json:"fieldPath"`
			FieldValue *PostMetersMeterIdReadings_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON429 *struct {
		Error string `json:"error"`
	}
}
type PostMetersMeterIdReadings400ErrorsFieldValue0 = string
type PostMetersMeterIdReadings400ErrorsFieldValue1 = float32
type PostMetersMeterIdReadings400ErrorsFieldValue2 = bool
type PostMetersMeterIdReadings_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostMetersMeterIdReadingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMetersMeterIdReadingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetertriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		MeterTriggers []struct {
			// Id Global ID of the trigger.
			Id float32 `json:"id"`

			// MeterId Global ID of the meter.
			MeterId float32 `json:"meterId"`
			Name    string  `json:"name"`
		} `json:"meterTriggers"`

		// NextCursor The cursor to retrieve the next page of Meter Triggers.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Meter Triggers.
		NextPageUrl *string `json:"nextPageUrl"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMetertriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetertriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMetertriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Id of the meter trigger
		Id float32 `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                   `json:"error"`
			FieldPath  *string                                  `json:"fieldPath"`
			FieldValue *PostMetertriggers_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostMetertriggers400ErrorsFieldValue0 = string
type PostMetertriggers400ErrorsFieldValue1 = float32
type PostMetertriggers400ErrorsFieldValue2 = bool
type PostMetertriggers_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostMetertriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMetertriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMetertriggersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                       `json:"error"`
			FieldPath  *string                                      `json:"fieldPath"`
			FieldValue *DeleteMetertriggersId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteMetertriggersId400ErrorsFieldValue0 = string
type DeleteMetertriggersId400ErrorsFieldValue1 = float32
type DeleteMetertriggersId400ErrorsFieldValue2 = bool
type DeleteMetertriggersId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteMetertriggersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMetertriggersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetertriggersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		MeterTrigger struct {
			// Amount Value used to trigger the condition
			Amount float32 `json:"amount"`

			// Condition Condition of the trigger
			Condition GetMetertriggersId200MeterTriggerCondition `json:"condition"`

			// CreatedAt Date at which the meter was created
			CreatedAt time.Time `json:"createdAt"`

			// CreatorId Global ID of the meter trigger's creator
			CreatorId  int `json:"creatorId"`
			DataPoints *struct {
				// Denominator The window of points where the condition gets checked
				Denominator *int `json:"denominator,omitempty"`

				// Numerator The number of data points out of "denominator" data points to trigger. E.g: 3 points out of 5 must be in a triggering state
				Numerator *int `json:"numerator,omitempty"`
			} `json:"dataPoints"`

			// DeletedAt Data at which the meter was delated
			DeletedAt   *time.Time `json:"deletedAt"`
			Description *string    `json:"description"`

			// Id Global ID of the meter trigger
			Id int `json:"id"`

			// MeterId Global ID of the meter
			MeterId int `json:"meterId"`

			// MinDateForProcessing Date that the trigger will start to be active
			MinDateForProcessing *time.Time `json:"minDateForProcessing"`

			// Name Name of the trigger
			Name string `json:"name"`

			// NextTriggerValue Can be set to override the first trigger value
			NextTriggerValue *float32 `json:"nextTriggerValue"`

			// OrganizationId Global ID of the organization
			OrganizationId int `json:"organizationId"`

			// Period Window in seconds where the data points can be checked
			Period *int `json:"period"`

			// State State of the trigger
			State GetMetertriggersId200MeterTriggerState `json:"state"`

			// UpdatedAt Date at which the meter was updated
			UpdatedAt time.Time `json:"updatedAt"`

			// WorkOrderTemplate Work Order template used by the meter trigger (expand with query parameter)
			WorkOrderTemplate *struct {
				// CreatedAt Date & time at which the work order template was created
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// CreatorId ID of the user who created the work order
				CreatorId *int `json:"creatorId"`
				Data      *struct {
					// AssetId Global ID of the asset assigned to the work order
					AssetId *int `json:"assetId"`

					// AssigneeIds Users IDs assigned to the template
					AssigneeIds *[]float32 `json:"assigneeIds,omitempty"`

					// AttachmentIds IDs of the attachments on the template
					AttachmentIds *[]float32 `json:"attachmentIds"`
					Description   *string    `json:"description"`
					DueDate       *struct {
						Offset *float32                                                           `json:"offset,omitempty"`
						Type   *GetMetertriggersId200MeterTriggerWorkOrderTemplateDataDueDateType `json:"type,omitempty"`
					} `json:"dueDate"`

					// LocationId Global ID of the location assigned to the work order
					LocationId *int `json:"locationId"`
					PartsUsed  *[]struct {
						Area *string `json:"area"`

						// AvailableQuantity Quantity currently in stock
						AvailableQuantity *int `json:"availableQuantity,omitempty"`

						// Barcode String encoded barcode
						Barcode *string `json:"barcode"`

						// CopyOnRecurring Indicates if the parts will be copied to the next work order in the chain (if applicable).
						CopyOnRecurring *GetMetertriggersId200MeterTriggerWorkOrderTemplateDataPartsUsedCopyOnRecurring `json:"copyOnRecurring,omitempty"`
						Description     *string                                                                         `json:"description"`
						ExtraFields     *map[string]string                                                              `json:"extraFields,omitempty"`

						// Id Global ID of the part
						Id *int `json:"id,omitempty"`

						// LocationId Global ID of the location of the part
						LocationId *float32 `json:"locationId"`

						// MinimumQuantity Minimum quantity before you should restock
						MinimumQuantity *int    `json:"minimumQuantity,omitempty"`
						Name            *string `json:"name,omitempty"`

						// QuantityUsed Quantity used in the work order.
						QuantityUsed *int `json:"quantityUsed,omitempty"`

						// UnitCost Cost in cents. For example, for $1.20, put 120.
						UnitCost *int `json:"unitCost"`
					} `json:"partsUsed"`
					Priority  *GetMetertriggersId200MeterTriggerWorkOrderTemplateDataPriority `json:"priority,omitempty"`
					Procedure *struct {
						Fields []struct {
							AttachmentId *float32 `json:"attachmentId"`

							// Attachments List of attachments linked to the procedure row
							Attachments *[]struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachments,omitempty"`
							Choices     *[]string `json:"choices"`
							Description *string   `json:"description"`
							Id          float32   `json:"id"`

							// IsDateAndTime Indicate if a DATE field also contains the time
							IsDateAndTime *bool                                                                     `json:"isDateAndTime"`
							Label         string                                                                    `json:"label"`
							MeterId       *float32                                                                  `json:"meterId"`
							Type          GetMetertriggersId200MeterTriggerWorkOrderTemplateDataProcedureFieldsType `json:"type"`
							Urls          *[]struct {
								// Label Label of the url
								Label *string `json:"label,omitempty"`

								// Link Link
								Link string `json:"link"`
							} `json:"urls,omitempty"`
						} `json:"fields"`
						Title string `json:"title"`
					} `json:"procedure"`

					// TagsIds Categories IDs
					TagsIds *[]float32 `json:"tagsIds,omitempty"`

					// TeamIds Teams IDs
					TeamIds *[]float32 `json:"teamIds,omitempty"`

					// ThumbnailId ID of the attachment used as thumbnail
					ThumbnailId *int `json:"thumbnailId"`

					// Title Use the `title` field outside of the data object instead
					// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
					Title *string `json:"title,omitempty"`

					// VendorIds Vendor IDs
					VendorIds *[]float32 `json:"vendorIds,omitempty"`
				} `json:"data,omitempty"`

				// DeletedAt Time at which the template was deleted
				DeletedAt *time.Time `json:"deletedAt"`

				// Id Global ID of the work order template
				Id *int `json:"id,omitempty"`

				// OrganizationId ID of the organization
				OrganizationId *int `json:"organizationId"`

				// ProcedureTemplateId ID of the procedure template used if in the library
				ProcedureTemplateId *int `json:"procedureTemplateId"`

				// Title Title of the work order that will be generated. Use the meter trigger's name instead
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				Title *string `json:"title,omitempty"`

				// UpdatedAt Time at which the template was updated
				UpdatedAt *time.Time `json:"updatedAt"`
			} `json:"workOrderTemplate"`

			// WorkOrderTemplateId Global ID of the work order template used by the meter trigger
			WorkOrderTemplateId *int `json:"workOrderTemplateId"`
		} `json:"meterTrigger"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetMetertriggersId200MeterTriggerCondition string
type GetMetertriggersId200MeterTriggerState string
type GetMetertriggersId200MeterTriggerWorkOrderTemplateDataDueDateType string
type GetMetertriggersId200MeterTriggerWorkOrderTemplateDataPartsUsedCopyOnRecurring string
type GetMetertriggersId200MeterTriggerWorkOrderTemplateDataPriority string
type GetMetertriggersId200MeterTriggerWorkOrderTemplateDataProcedureFieldsType string

// Status returns HTTPResponse.Status
func (r GetMetertriggersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetertriggersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchMetertriggersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                      `json:"error"`
			FieldPath  *string                                     `json:"fieldPath"`
			FieldValue *PatchMetertriggersId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchMetertriggersId400ErrorsFieldValue0 = string
type PatchMetertriggersId400ErrorsFieldValue1 = float32
type PatchMetertriggersId400ErrorsFieldValue2 = bool
type PatchMetertriggersId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchMetertriggersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchMetertriggersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutMetertriggersIdThumbnailFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                                     `json:"error"`
			FieldPath  *string                                                    `json:"fieldPath"`
			FieldValue *PutMetertriggersIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}
type PutMetertriggersIdThumbnailFilename400ErrorsFieldValue0 = string
type PutMetertriggersIdThumbnailFilename400ErrorsFieldValue1 = float32
type PutMetertriggersIdThumbnailFilename400ErrorsFieldValue2 = bool
type PutMetertriggersIdThumbnailFilename_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PutMetertriggersIdThumbnailFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutMetertriggersIdThumbnailFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchMetertriggersIdWorkordertemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                                        `json:"error"`
			FieldPath  *string                                                       `json:"fieldPath"`
			FieldValue *PatchMetertriggersIdWorkordertemplates_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchMetertriggersIdWorkordertemplates400ErrorsFieldValue0 = string
type PatchMetertriggersIdWorkordertemplates400ErrorsFieldValue1 = float32
type PatchMetertriggersIdWorkordertemplates400ErrorsFieldValue2 = bool
type PatchMetertriggersIdWorkordertemplates_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchMetertriggersIdWorkordertemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchMetertriggersIdWorkordertemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *string
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r PutMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor The cursor to retrieve the next page of Organizations.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Organizations.
		NextPageUrl   *string `json:"nextPageUrl"`
		Organizations []struct {
			// Currency Currency of the organization
			Currency *string `json:"currency"`

			// DateFormatLocale Date format locale of the organization
			DateFormatLocale *string `json:"dateFormatLocale"`

			// Id Global ID of the organization
			Id int `json:"id"`

			// ImageUrl URL of the organization image
			ImageUrl *string `json:"imageUrl"`

			// Name Name of the organization
			Name string `json:"name"`

			// TimeZone Time zone of the organization. default: Etc/UTC
			TimeZone *string `json:"timeZone,omitempty"`
		} `json:"organizations"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPartsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor The cursor to retrieve the next page of Parts.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Parts.
		NextPageUrl *string `json:"nextPageUrl"`
		Parts       []struct {
			// Area Area of the part. Deprecated: for Parts with multiple locations, use the new field in `locations`
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			Area *string `json:"area"`

			// AvailableQuantity Total quantity currently in stock. If your plan includes multi-location parts, this is the quantity across all part locations.
			AvailableQuantity int `json:"availableQuantity"`

			// Barcode String encoded barcode
			Barcode *string `json:"barcode"`

			// CreatedAt Date & time at which the part was created
			CreatedAt   time.Time `json:"createdAt"`
			Description *string   `json:"description"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number") (expand with query parameter)
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the part
			Id int `json:"id"`

			// LocationId ID of the location where the part is located. Deprecated: for Parts with multiple locations, use the new field in `locations`
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			LocationId *int `json:"locationId"`

			// Locations Detailed list of locations where the part is stored, including properties such as available quantity, minimum quantity, reserved quantity, and area within each location.
			Locations []struct {
				Area *string `json:"area"`

				// AvailableQuantity Quantity currently in stock
				AvailableQuantity *int `json:"availableQuantity,omitempty"`

				// LocationId ID of the location where the part is located
				LocationId int `json:"locationId"`

				// MinimumQuantity Minimum quantity before you should restock
				MinimumQuantity *int `json:"minimumQuantity"`

				// ReservedQuantity Quantity currently reserved for work orders
				ReservedQuantity *int `json:"reservedQuantity"`
			} `json:"locations"`

			// MinimumQuantity Total minimum quantity before you should restock. If your plan includes multi-location parts, this is the quantity across all part locations.
			MinimumQuantity int    `json:"minimumQuantity"`
			Name            string `json:"name"`

			// OrderedQuantity Total quantity currently on order from purchase orders. If your plan includes multi-location parts, this is the quantity across all part locations.
			OrderedQuantity int `json:"orderedQuantity"`

			// PartTypes List of part types
			PartTypes []string `json:"partTypes"`

			// ReservedQuantity Total quantity currently reserved for work orders. If your plan includes multi-location parts, this is the quantity across all part locations.
			ReservedQuantity int `json:"reservedQuantity"`

			// UnitCost Cost in cents. For example, for $1.20, put 120.
			UnitCost *int `json:"unitCost"`

			// UpdatedAt Date & time at which the part was last updated. This doesn't include comments
			UpdatedAt time.Time `json:"updatedAt"`

			// Vendors List of vendors of the part (expand with query parameter)
			Vendors *[]struct {
				// PartNumber Part number given to the part by this vendor
				PartNumber *string `json:"partNumber,omitempty"`

				// VendorId Id of the vendor
				VendorId *int `json:"vendorId,omitempty"`
			} `json:"vendors,omitempty"`
		} `json:"parts"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPartsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPartsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPartsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the part
		Id int `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                           `json:"error"`
			FieldPath  *string                          `json:"fieldPath"`
			FieldValue *PostParts_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostParts400ErrorsFieldValue0 = string
type PostParts400ErrorsFieldValue1 = float32
type PostParts400ErrorsFieldValue2 = bool
type PostParts_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostPartsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPartsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePartsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                               `json:"error"`
			FieldPath  *string                              `json:"fieldPath"`
			FieldValue *DeletePartsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeletePartsId400ErrorsFieldValue0 = string
type DeletePartsId400ErrorsFieldValue1 = float32
type DeletePartsId400ErrorsFieldValue2 = bool
type DeletePartsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeletePartsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePartsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPartsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Part struct {
			// Area Area of the part. Deprecated: for Parts with multiple locations, use the new field in `locations`
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			Area *string `json:"area"`

			// AssetIds List of asset IDs
			AssetIds *[]int `json:"assetIds,omitempty"`

			// Attachments List of attachments linked to the part
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// AvailableQuantity Total quantity currently in stock. If your plan includes multi-location parts, this is the quantity across all part locations.
			AvailableQuantity *int `json:"availableQuantity,omitempty"`

			// Barcode String encoded barcode
			Barcode *string `json:"barcode"`

			// CreatedAt Date & time at which the part was created
			CreatedAt time.Time `json:"createdAt"`

			// DeletedAt Date at which the part was deleted
			DeletedAt   *time.Time `json:"deletedAt"`
			Description *string    `json:"description"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the part
			Id int `json:"id"`

			// LocationId ID of the location where the part is located. Deprecated: for Parts with multiple locations, use the new field in `locations`
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			LocationId *int `json:"locationId"`

			// Locations Detailed list of locations where the part is stored, including properties such as available quantity, minimum quantity, reserved quantity, and area within each location.
			Locations *[]struct {
				Area *string `json:"area"`

				// AvailableQuantity Quantity currently in stock
				AvailableQuantity *int `json:"availableQuantity,omitempty"`

				// LocationId ID of the location where the part is located
				LocationId int `json:"locationId"`

				// MinimumQuantity Minimum quantity before you should restock
				MinimumQuantity *int `json:"minimumQuantity"`

				// ReservedQuantity Quantity currently reserved for work orders
				ReservedQuantity *int `json:"reservedQuantity"`
			} `json:"locations,omitempty"`

			// MinimumQuantity Total minimum quantity before you should restock. If your plan includes multi-location parts, this is the quantity across all part locations.
			MinimumQuantity *int   `json:"minimumQuantity,omitempty"`
			Name            string `json:"name"`

			// OrderedQuantity Total quantity currently on order from purchase orders. If your plan includes multi-location parts, this is the quantity across all part locations.
			OrderedQuantity *int `json:"orderedQuantity,omitempty"`

			// PartTypes List of part types
			PartTypes *[]string `json:"partTypes,omitempty"`

			// ReservedQuantity Total quantity currently reserved for work orders. If your plan includes multi-location parts, this is the quantity across all part locations.
			ReservedQuantity *int `json:"reservedQuantity,omitempty"`

			// TeamIds List of team IDs in charge of the part
			TeamIds   *[]int `json:"teamIds,omitempty"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`

			// UnitCost Cost in cents. For example, for $1.20, put 120.
			UnitCost *int `json:"unitCost"`

			// UpdatedAt Date & time at which the part was last updated. This doesn't include comments
			UpdatedAt time.Time `json:"updatedAt"`

			// VendorIds List of vendor IDs
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			VendorIds *[]int `json:"vendorIds,omitempty"`

			// Vendors List of vendors of the part
			Vendors *[]struct {
				// PartNumber Part number given to the part by this vendor
				PartNumber *string `json:"partNumber,omitempty"`

				// VendorId Id of the vendor
				VendorId *int `json:"vendorId,omitempty"`
			} `json:"vendors,omitempty"`
		} `json:"part"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPartsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPartsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPartsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Part struct {
			// Area Area of the part. Deprecated: for Parts with multiple locations, use the new field in `locations`
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			Area *string `json:"area"`

			// AssetIds List of asset IDs
			AssetIds *[]int `json:"assetIds,omitempty"`

			// Attachments List of attachments linked to the part
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// AvailableQuantity Total quantity currently in stock. If your plan includes multi-location parts, this is the quantity across all part locations.
			AvailableQuantity *int `json:"availableQuantity,omitempty"`

			// Barcode String encoded barcode
			Barcode *string `json:"barcode"`

			// CreatedAt Date & time at which the part was created
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// DeletedAt Date at which the part was deleted
			DeletedAt   *time.Time `json:"deletedAt"`
			Description *string    `json:"description"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the part
			Id int `json:"id"`

			// LocationId ID of the location where the part is located. Deprecated: for Parts with multiple locations, use the new field in `locations`
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			LocationId *int `json:"locationId"`

			// Locations Detailed list of locations where the part is stored, including properties such as available quantity, minimum quantity, reserved quantity, and area within each location.
			Locations *[]struct {
				Area *string `json:"area"`

				// AvailableQuantity Quantity currently in stock
				AvailableQuantity *int `json:"availableQuantity,omitempty"`

				// LocationId ID of the location where the part is located
				LocationId int `json:"locationId"`

				// MinimumQuantity Minimum quantity before you should restock
				MinimumQuantity *int `json:"minimumQuantity"`

				// ReservedQuantity Quantity currently reserved for work orders
				ReservedQuantity *int `json:"reservedQuantity"`
			} `json:"locations,omitempty"`

			// MinimumQuantity Total minimum quantity before you should restock. If your plan includes multi-location parts, this is the quantity across all part locations.
			MinimumQuantity *int   `json:"minimumQuantity,omitempty"`
			Name            string `json:"name"`

			// OrderedQuantity Total quantity currently on order from purchase orders. If your plan includes multi-location parts, this is the quantity across all part locations.
			OrderedQuantity *int `json:"orderedQuantity,omitempty"`

			// PartTypes List of part types
			PartTypes *[]string `json:"partTypes,omitempty"`

			// ReservedQuantity Total quantity currently reserved for work orders. If your plan includes multi-location parts, this is the quantity across all part locations.
			ReservedQuantity *int `json:"reservedQuantity,omitempty"`

			// TeamIds List of team IDs in charge of the part
			TeamIds   *[]int `json:"teamIds,omitempty"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`

			// UnitCost Cost in cents. For example, for $1.20, put 120.
			UnitCost *int `json:"unitCost"`

			// UpdatedAt Date & time at which the part was last updated. This doesn't include comments
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`

			// VendorIds List of vendor IDs
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			VendorIds *[]int `json:"vendorIds,omitempty"`

			// Vendors List of vendors of the part
			Vendors *[]struct {
				// PartNumber Part number given to the part by this vendor
				PartNumber *string `json:"partNumber,omitempty"`

				// VendorId Id of the vendor
				VendorId *int `json:"vendorId,omitempty"`
			} `json:"vendors,omitempty"`
		} `json:"part"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                              `json:"error"`
			FieldPath  *string                             `json:"fieldPath"`
			FieldValue *PatchPartsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchPartsId400ErrorsFieldValue0 = string
type PatchPartsId400ErrorsFieldValue1 = float32
type PatchPartsId400ErrorsFieldValue2 = bool
type PatchPartsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchPartsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPartsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePartsIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePartsIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePartsIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutPartsIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *string
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r PutPartsIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutPartsIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutPartsIdThumbnailFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                             `json:"error"`
			FieldPath  *string                                            `json:"fieldPath"`
			FieldValue *PutPartsIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}
type PutPartsIdThumbnailFilename400ErrorsFieldValue0 = string
type PutPartsIdThumbnailFilename400ErrorsFieldValue1 = float32
type PutPartsIdThumbnailFilename400ErrorsFieldValue2 = bool
type PutPartsIdThumbnailFilename_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PutPartsIdThumbnailFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutPartsIdThumbnailFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetParttransferrequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor The cursor to retrieve the next page of Part Transfer Requests.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Part Transfer Requests.
		NextPageUrl          *string `json:"nextPageUrl"`
		PartTransferRequests []struct {
			// DestinationLocations Locations into which the transferred parts were received. (Receiving stocks)
			DestinationLocations *[]struct {
				// LocationId ID of the location in the organization where the part is being received. (Receiving stocks)
				LocationId *int `json:"locationId,omitempty"`

				// Quantity Quantity of parts received.
				Quantity int `json:"quantity"`
			} `json:"destinationLocations,omitempty"`

			// DestinationOrganizationId ID of the organization performing the request. (Requesting/receiving stocks)
			DestinationOrganizationId int `json:"destinationOrganizationId"`

			// DestinationPartId ID of the part that belongs to the organization performing the request. (Receiving stocks)
			DestinationPartId int `json:"destinationPartId"`

			// Id Global ID of the part transfer request.
			Id int `json:"id"`

			// QuantityReceived Quantity of parts received.
			QuantityReceived *int `json:"quantityReceived"`

			// QuantityRequested Quantity of parts requested for transfer.
			QuantityRequested int `json:"quantityRequested"`

			// QuantityTransferred Quantity of parts transferred.
			QuantityTransferred *int `json:"quantityTransferred"`

			// RequestMessage Message to give context surrounding the part transfer request.
			RequestMessage *string `json:"requestMessage"`

			// RequesterId ID of the user performing the request. (Requesting/receiving stocks)
			RequesterId *int `json:"requesterId,omitempty"`

			// ResponseMessage Message to give context surrounding the transfer of the part transfer request.
			ResponseMessage *string `json:"responseMessage"`

			// SourceLocationId ID of the location in the organization from which parts were transferred. (Sending stocks)
			SourceLocationId *int `json:"sourceLocationId,omitempty"`

			// SourceOrganizationId ID of the organization receiving the request. (Sending stocks)
			SourceOrganizationId int `json:"sourceOrganizationId"`

			// SourcePartId ID of the part that belongs to the organization receiving the request. (Sending stocks)
			SourcePartId int `json:"sourcePartId"`

			// Status Status of the part transfer request.
			Status *GetParttransferrequests200PartTransferRequestsStatus `json:"status,omitempty"`

			// TransferrerId ID of the user performing the transfer. (Sending stocks)
			TransferrerId *int `json:"transferrerId"`
		} `json:"partTransferRequests"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}
type GetParttransferrequests200PartTransferRequestsStatus string

// Status returns HTTPResponse.Status
func (r GetParttransferrequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetParttransferrequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostParttransferrequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the part transfer request.
		Id int `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                          `json:"error"`
			FieldPath  *string                                         `json:"fieldPath"`
			FieldValue *PostParttransferrequests_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PostParttransferrequests400ErrorsFieldValue0 = string
type PostParttransferrequests400ErrorsFieldValue1 = float32
type PostParttransferrequests400ErrorsFieldValue2 = bool
type PostParttransferrequests_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostParttransferrequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostParttransferrequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetParttransferrequestsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		PartTransferRequest struct {
			// DestinationLocations Locations into which the transferred parts were received. (Receiving stocks)
			DestinationLocations *[]struct {
				// LocationId ID of the location in the organization where the part is being received. (Receiving stocks)
				LocationId *int `json:"locationId,omitempty"`

				// Quantity Quantity of parts received.
				Quantity int `json:"quantity"`
			} `json:"destinationLocations,omitempty"`

			// DestinationOrganizationId ID of the organization performing the request. (Requesting/receiving stocks)
			DestinationOrganizationId int `json:"destinationOrganizationId"`

			// DestinationPartId ID of the part that belongs to the organization performing the request. (Receiving stocks)
			DestinationPartId int `json:"destinationPartId"`

			// Id Global ID of the part transfer request.
			Id int `json:"id"`

			// QuantityReceived Quantity of parts received.
			QuantityReceived *int `json:"quantityReceived"`

			// QuantityRequested Quantity of parts requested for transfer.
			QuantityRequested int `json:"quantityRequested"`

			// QuantityTransferred Quantity of parts transferred.
			QuantityTransferred *int `json:"quantityTransferred"`

			// RequestMessage Message to give context surrounding the part transfer request.
			RequestMessage *string `json:"requestMessage"`

			// RequesterId ID of the user performing the request. (Requesting/receiving stocks)
			RequesterId *int `json:"requesterId,omitempty"`

			// ResponseMessage Message to give context surrounding the transfer of the part transfer request.
			ResponseMessage *string `json:"responseMessage"`

			// SourceLocationId ID of the location in the organization from which parts were transferred. (Sending stocks)
			SourceLocationId *int `json:"sourceLocationId,omitempty"`

			// SourceOrganizationId ID of the organization receiving the request. (Sending stocks)
			SourceOrganizationId int `json:"sourceOrganizationId"`

			// SourcePartId ID of the part that belongs to the organization receiving the request. (Sending stocks)
			SourcePartId int `json:"sourcePartId"`

			// Status Status of the part transfer request.
			Status *GetParttransferrequestsId200PartTransferRequestStatus `json:"status,omitempty"`

			// TransferrerId ID of the user performing the transfer. (Sending stocks)
			TransferrerId *int `json:"transferrerId"`
		} `json:"partTransferRequest"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetParttransferrequestsId200PartTransferRequestStatus string

// Status returns HTTPResponse.Status
func (r GetParttransferrequestsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetParttransferrequestsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchParttransferrequestsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		PartTransferRequest struct {
			// DestinationLocations Locations into which the transferred parts were received. (Receiving stocks)
			DestinationLocations *[]struct {
				// LocationId ID of the location in the organization where the part is being received. (Receiving stocks)
				LocationId *int `json:"locationId,omitempty"`

				// Quantity Quantity of parts received.
				Quantity int `json:"quantity"`
			} `json:"destinationLocations,omitempty"`

			// DestinationOrganizationId ID of the organization performing the request. (Requesting/receiving stocks)
			DestinationOrganizationId int `json:"destinationOrganizationId"`

			// DestinationPartId ID of the part that belongs to the organization performing the request. (Receiving stocks)
			DestinationPartId int `json:"destinationPartId"`

			// Id Global ID of the part transfer request.
			Id int `json:"id"`

			// QuantityReceived Quantity of parts received.
			QuantityReceived *int `json:"quantityReceived"`

			// QuantityRequested Quantity of parts requested for transfer.
			QuantityRequested int `json:"quantityRequested"`

			// QuantityTransferred Quantity of parts transferred.
			QuantityTransferred *int `json:"quantityTransferred"`

			// RequestMessage Message to give context surrounding the part transfer request.
			RequestMessage *string `json:"requestMessage"`

			// RequesterId ID of the user performing the request. (Requesting/receiving stocks)
			RequesterId *int `json:"requesterId,omitempty"`

			// ResponseMessage Message to give context surrounding the transfer of the part transfer request.
			ResponseMessage *string `json:"responseMessage"`

			// SourceLocationId ID of the location in the organization from which parts were transferred. (Sending stocks)
			SourceLocationId *int `json:"sourceLocationId,omitempty"`

			// SourceOrganizationId ID of the organization receiving the request. (Sending stocks)
			SourceOrganizationId int `json:"sourceOrganizationId"`

			// SourcePartId ID of the part that belongs to the organization receiving the request. (Sending stocks)
			SourcePartId int `json:"sourcePartId"`

			// Status Status of the part transfer request.
			Status *PatchParttransferrequestsId200PartTransferRequestStatus `json:"status,omitempty"`

			// TransferrerId ID of the user performing the transfer. (Sending stocks)
			TransferrerId *int `json:"transferrerId"`
		} `json:"partTransferRequest"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                             `json:"error"`
			FieldPath  *string                                            `json:"fieldPath"`
			FieldValue *PatchParttransferrequestsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchParttransferrequestsId200PartTransferRequestStatus string
type PatchParttransferrequestsId400ErrorsFieldValue0 = string
type PatchParttransferrequestsId400ErrorsFieldValue1 = float32
type PatchParttransferrequestsId400ErrorsFieldValue2 = bool
type PatchParttransferrequestsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchParttransferrequestsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchParttransferrequestsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProceduretemplaterowsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                               `json:"error"`
			FieldPath  *string                                              `json:"fieldPath"`
			FieldValue *DeleteProceduretemplaterowsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteProceduretemplaterowsId400ErrorsFieldValue0 = string
type DeleteProceduretemplaterowsId400ErrorsFieldValue1 = float32
type DeleteProceduretemplaterowsId400ErrorsFieldValue2 = bool
type DeleteProceduretemplaterowsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteProceduretemplaterowsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProceduretemplaterowsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchProceduretemplaterowsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Row struct {
			AttachmentId *float32 `json:"attachmentId"`

			// Attachments List of attachments linked to the procedure row
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`
			Choices     *[]string `json:"choices"`
			Description *string   `json:"description"`
			Id          float32   `json:"id"`

			// IsDateAndTime Indicate if a DATE field also contains the time
			IsDateAndTime *bool                                  `json:"isDateAndTime"`
			Label         string                                 `json:"label"`
			MeterId       *float32                               `json:"meterId"`
			Type          PatchProceduretemplaterowsId200RowType `json:"type"`
			Urls          *[]struct {
				// Label Label of the url
				Label *string `json:"label,omitempty"`

				// Link Link
				Link string `json:"link"`
			} `json:"urls,omitempty"`
		} `json:"row"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                              `json:"error"`
			FieldPath  *string                                             `json:"fieldPath"`
			FieldValue *PatchProceduretemplaterowsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchProceduretemplaterowsId200RowType string
type PatchProceduretemplaterowsId400ErrorsFieldValue0 = string
type PatchProceduretemplaterowsId400ErrorsFieldValue1 = float32
type PatchProceduretemplaterowsId400ErrorsFieldValue2 = bool
type PatchProceduretemplaterowsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchProceduretemplaterowsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchProceduretemplaterowsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProceduretemplaterowsIdAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteProceduretemplaterowsIdAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProceduretemplaterowsIdAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutProceduretemplaterowsIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *string
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r PutProceduretemplaterowsIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutProceduretemplaterowsIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProceduretemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor The cursor to retrieve the next page of Procedure Templates.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Procedure Templates.
		NextPageUrl        *string `json:"nextPageUrl"`
		ProcedureTemplates []struct {
			// Id Global ID of the procedure template
			Id float32 `json:"id"`

			// Rows (expand with query parameter)
			Rows *[]struct {
				AttachmentId *float32 `json:"attachmentId"`

				// Attachments List of attachments linked to the procedure row
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`
				Choices     *[]string `json:"choices"`
				Description *string   `json:"description"`
				Id          float32   `json:"id"`

				// IsDateAndTime Indicate if a DATE field also contains the time
				IsDateAndTime *bool                                              `json:"isDateAndTime"`
				Label         string                                             `json:"label"`
				MeterId       *float32                                           `json:"meterId"`
				Type          GetProceduretemplates200ProcedureTemplatesRowsType `json:"type"`
				Urls          *[]struct {
					// Label Label of the url
					Label *string `json:"label,omitempty"`

					// Link Link
					Link string `json:"link"`
				} `json:"urls,omitempty"`
			} `json:"rows"`

			// Title Title of the procedure template
			Title string `json:"title"`
		} `json:"procedureTemplates"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}
type GetProceduretemplates200ProcedureTemplatesRowsType string

// Status returns HTTPResponse.Status
func (r GetProceduretemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProceduretemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProceduretemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Fields []struct {
			AttachmentId *float32 `json:"attachmentId"`

			// Attachments List of attachments linked to the procedure row
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`
			Choices     *[]string `json:"choices"`
			Description *string   `json:"description"`
			Id          float32   `json:"id"`

			// IsDateAndTime Indicate if a DATE field also contains the time
			IsDateAndTime *bool                               `json:"isDateAndTime"`
			Label         string                              `json:"label"`
			MeterId       *float32                            `json:"meterId"`
			Type          PostProceduretemplates201FieldsType `json:"type"`
			Urls          *[]struct {
				// Label Label of the url
				Label *string `json:"label,omitempty"`

				// Link Link
				Link string `json:"link"`
			} `json:"urls,omitempty"`
		} `json:"fields"`

		// Id Id of the procedure template
		Id float32 `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                        `json:"error"`
			FieldPath  *string                                       `json:"fieldPath"`
			FieldValue *PostProceduretemplates_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostProceduretemplates201FieldsType string
type PostProceduretemplates400ErrorsFieldValue0 = string
type PostProceduretemplates400ErrorsFieldValue1 = float32
type PostProceduretemplates400ErrorsFieldValue2 = bool
type PostProceduretemplates_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostProceduretemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProceduretemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProceduretemplatesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                            `json:"error"`
			FieldPath  *string                                           `json:"fieldPath"`
			FieldValue *DeleteProceduretemplatesId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteProceduretemplatesId400ErrorsFieldValue0 = string
type DeleteProceduretemplatesId400ErrorsFieldValue1 = float32
type DeleteProceduretemplatesId400ErrorsFieldValue2 = bool
type DeleteProceduretemplatesId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteProceduretemplatesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProceduretemplatesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProceduretemplatesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ProcedureTemplate struct {
			// CreatedAt Date & time at which the procedure template was created
			CreatedAt time.Time `json:"createdAt"`

			// DeletedAt Date & time at which the procedure template was deleted
			DeletedAt *time.Time `json:"deletedAt"`

			// Id Global ID of the procedure template
			Id float32 `json:"id"`

			// Rows (expand with query parameter)
			Rows *[]struct {
				AttachmentId *float32 `json:"attachmentId"`

				// Attachments List of attachments linked to the procedure row
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`
				Choices     *[]string `json:"choices"`
				Description *string   `json:"description"`
				Id          float32   `json:"id"`

				// IsDateAndTime Indicate if a DATE field also contains the time
				IsDateAndTime *bool                                               `json:"isDateAndTime"`
				Label         string                                              `json:"label"`
				MeterId       *float32                                            `json:"meterId"`
				Type          GetProceduretemplatesId200ProcedureTemplateRowsType `json:"type"`
				Urls          *[]struct {
					// Label Label of the url
					Label *string `json:"label,omitempty"`

					// Link Link
					Link string `json:"link"`
				} `json:"urls,omitempty"`
			} `json:"rows"`

			// Title Title of the procedure template
			Title string `json:"title"`

			// UpdatedAt Date & time at which the procedure template was last updated
			UpdatedAt time.Time `json:"updatedAt"`
		} `json:"procedureTemplate"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetProceduretemplatesId200ProcedureTemplateRowsType string

// Status returns HTTPResponse.Status
func (r GetProceduretemplatesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProceduretemplatesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchProceduretemplatesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                           `json:"error"`
			FieldPath  *string                                          `json:"fieldPath"`
			FieldValue *PatchProceduretemplatesId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchProceduretemplatesId400ErrorsFieldValue0 = string
type PatchProceduretemplatesId400ErrorsFieldValue1 = float32
type PatchProceduretemplatesId400ErrorsFieldValue2 = bool
type PatchProceduretemplatesId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchProceduretemplatesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchProceduretemplatesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPurchaseordersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor The cursor to retrieve the next page of Purchase Orders.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Purchase Orders.
		NextPageUrl    *string `json:"nextPageUrl"`
		PurchaseOrders []struct {
			// Id Global ID of the Purchase Order
			Id float32 `json:"id"`

			// Status Status of the Purchase Order. Supported values are APPROVED, CANCELED, COMPLETED, DECLINED, PARTIALLY_FULFILLED, PENDING, REQUESTED
			Status *string `json:"status"`
		} `json:"purchaseOrders"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPurchaseordersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPurchaseordersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPurchaseordersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// ApprovalDate Date the Purchase Order was approved
		ApprovalDate *string `json:"approvalDate"`

		// ApproverId ID of the user who approved the Purchase Order
		ApproverId *float32 `json:"approverId"`

		// Attachments List of attachments linked to the Purchase Order
		Attachments *[]struct {
			// CreatedAt Date & time at which the attachment was uploaded
			CreatedAt time.Time `json:"createdAt"`

			// FileName Attachment's file name
			FileName string `json:"fileName"`

			// Height Height if the file is an image
			Height *float32 `json:"height"`

			// Id Global ID of the attachment
			Id float32 `json:"id"`

			// MimeType MIME type of the file
			MimeType string `json:"mimeType"`

			// Url Url of the file
			Url string `json:"url"`

			// Width Width if the file is an image
			Width *float32 `json:"width"`
		} `json:"attachments,omitempty"`

		// AutoGeneratedNumber Autogenerated Purchase Order number
		AutoGeneratedNumber *float32 `json:"autoGeneratedNumber"`

		// BillingAddress Billing address in the Purchase Order
		BillingAddress *struct {
			City    string `json:"city"`
			Country string `json:"country"`

			// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
			Label      *string `json:"label"`
			PostalCode string  `json:"postalCode"`
			State      string  `json:"state"`
			Street     string  `json:"street"`
		} `json:"billingAddress"`

		// Costs List of costs in the Purchase Order
		Costs *[]struct {
			Amount float32 `json:"amount"`

			// Id ID of the cost
			Id *float32 `json:"id,omitempty"`

			// Name Description of the cost
			Name string `json:"name"`

			// Type Type of cost in either cents or percent. Accepted types in cents are AMOUNT_TAXABLE and AMOUNT_NON_TAXABLE. For percentage use PERCENT_TAXABLE
			Type PostPurchaseorders201CostsType `json:"type"`
		} `json:"costs,omitempty"`

		// CreatorId ID of the user that created this Purchase Order
		CreatorId *float32 `json:"creatorId,omitempty"`

		// DeletedAt Date at which the Purchase Order was deleted
		DeletedAt *time.Time `json:"deletedAt"`

		// DueDate Due date of Purchase Order
		DueDate *string `json:"dueDate"`

		// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
		ExtraFields *map[string]string `json:"extraFields,omitempty"`

		// Id Global ID of the Purchase Order
		Id float32 `json:"id"`

		// Items List of items in the Purchase Order
		Items []struct {
			// ExtraFields Custom Fields on the entity. Deprecated: Use `lineExtraFields` instead.
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Fulfillments Fulfillment information for the item's fulfillment locations.
			Fulfillments *[]struct {
				// Id ID of the item fulfillment
				Id *float32 `json:"id,omitempty"`

				// IsLegacy Indicates the location is a legacy location. This is used to determine if this fulfillment was done before enablement of the multi-location parts feature.
				IsLegacy *bool `json:"isLegacy,omitempty"`

				// LocationId ID of the location where the item was fulfilled
				LocationId *float32 `json:"locationId"`

				// QuantityReceived Quantity of the item fulfilled to this location
				QuantityReceived *string `json:"quantityReceived,omitempty"`
			} `json:"fulfillments,omitempty"`

			// Id ID of the item
			Id float32 `json:"id"`

			// LineExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
			LineExtraFields *map[string]string `json:"lineExtraFields,omitempty"`
			Name            *string            `json:"name"`

			// PartExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
			PartExtraFields *map[string]string `json:"partExtraFields,omitempty"`

			// PartId ID of the part this item is related to
			PartId     *float32 `json:"partId"`
			PartNumber *string  `json:"partNumber"`

			// Price Total price of items in cents
			Price *float32 `json:"price"`

			// QuantityOrdered Represent the amount of units for this item that were ordered in the purchase order.
			QuantityOrdered float32 `json:"quantityOrdered"`

			// QuantityReceived Represents the total amount of this specific item that has been received to date.
			QuantityReceived *float32 `json:"quantityReceived"`

			// UnitCost Price of a single item in cents
			UnitCost *float32 `json:"unitCost"`
		} `json:"items"`

		// Note Notes left for Purchase Orders
		Note *string `json:"note"`

		// OverrideNumber Custom number/identifier for Purchase Order
		OverrideNumber *string `json:"overrideNumber"`

		// ReviewNote Notes to be left for changes to be made when sending a Purchase Order for revision
		ReviewNote *string `json:"reviewNote"`

		// ShippingAddress Shipping address in the Purchase Order
		ShippingAddress *struct {
			City    string `json:"city"`
			Country string `json:"country"`

			// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
			Label      *string `json:"label"`
			PostalCode string  `json:"postalCode"`
			State      string  `json:"state"`
			Street     string  `json:"street"`
		} `json:"shippingAddress"`

		// Status Status of the Purchase Order. Supported values are APPROVED, CANCELED, COMPLETED, DECLINED, PARTIALLY_FULFILLED, PENDING, REQUESTED
		Status    *string `json:"status"`
		Thumbnail *struct {
			// CreatedAt Date & time at which the attachment was uploaded
			CreatedAt time.Time `json:"createdAt"`

			// FileName Attachment's file name
			FileName string `json:"fileName"`

			// Height Height if the file is an image
			Height *float32 `json:"height"`

			// Id Global ID of the attachment
			Id float32 `json:"id"`

			// MimeType MIME type of the file
			MimeType string `json:"mimeType"`

			// Url Url of the file
			Url string `json:"url"`

			// Width Width if the file is an image
			Width *float32 `json:"width"`
		} `json:"thumbnail"`

		// UpdatedAt Date the Purchase Order was last updated
		UpdatedAt *string `json:"updatedAt"`

		// VendorContactIds List of vendor contact IDs in the Purchase Order
		VendorContactIds *[]float32 `json:"vendorContactIds,omitempty"`

		// VendorId ID of vendor that this Purchase Order is associated with
		VendorId *float32 `json:"vendorId"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                    `json:"error"`
			FieldPath  *string                                   `json:"fieldPath"`
			FieldValue *PostPurchaseorders_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                    `json:"error"`
			FieldPath  *string                                   `json:"fieldPath"`
			FieldValue *PostPurchaseorders_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON429 *struct {
		Error string `json:"error"`
	}
}
type PostPurchaseorders201CostsType string
type PostPurchaseorders400ErrorsFieldValue0 = string
type PostPurchaseorders400ErrorsFieldValue1 = float32
type PostPurchaseorders400ErrorsFieldValue2 = bool
type PostPurchaseorders_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PostPurchaseorders403ErrorsFieldValue0 = string
type PostPurchaseorders403ErrorsFieldValue1 = float32
type PostPurchaseorders403ErrorsFieldValue2 = bool
type PostPurchaseorders_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostPurchaseordersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPurchaseordersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePurchaseordersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                        `json:"error"`
			FieldPath  *string                                       `json:"fieldPath"`
			FieldValue *DeletePurchaseordersId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeletePurchaseordersId400ErrorsFieldValue0 = string
type DeletePurchaseordersId400ErrorsFieldValue1 = float32
type DeletePurchaseordersId400ErrorsFieldValue2 = bool
type DeletePurchaseordersId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeletePurchaseordersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePurchaseordersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPurchaseordersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		PurchaseOrder struct {
			// ApprovalDate Date the Purchase Order was approved
			ApprovalDate *string `json:"approvalDate"`

			// ApproverId ID of the user who approved the Purchase Order
			ApproverId *float32 `json:"approverId"`

			// Attachments List of attachments linked to the Purchase Order
			Attachments []struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments"`

			// AutoGeneratedNumber Autogenerated Purchase Order number
			AutoGeneratedNumber *float32 `json:"autoGeneratedNumber"`

			// BillingAddress Billing address in the Purchase Order
			BillingAddress *struct {
				City    string `json:"city"`
				Country string `json:"country"`

				// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
				Label      *string `json:"label"`
				PostalCode string  `json:"postalCode"`
				State      string  `json:"state"`
				Street     string  `json:"street"`
			} `json:"billingAddress"`

			// Costs List of costs in the Purchase Order
			Costs []struct {
				Amount float32 `json:"amount"`

				// Id ID of the cost
				Id *float32 `json:"id,omitempty"`

				// Name Description of the cost
				Name string `json:"name"`

				// Type Type of cost in either cents or percent. Accepted types in cents are AMOUNT_TAXABLE and AMOUNT_NON_TAXABLE. For percentage use PERCENT_TAXABLE
				Type GetPurchaseordersId200PurchaseOrderCostsType `json:"type"`
			} `json:"costs"`

			// CreatorId ID of the user that created this Purchase Order
			CreatorId float32 `json:"creatorId"`

			// DeletedAt Date at which the Purchase Order was deleted
			DeletedAt *time.Time `json:"deletedAt"`

			// DueDate Due date of Purchase Order
			DueDate *string `json:"dueDate"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
			ExtraFields map[string]string `json:"extraFields"`

			// Id Global ID of the Purchase Order
			Id float32 `json:"id"`

			// Items List of items in the Purchase Order
			Items []struct {
				// ExtraFields Custom Fields on the entity. Deprecated: Use `lineExtraFields` instead.
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Fulfillments Fulfillment information for the item's fulfillment locations.
				Fulfillments *[]struct {
					// Id ID of the item fulfillment
					Id *float32 `json:"id,omitempty"`

					// IsLegacy Indicates the location is a legacy location. This is used to determine if this fulfillment was done before enablement of the multi-location parts feature.
					IsLegacy *bool `json:"isLegacy,omitempty"`

					// LocationId ID of the location where the item was fulfilled
					LocationId *float32 `json:"locationId"`

					// QuantityReceived Quantity of the item fulfilled to this location
					QuantityReceived *string `json:"quantityReceived,omitempty"`
				} `json:"fulfillments,omitempty"`

				// Id ID of the item
				Id float32 `json:"id"`

				// LineExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
				LineExtraFields *map[string]string `json:"lineExtraFields,omitempty"`
				Name            *string            `json:"name"`

				// PartExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
				PartExtraFields *map[string]string `json:"partExtraFields,omitempty"`

				// PartId ID of the part this item is related to
				PartId     *float32 `json:"partId"`
				PartNumber *string  `json:"partNumber"`

				// Price Total price of items in cents
				Price *float32 `json:"price"`

				// QuantityOrdered Represent the amount of units for this item that were ordered in the purchase order.
				QuantityOrdered float32 `json:"quantityOrdered"`

				// QuantityReceived Represents the total amount of this specific item that has been received to date.
				QuantityReceived *float32 `json:"quantityReceived"`

				// UnitCost Price of a single item in cents
				UnitCost *float32 `json:"unitCost"`
			} `json:"items"`

			// Note Notes left for Purchase Orders
			Note *string `json:"note"`

			// OverrideNumber Custom number/identifier for Purchase Order
			OverrideNumber *string `json:"overrideNumber"`

			// ReviewNote Notes to be left for changes to be made when sending a Purchase Order for revision
			ReviewNote *string `json:"reviewNote"`

			// ShippingAddress Shipping address in the Purchase Order
			ShippingAddress *struct {
				City    string `json:"city"`
				Country string `json:"country"`

				// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
				Label      *string `json:"label"`
				PostalCode string  `json:"postalCode"`
				State      string  `json:"state"`
				Street     string  `json:"street"`
			} `json:"shippingAddress"`

			// Status Status of the Purchase Order. Supported values are APPROVED, CANCELED, COMPLETED, DECLINED, PARTIALLY_FULFILLED, PENDING, REQUESTED
			Status    *string `json:"status"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`

			// UpdatedAt Date the Purchase Order was last updated
			UpdatedAt *string `json:"updatedAt"`

			// VendorContactIds List of vendor contact IDs in the Purchase Order
			VendorContactIds []float32 `json:"vendorContactIds"`

			// VendorId ID of vendor that this Purchase Order is associated with
			VendorId *float32 `json:"vendorId"`
		} `json:"purchaseOrder"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetPurchaseordersId200PurchaseOrderCostsType string

// Status returns HTTPResponse.Status
func (r GetPurchaseordersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPurchaseordersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPurchaseordersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		PurchaseOrder struct {
			// ApprovalDate Date the Purchase Order was approved
			ApprovalDate *string `json:"approvalDate"`

			// ApproverId ID of the user who approved the Purchase Order
			ApproverId *float32 `json:"approverId"`

			// Attachments List of attachments linked to the Purchase Order
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// AutoGeneratedNumber Autogenerated Purchase Order number
			AutoGeneratedNumber *float32 `json:"autoGeneratedNumber"`

			// BillingAddress Billing address in the Purchase Order
			BillingAddress *struct {
				City    string `json:"city"`
				Country string `json:"country"`

				// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
				Label      *string `json:"label"`
				PostalCode string  `json:"postalCode"`
				State      string  `json:"state"`
				Street     string  `json:"street"`
			} `json:"billingAddress"`

			// Costs List of costs in the Purchase Order
			Costs *[]struct {
				Amount float32 `json:"amount"`

				// Id ID of the cost
				Id *float32 `json:"id,omitempty"`

				// Name Description of the cost
				Name string `json:"name"`

				// Type Type of cost in either cents or percent. Accepted types in cents are AMOUNT_TAXABLE and AMOUNT_NON_TAXABLE. For percentage use PERCENT_TAXABLE
				Type PatchPurchaseordersId200PurchaseOrderCostsType `json:"type"`
			} `json:"costs,omitempty"`

			// CreatorId ID of the user that created this Purchase Order
			CreatorId *float32 `json:"creatorId,omitempty"`

			// DeletedAt Date at which the Purchase Order was deleted
			DeletedAt *time.Time `json:"deletedAt"`

			// DueDate Due date of Purchase Order
			DueDate *string `json:"dueDate"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the Purchase Order
			Id float32 `json:"id"`

			// Items List of items in the Purchase Order
			Items []struct {
				// ExtraFields Custom Fields on the entity. Deprecated: Use `lineExtraFields` instead.
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Fulfillments Fulfillment information for the item's fulfillment locations.
				Fulfillments *[]struct {
					// Id ID of the item fulfillment
					Id *float32 `json:"id,omitempty"`

					// IsLegacy Indicates the location is a legacy location. This is used to determine if this fulfillment was done before enablement of the multi-location parts feature.
					IsLegacy *bool `json:"isLegacy,omitempty"`

					// LocationId ID of the location where the item was fulfilled
					LocationId *float32 `json:"locationId"`

					// QuantityReceived Quantity of the item fulfilled to this location
					QuantityReceived *string `json:"quantityReceived,omitempty"`
				} `json:"fulfillments,omitempty"`

				// Id ID of the item
				Id float32 `json:"id"`

				// LineExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
				LineExtraFields *map[string]string `json:"lineExtraFields,omitempty"`
				Name            *string            `json:"name"`

				// PartExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
				PartExtraFields *map[string]string `json:"partExtraFields,omitempty"`

				// PartId ID of the part this item is related to
				PartId     *float32 `json:"partId"`
				PartNumber *string  `json:"partNumber"`

				// Price Total price of items in cents
				Price *float32 `json:"price"`

				// QuantityOrdered Represent the amount of units for this item that were ordered in the purchase order.
				QuantityOrdered float32 `json:"quantityOrdered"`

				// QuantityReceived Represents the total amount of this specific item that has been received to date.
				QuantityReceived *float32 `json:"quantityReceived"`

				// UnitCost Price of a single item in cents
				UnitCost *float32 `json:"unitCost"`
			} `json:"items"`

			// Note Notes left for Purchase Orders
			Note *string `json:"note"`

			// OverrideNumber Custom number/identifier for Purchase Order
			OverrideNumber *string `json:"overrideNumber"`

			// ReviewNote Notes to be left for changes to be made when sending a Purchase Order for revision
			ReviewNote *string `json:"reviewNote"`

			// ShippingAddress Shipping address in the Purchase Order
			ShippingAddress *struct {
				City    string `json:"city"`
				Country string `json:"country"`

				// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
				Label      *string `json:"label"`
				PostalCode string  `json:"postalCode"`
				State      string  `json:"state"`
				Street     string  `json:"street"`
			} `json:"shippingAddress"`

			// Status Status of the Purchase Order. Supported values are APPROVED, CANCELED, COMPLETED, DECLINED, PARTIALLY_FULFILLED, PENDING, REQUESTED
			Status    *string `json:"status"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`

			// UpdatedAt Date the Purchase Order was last updated
			UpdatedAt *string `json:"updatedAt"`

			// VendorContactIds List of vendor contact IDs in the Purchase Order
			VendorContactIds *[]float32 `json:"vendorContactIds,omitempty"`

			// VendorId ID of vendor that this Purchase Order is associated with
			VendorId *float32 `json:"vendorId"`
		} `json:"purchaseOrder"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                       `json:"error"`
			FieldPath  *string                                      `json:"fieldPath"`
			FieldValue *PatchPurchaseordersId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                       `json:"error"`
			FieldPath  *string                                      `json:"fieldPath"`
			FieldValue *PatchPurchaseordersId_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchPurchaseordersId200PurchaseOrderCostsType string
type PatchPurchaseordersId400ErrorsFieldValue0 = string
type PatchPurchaseordersId400ErrorsFieldValue1 = float32
type PatchPurchaseordersId400ErrorsFieldValue2 = bool
type PatchPurchaseordersId_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PatchPurchaseordersId403ErrorsFieldValue0 = string
type PatchPurchaseordersId403ErrorsFieldValue1 = float32
type PatchPurchaseordersId403ErrorsFieldValue2 = bool
type PatchPurchaseordersId_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchPurchaseordersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPurchaseordersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePurchaseordersIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePurchaseordersIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePurchaseordersIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutPurchaseordersIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *string
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r PutPurchaseordersIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutPurchaseordersIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPurchaseordersIdCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the comment
		Id float32 `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                              `json:"error"`
			FieldPath  *string                                             `json:"fieldPath"`
			FieldValue *PostPurchaseordersIdComments_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PostPurchaseordersIdComments400ErrorsFieldValue0 = string
type PostPurchaseordersIdComments400ErrorsFieldValue1 = float32
type PostPurchaseordersIdComments400ErrorsFieldValue2 = bool
type PostPurchaseordersIdComments_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostPurchaseordersIdCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPurchaseordersIdCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPurchaseordersIdEmailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the Purchase Order
		Id *int `json:"id,omitempty"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                            `json:"error"`
			FieldPath  *string                                           `json:"fieldPath"`
			FieldValue *PostPurchaseordersIdEmails_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                            `json:"error"`
			FieldPath  *string                                           `json:"fieldPath"`
			FieldValue *PostPurchaseordersIdEmails_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PostPurchaseordersIdEmails400ErrorsFieldValue0 = string
type PostPurchaseordersIdEmails400ErrorsFieldValue1 = float32
type PostPurchaseordersIdEmails400ErrorsFieldValue2 = bool
type PostPurchaseordersIdEmails_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PostPurchaseordersIdEmails403ErrorsFieldValue0 = string
type PostPurchaseordersIdEmails403ErrorsFieldValue1 = float32
type PostPurchaseordersIdEmails403ErrorsFieldValue2 = bool
type PostPurchaseordersIdEmails_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostPurchaseordersIdEmailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPurchaseordersIdEmailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPurchaseordersIdFulfillmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		PurchaseOrder struct {
			// ApprovalDate Date the Purchase Order was approved
			ApprovalDate *string `json:"approvalDate"`

			// ApproverId ID of the user who approved the Purchase Order
			ApproverId *float32 `json:"approverId"`

			// Attachments List of attachments linked to the Purchase Order
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// AutoGeneratedNumber Autogenerated Purchase Order number
			AutoGeneratedNumber *float32 `json:"autoGeneratedNumber"`

			// BillingAddress Billing address in the Purchase Order
			BillingAddress *struct {
				City    string `json:"city"`
				Country string `json:"country"`

				// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
				Label      *string `json:"label"`
				PostalCode string  `json:"postalCode"`
				State      string  `json:"state"`
				Street     string  `json:"street"`
			} `json:"billingAddress"`

			// Costs List of costs in the Purchase Order
			Costs *[]struct {
				Amount float32 `json:"amount"`

				// Id ID of the cost
				Id *float32 `json:"id,omitempty"`

				// Name Description of the cost
				Name string `json:"name"`

				// Type Type of cost in either cents or percent. Accepted types in cents are AMOUNT_TAXABLE and AMOUNT_NON_TAXABLE. For percentage use PERCENT_TAXABLE
				Type PatchPurchaseordersIdFulfillment200PurchaseOrderCostsType `json:"type"`
			} `json:"costs,omitempty"`

			// CreatorId ID of the user that created this Purchase Order
			CreatorId *float32 `json:"creatorId,omitempty"`

			// DeletedAt Date at which the Purchase Order was deleted
			DeletedAt *time.Time `json:"deletedAt"`

			// DueDate Due date of Purchase Order
			DueDate *string `json:"dueDate"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the Purchase Order
			Id float32 `json:"id"`

			// Items List of items in the Purchase Order
			Items []struct {
				// ExtraFields Custom Fields on the entity. Deprecated: Use `lineExtraFields` instead.
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Fulfillments Fulfillment information for the item's fulfillment locations.
				Fulfillments *[]struct {
					// Id ID of the item fulfillment
					Id *float32 `json:"id,omitempty"`

					// IsLegacy Indicates the location is a legacy location. This is used to determine if this fulfillment was done before enablement of the multi-location parts feature.
					IsLegacy *bool `json:"isLegacy,omitempty"`

					// LocationId ID of the location where the item was fulfilled
					LocationId *float32 `json:"locationId"`

					// QuantityReceived Quantity of the item fulfilled to this location
					QuantityReceived *string `json:"quantityReceived,omitempty"`
				} `json:"fulfillments,omitempty"`

				// Id ID of the item
				Id float32 `json:"id"`

				// LineExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
				LineExtraFields *map[string]string `json:"lineExtraFields,omitempty"`
				Name            *string            `json:"name"`

				// PartExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
				PartExtraFields *map[string]string `json:"partExtraFields,omitempty"`

				// PartId ID of the part this item is related to
				PartId     *float32 `json:"partId"`
				PartNumber *string  `json:"partNumber"`

				// Price Total price of items in cents
				Price *float32 `json:"price"`

				// QuantityOrdered Represent the amount of units for this item that were ordered in the purchase order.
				QuantityOrdered float32 `json:"quantityOrdered"`

				// QuantityReceived Represents the total amount of this specific item that has been received to date.
				QuantityReceived *float32 `json:"quantityReceived"`

				// UnitCost Price of a single item in cents
				UnitCost *float32 `json:"unitCost"`
			} `json:"items"`

			// Note Notes left for Purchase Orders
			Note *string `json:"note"`

			// OverrideNumber Custom number/identifier for Purchase Order
			OverrideNumber *string `json:"overrideNumber"`

			// ReviewNote Notes to be left for changes to be made when sending a Purchase Order for revision
			ReviewNote *string `json:"reviewNote"`

			// ShippingAddress Shipping address in the Purchase Order
			ShippingAddress *struct {
				City    string `json:"city"`
				Country string `json:"country"`

				// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
				Label      *string `json:"label"`
				PostalCode string  `json:"postalCode"`
				State      string  `json:"state"`
				Street     string  `json:"street"`
			} `json:"shippingAddress"`

			// Status Status of the Purchase Order. Supported values are APPROVED, CANCELED, COMPLETED, DECLINED, PARTIALLY_FULFILLED, PENDING, REQUESTED
			Status    *string `json:"status"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`

			// UpdatedAt Date the Purchase Order was last updated
			UpdatedAt *string `json:"updatedAt"`

			// VendorContactIds List of vendor contact IDs in the Purchase Order
			VendorContactIds *[]float32 `json:"vendorContactIds,omitempty"`

			// VendorId ID of vendor that this Purchase Order is associated with
			VendorId *float32 `json:"vendorId"`
		} `json:"purchaseOrder"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                                  `json:"error"`
			FieldPath  *string                                                 `json:"fieldPath"`
			FieldValue *PatchPurchaseordersIdFulfillment_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                                  `json:"error"`
			FieldPath  *string                                                 `json:"fieldPath"`
			FieldValue *PatchPurchaseordersIdFulfillment_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchPurchaseordersIdFulfillment200PurchaseOrderCostsType string
type PatchPurchaseordersIdFulfillment400ErrorsFieldValue0 = string
type PatchPurchaseordersIdFulfillment400ErrorsFieldValue1 = float32
type PatchPurchaseordersIdFulfillment400ErrorsFieldValue2 = bool
type PatchPurchaseordersIdFulfillment_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PatchPurchaseordersIdFulfillment403ErrorsFieldValue0 = string
type PatchPurchaseordersIdFulfillment403ErrorsFieldValue1 = float32
type PatchPurchaseordersIdFulfillment403ErrorsFieldValue2 = bool
type PatchPurchaseordersIdFulfillment_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchPurchaseordersIdFulfillmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPurchaseordersIdFulfillmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPurchaseordersIdStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		PurchaseOrder struct {
			// ApprovalDate Date the Purchase Order was approved
			ApprovalDate *string `json:"approvalDate"`

			// ApproverId ID of the user who approved the Purchase Order
			ApproverId *float32 `json:"approverId"`

			// Attachments List of attachments linked to the Purchase Order
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// AutoGeneratedNumber Autogenerated Purchase Order number
			AutoGeneratedNumber *float32 `json:"autoGeneratedNumber"`

			// BillingAddress Billing address in the Purchase Order
			BillingAddress *struct {
				City    string `json:"city"`
				Country string `json:"country"`

				// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
				Label      *string `json:"label"`
				PostalCode string  `json:"postalCode"`
				State      string  `json:"state"`
				Street     string  `json:"street"`
			} `json:"billingAddress"`

			// Costs List of costs in the Purchase Order
			Costs *[]struct {
				Amount float32 `json:"amount"`

				// Id ID of the cost
				Id *float32 `json:"id,omitempty"`

				// Name Description of the cost
				Name string `json:"name"`

				// Type Type of cost in either cents or percent. Accepted types in cents are AMOUNT_TAXABLE and AMOUNT_NON_TAXABLE. For percentage use PERCENT_TAXABLE
				Type PatchPurchaseordersIdStatus200PurchaseOrderCostsType `json:"type"`
			} `json:"costs,omitempty"`

			// CreatorId ID of the user that created this Purchase Order
			CreatorId *float32 `json:"creatorId,omitempty"`

			// DeletedAt Date at which the Purchase Order was deleted
			DeletedAt *time.Time `json:"deletedAt"`

			// DueDate Due date of Purchase Order
			DueDate *string `json:"dueDate"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the Purchase Order
			Id float32 `json:"id"`

			// Items List of items in the Purchase Order
			Items []struct {
				// ExtraFields Custom Fields on the entity. Deprecated: Use `lineExtraFields` instead.
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Fulfillments Fulfillment information for the item's fulfillment locations.
				Fulfillments *[]struct {
					// Id ID of the item fulfillment
					Id *float32 `json:"id,omitempty"`

					// IsLegacy Indicates the location is a legacy location. This is used to determine if this fulfillment was done before enablement of the multi-location parts feature.
					IsLegacy *bool `json:"isLegacy,omitempty"`

					// LocationId ID of the location where the item was fulfilled
					LocationId *float32 `json:"locationId"`

					// QuantityReceived Quantity of the item fulfilled to this location
					QuantityReceived *string `json:"quantityReceived,omitempty"`
				} `json:"fulfillments,omitempty"`

				// Id ID of the item
				Id float32 `json:"id"`

				// LineExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
				LineExtraFields *map[string]string `json:"lineExtraFields,omitempty"`
				Name            *string            `json:"name"`

				// PartExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
				PartExtraFields *map[string]string `json:"partExtraFields,omitempty"`

				// PartId ID of the part this item is related to
				PartId     *float32 `json:"partId"`
				PartNumber *string  `json:"partNumber"`

				// Price Total price of items in cents
				Price *float32 `json:"price"`

				// QuantityOrdered Represent the amount of units for this item that were ordered in the purchase order.
				QuantityOrdered float32 `json:"quantityOrdered"`

				// QuantityReceived Represents the total amount of this specific item that has been received to date.
				QuantityReceived *float32 `json:"quantityReceived"`

				// UnitCost Price of a single item in cents
				UnitCost *float32 `json:"unitCost"`
			} `json:"items"`

			// Note Notes left for Purchase Orders
			Note *string `json:"note"`

			// OverrideNumber Custom number/identifier for Purchase Order
			OverrideNumber *string `json:"overrideNumber"`

			// ReviewNote Notes to be left for changes to be made when sending a Purchase Order for revision
			ReviewNote *string `json:"reviewNote"`

			// ShippingAddress Shipping address in the Purchase Order
			ShippingAddress *struct {
				City    string `json:"city"`
				Country string `json:"country"`

				// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
				Label      *string `json:"label"`
				PostalCode string  `json:"postalCode"`
				State      string  `json:"state"`
				Street     string  `json:"street"`
			} `json:"shippingAddress"`

			// Status Status of the Purchase Order. Supported values are APPROVED, CANCELED, COMPLETED, DECLINED, PARTIALLY_FULFILLED, PENDING, REQUESTED
			Status    *string `json:"status"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`

			// UpdatedAt Date the Purchase Order was last updated
			UpdatedAt *string `json:"updatedAt"`

			// VendorContactIds List of vendor contact IDs in the Purchase Order
			VendorContactIds *[]float32 `json:"vendorContactIds,omitempty"`

			// VendorId ID of vendor that this Purchase Order is associated with
			VendorId *float32 `json:"vendorId"`
		} `json:"purchaseOrder"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                             `json:"error"`
			FieldPath  *string                                            `json:"fieldPath"`
			FieldValue *PatchPurchaseordersIdStatus_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                             `json:"error"`
			FieldPath  *string                                            `json:"fieldPath"`
			FieldValue *PatchPurchaseordersIdStatus_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchPurchaseordersIdStatus200PurchaseOrderCostsType string
type PatchPurchaseordersIdStatus400ErrorsFieldValue0 = string
type PatchPurchaseordersIdStatus400ErrorsFieldValue1 = float32
type PatchPurchaseordersIdStatus400ErrorsFieldValue2 = bool
type PatchPurchaseordersIdStatus_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PatchPurchaseordersIdStatus403ErrorsFieldValue0 = string
type PatchPurchaseordersIdStatus403ErrorsFieldValue1 = float32
type PatchPurchaseordersIdStatus403ErrorsFieldValue2 = bool
type PatchPurchaseordersIdStatus_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchPurchaseordersIdStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPurchaseordersIdStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutPurchaseordersIdThumbnailFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                                      `json:"error"`
			FieldPath  *string                                                     `json:"fieldPath"`
			FieldValue *PutPurchaseordersIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}
type PutPurchaseordersIdThumbnailFilename400ErrorsFieldValue0 = string
type PutPurchaseordersIdThumbnailFilename400ErrorsFieldValue1 = float32
type PutPurchaseordersIdThumbnailFilename400ErrorsFieldValue2 = bool
type PutPurchaseordersIdThumbnailFilename_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PutPurchaseordersIdThumbnailFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutPurchaseordersIdThumbnailFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the subscription
		Id int `json:"id"`

		// Secret Secret to hash the Hmac signature
		Secret *string `json:"secret,omitempty"`

		// Status Validation status of the subscription. Contact support if your subscription returns PENDING_APPROVAL before using the subscription.
		Status PostSubscriptions201Status `json:"status"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                   `json:"error"`
			FieldPath  *string                                  `json:"fieldPath"`
			FieldValue *PostSubscriptions_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                   `json:"error"`
			FieldPath  *string                                  `json:"fieldPath"`
			FieldValue *PostSubscriptions_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostSubscriptions201Status string
type PostSubscriptions400ErrorsFieldValue0 = string
type PostSubscriptions400ErrorsFieldValue1 = float32
type PostSubscriptions400ErrorsFieldValue2 = bool
type PostSubscriptions_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PostSubscriptions403ErrorsFieldValue0 = string
type PostSubscriptions403ErrorsFieldValue1 = float32
type PostSubscriptions403ErrorsFieldValue2 = bool
type PostSubscriptions_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscriptionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                       `json:"error"`
			FieldPath  *string                                      `json:"fieldPath"`
			FieldValue *DeleteSubscriptionsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                       `json:"error"`
			FieldPath  *string                                      `json:"fieldPath"`
			FieldValue *DeleteSubscriptionsId_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteSubscriptionsId400ErrorsFieldValue0 = string
type DeleteSubscriptionsId400ErrorsFieldValue1 = float32
type DeleteSubscriptionsId400ErrorsFieldValue2 = bool
type DeleteSubscriptionsId_400_Errors_FieldValue struct {
	union json.RawMessage
}
type DeleteSubscriptionsId403ErrorsFieldValue0 = string
type DeleteSubscriptionsId403ErrorsFieldValue1 = float32
type DeleteSubscriptionsId403ErrorsFieldValue2 = bool
type DeleteSubscriptionsId_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteSubscriptionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscriptionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Subscription struct {
			// Id Global ID of the subscription
			Id int `json:"id"`

			// Status Validation status of the subscription. Contact support if your subscription returns PENDING_APPROVAL before using the subscription.
			Status GetSubscriptionsId200SubscriptionStatus `json:"status"`

			// Type Type of event subscribed to
			Type GetSubscriptionsId200SubscriptionType `json:"type"`
			Url  string                                `json:"url"`
		} `json:"subscription"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetSubscriptionsId200SubscriptionStatus string
type GetSubscriptionsId200SubscriptionType string

// Status returns HTTPResponse.Status
func (r GetSubscriptionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSubscriptionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Subscription struct {
			// Id Global ID of the subscription
			Id int `json:"id"`

			// Status Validation status of the subscription. Contact support if your subscription returns PENDING_APPROVAL before using the subscription.
			Status PatchSubscriptionsId200SubscriptionStatus `json:"status"`

			// Type Type of event subscribed to
			Type PatchSubscriptionsId200SubscriptionType `json:"type"`
			Url  string                                  `json:"url"`
		} `json:"subscription"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                      `json:"error"`
			FieldPath  *string                                     `json:"fieldPath"`
			FieldValue *PatchSubscriptionsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchSubscriptionsId200SubscriptionStatus string
type PatchSubscriptionsId200SubscriptionType string
type PatchSubscriptionsId400ErrorsFieldValue0 = string
type PatchSubscriptionsId400ErrorsFieldValue1 = float32
type PatchSubscriptionsId400ErrorsFieldValue2 = bool
type PatchSubscriptionsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchSubscriptionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSubscriptionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionsIdSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Secret string `json:"secret"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionsIdSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionsIdSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor The cursor to retrieve the next page of Teams.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Teams.
		NextPageUrl *string `json:"nextPageUrl"`
		Teams       []struct {
			// Id Global ID of the team
			Id   int    `json:"id"`
			Name string `json:"name"`
		} `json:"teams"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the team
		Id int `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                           `json:"error"`
			FieldPath  *string                          `json:"fieldPath"`
			FieldValue *PostTeams_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostTeams400ErrorsFieldValue0 = string
type PostTeams400ErrorsFieldValue1 = float32
type PostTeams400ErrorsFieldValue2 = bool
type PostTeams_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                               `json:"error"`
			FieldPath  *string                              `json:"fieldPath"`
			FieldValue *DeleteTeamsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteTeamsId400ErrorsFieldValue0 = string
type DeleteTeamsId400ErrorsFieldValue1 = float32
type DeleteTeamsId400ErrorsFieldValue2 = bool
type DeleteTeamsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteTeamsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Team struct {
			// AssetIds List of asset IDs that the team is responsible for
			AssetIds    *[]int  `json:"assetIds,omitempty"`
			Description *string `json:"description,omitempty"`

			// Id Global ID of the team
			Id int `json:"id"`

			// LocationIds List of location where the team is operating
			LocationIds *[]int `json:"locationIds,omitempty"`

			// MembersCount Number of team members
			MembersCount int    `json:"membersCount"`
			Name         string `json:"name"`
		} `json:"team"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTeamsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchTeamsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Team struct {
			// AssetIds List of asset IDs that the team is responsible for
			AssetIds    *[]int  `json:"assetIds,omitempty"`
			Description *string `json:"description,omitempty"`

			// Id Global ID of the team
			Id int `json:"id"`

			// LocationIds List of location where the team is operating
			LocationIds *[]int `json:"locationIds,omitempty"`

			// MembersCount Number of team members
			MembersCount int    `json:"membersCount"`
			Name         string `json:"name"`
		} `json:"team"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                              `json:"error"`
			FieldPath  *string                             `json:"fieldPath"`
			FieldValue *PatchTeamsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchTeamsId400ErrorsFieldValue0 = string
type PatchTeamsId400ErrorsFieldValue1 = float32
type PatchTeamsId400ErrorsFieldValue2 = bool
type PatchTeamsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchTeamsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchTeamsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsIdMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Members []struct {
			FirstName *string `json:"firstName,omitempty"`

			// Id Global ID of the user
			Id       int                                 `json:"id"`
			LastName *string                             `json:"lastName,omitempty"`
			TeamRole GetTeamsIdMembers200MembersTeamRole `json:"teamRole"`
		} `json:"members"`

		// NextCursor The cursor to retrieve the next page of Members.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Members.
		NextPageUrl *string `json:"nextPageUrl"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}
type GetTeamsIdMembers200MembersTeamRole string

// Status returns HTTPResponse.Status
func (r GetTeamsIdMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsIdMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTeamsIdMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the user
		Id int `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                    `json:"error"`
			FieldPath  *string                                   `json:"fieldPath"`
			FieldValue *PostTeamsIdMembers_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PostTeamsIdMembers400ErrorsFieldValue0 = string
type PostTeamsIdMembers400ErrorsFieldValue1 = float32
type PostTeamsIdMembers400ErrorsFieldValue2 = bool
type PostTeamsIdMembers_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostTeamsIdMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTeamsIdMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamsTeamIdMembersUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                                `json:"error"`
			FieldPath  *string                                               `json:"fieldPath"`
			FieldValue *DeleteTeamsTeamIdMembersUserId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteTeamsTeamIdMembersUserId400ErrorsFieldValue0 = string
type DeleteTeamsTeamIdMembersUserId400ErrorsFieldValue1 = float32
type DeleteTeamsTeamIdMembersUserId400ErrorsFieldValue2 = bool
type DeleteTeamsTeamIdMembersUserId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteTeamsTeamIdMembersUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamsTeamIdMembersUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchTeamsTeamIdMembersUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Member struct {
			FirstName *string `json:"firstName,omitempty"`

			// Id Global ID of the user
			Id       int                                            `json:"id"`
			LastName *string                                        `json:"lastName,omitempty"`
			TeamRole PatchTeamsTeamIdMembersUserId200MemberTeamRole `json:"teamRole"`
		} `json:"member"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                               `json:"error"`
			FieldPath  *string                                              `json:"fieldPath"`
			FieldValue *PatchTeamsTeamIdMembersUserId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchTeamsTeamIdMembersUserId200MemberTeamRole string
type PatchTeamsTeamIdMembersUserId400ErrorsFieldValue0 = string
type PatchTeamsTeamIdMembersUserId400ErrorsFieldValue1 = float32
type PatchTeamsTeamIdMembersUserId400ErrorsFieldValue2 = bool
type PatchTeamsTeamIdMembersUserId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchTeamsTeamIdMembersUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchTeamsTeamIdMembersUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor The cursor to retrieve the next page of Users.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Users.
		NextPageUrl *string `json:"nextPageUrl"`
		Users       []struct {
			AuthType *GetUsers200UsersAuthType `json:"authType"`
			Email    *string                   `json:"email"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Department") (expand with query parameter)
			ExtraFields *map[string]string `json:"extraFields,omitempty"`
			FirstName   string             `json:"firstName"`

			// HourlyRate Cost in cents. For example, for $1.20, the value will be 120. If the hourly rate is not set specifically for the user, the API will return the default organization hourly rate, if that is also not set, it will return the hourly rate that is specifically set for the user in any work order. Otherwise, it would be `undefined`
			HourlyRate *int `json:"hourlyRate"`

			// Id Global ID of the user
			Id          int     `json:"id"`
			LastName    string  `json:"lastName"`
			PhoneNumber *string `json:"phoneNumber"`

			// Role (expand with query parameter)
			Role *GetUsers200UsersRole `json:"role,omitempty"`
		} `json:"users"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}
type GetUsers200UsersAuthType string
type GetUsers200UsersRole string

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the user
		Id int `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                           `json:"error"`
			FieldPath  *string                          `json:"fieldPath"`
			FieldValue *PostUsers_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                           `json:"error"`
			FieldPath  *string                          `json:"fieldPath"`
			FieldValue *PostUsers_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PostUsers400ErrorsFieldValue0 = string
type PostUsers400ErrorsFieldValue1 = float32
type PostUsers400ErrorsFieldValue2 = bool
type PostUsers_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PostUsers403ErrorsFieldValue0 = string
type PostUsers403ErrorsFieldValue1 = float32
type PostUsers403ErrorsFieldValue2 = bool
type PostUsers_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                               `json:"error"`
			FieldPath  *string                              `json:"fieldPath"`
			FieldValue *DeleteUsersId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteUsersId400ErrorsFieldValue0 = string
type DeleteUsersId400ErrorsFieldValue1 = float32
type DeleteUsersId400ErrorsFieldValue2 = bool
type DeleteUsersId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteUsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		User struct {
			AuthType *GetUsersId200UserAuthType `json:"authType"`

			// CustomRole Custom role name if the user has a custom role assigned
			CustomRole *string `json:"customRole"`
			Email      *string `json:"email"`

			// ExternalData Extra data that can be attached to the user, for example to help reference to a matching record in an external system.
			ExternalData *GetUsersId_200_User_ExternalData `json:"externalData"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Department")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`
			FirstName   string             `json:"firstName"`

			// HourlyRate Cost in cents. For example, for $1.20, the value will be 120. If the hourly rate is not set specifically for the user, the API will return the default organization hourly rate, if that is also not set, it will return the hourly rate that is specifically set for the user in any work order. Otherwise, it would be `undefined`
			HourlyRate *int `json:"hourlyRate"`

			// Id Global ID of the user
			Id                      int                    `json:"id"`
			LastName                string                 `json:"lastName"`
			PhoneNumber             *string                `json:"phoneNumber"`
			RemovedFromOrganization *bool                  `json:"removedFromOrganization,omitempty"`
			Role                    *GetUsersId200UserRole `json:"role"`
		} `json:"user"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetUsersId200UserAuthType string
type GetUsersId200UserExternalData0 = map[string]interface{}
type GetUsersId200UserExternalData1 = float32
type GetUsersId200UserExternalData2 = string
type GetUsersId_200_User_ExternalData struct {
	union json.RawMessage
}
type GetUsersId200UserRole string

// Status returns HTTPResponse.Status
func (r GetUsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		User struct {
			AuthType *PatchUsersId200UserAuthType `json:"authType"`

			// CustomRole Custom role name if the user has a custom role assigned
			CustomRole *string `json:"customRole"`
			Email      *string `json:"email"`

			// ExternalData Extra data that can be attached to the user, for example to help reference to a matching record in an external system.
			ExternalData *PatchUsersId_200_User_ExternalData `json:"externalData"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Department")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`
			FirstName   *string            `json:"firstName,omitempty"`

			// HourlyRate Cost in cents. For example, for $1.20, the value will be 120. If the hourly rate is not set specifically for the user, the API will return the default organization hourly rate, if that is also not set, it will return the hourly rate that is specifically set for the user in any work order. Otherwise, it would be `undefined`
			HourlyRate *int `json:"hourlyRate"`

			// Id Global ID of the user
			Id                      int                      `json:"id"`
			LastName                *string                  `json:"lastName,omitempty"`
			PhoneNumber             *string                  `json:"phoneNumber"`
			RemovedFromOrganization *bool                    `json:"removedFromOrganization,omitempty"`
			Role                    *PatchUsersId200UserRole `json:"role"`
		} `json:"user"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                              `json:"error"`
			FieldPath  *string                             `json:"fieldPath"`
			FieldValue *PatchUsersId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                              `json:"error"`
			FieldPath  *string                             `json:"fieldPath"`
			FieldValue *PatchUsersId_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchUsersId200UserAuthType string
type PatchUsersId200UserExternalData0 = map[string]interface{}
type PatchUsersId200UserExternalData1 = float32
type PatchUsersId200UserExternalData2 = string
type PatchUsersId_200_User_ExternalData struct {
	union json.RawMessage
}
type PatchUsersId200UserRole string
type PatchUsersId400ErrorsFieldValue0 = string
type PatchUsersId400ErrorsFieldValue1 = float32
type PatchUsersId400ErrorsFieldValue2 = bool
type PatchUsersId_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PatchUsersId403ErrorsFieldValue0 = string
type PatchUsersId403ErrorsFieldValue1 = float32
type PatchUsersId403ErrorsFieldValue2 = bool
type PatchUsersId_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchUsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUsersIdMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// ConversationId ID of the conversation
		ConversationId float32 `json:"conversationId"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                     `json:"error"`
			FieldPath  *string                                    `json:"fieldPath"`
			FieldValue *PostUsersIdMessages_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                     `json:"error"`
			FieldPath  *string                                    `json:"fieldPath"`
			FieldValue *PostUsersIdMessages_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PostUsersIdMessages400ErrorsFieldValue0 = string
type PostUsersIdMessages400ErrorsFieldValue1 = float32
type PostUsersIdMessages400ErrorsFieldValue2 = bool
type PostUsersIdMessages_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PostUsersIdMessages403ErrorsFieldValue0 = string
type PostUsersIdMessages403ErrorsFieldValue1 = float32
type PostUsersIdMessages403ErrorsFieldValue2 = bool
type PostUsersIdMessages_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostUsersIdMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUsersIdMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVendorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor The cursor to retrieve the next page of Vendors.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Vendors.
		NextPageUrl *string `json:"nextPageUrl"`
		Vendors     []struct {
			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Qualifications") (expand with query parameter)
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the vendor
			Id   int    `json:"id"`
			Name string `json:"name"`
		} `json:"vendors"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetVendorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVendorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVendorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the vendor
		Id int `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                             `json:"error"`
			FieldPath  *string                            `json:"fieldPath"`
			FieldValue *PostVendors_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostVendors400ErrorsFieldValue0 = string
type PostVendors400ErrorsFieldValue1 = float32
type PostVendors400ErrorsFieldValue2 = bool
type PostVendors_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostVendorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVendorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVendorsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                 `json:"error"`
			FieldPath  *string                                `json:"fieldPath"`
			FieldValue *DeleteVendorsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteVendorsId400ErrorsFieldValue0 = string
type DeleteVendorsId400ErrorsFieldValue1 = float32
type DeleteVendorsId400ErrorsFieldValue2 = bool
type DeleteVendorsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteVendorsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVendorsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVendorsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Vendor struct {
			// Attachments List of attachments linked to the vendor
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// ContactIds List of contact IDs
			ContactIds *[]int `json:"contactIds,omitempty"`

			// DeletedAt Date that the vendor was deleted
			DeletedAt   *time.Time `json:"deletedAt"`
			Description *string    `json:"description"`

			// Emails List of email address
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			Emails *[]string `json:"emails,omitempty"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Qualifications")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the vendor
			Id   int    `json:"id"`
			Name string `json:"name"`

			// PhoneNumbers List of phone number
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			PhoneNumbers *[]string `json:"phoneNumbers,omitempty"`
			Thumbnail    *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`
		} `json:"vendor"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetVendorsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVendorsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchVendorsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Vendor struct {
			// Attachments List of attachments linked to the vendor
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// ContactIds List of contact IDs
			ContactIds *[]int `json:"contactIds,omitempty"`

			// DeletedAt Date that the vendor was deleted
			DeletedAt   *time.Time `json:"deletedAt"`
			Description *string    `json:"description"`

			// Emails List of email address
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			Emails *[]string `json:"emails,omitempty"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Qualifications")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the vendor
			Id   int    `json:"id"`
			Name string `json:"name"`

			// PhoneNumbers List of phone number
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			PhoneNumbers *[]string `json:"phoneNumbers,omitempty"`
			Thumbnail    *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`
		} `json:"vendor"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                `json:"error"`
			FieldPath  *string                               `json:"fieldPath"`
			FieldValue *PatchVendorsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchVendorsId400ErrorsFieldValue0 = string
type PatchVendorsId400ErrorsFieldValue1 = float32
type PatchVendorsId400ErrorsFieldValue2 = bool
type PatchVendorsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchVendorsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchVendorsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVendorsIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteVendorsIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVendorsIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutVendorsIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *string
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r PutVendorsIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutVendorsIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVendorsIdContactsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Contacts []struct {
			// Email Email address of contact.
			Email *string `json:"email"`

			// Extension Phone number extension
			Extension *string `json:"extension"`

			// Id Global ID of the contact
			Id   float32 `json:"id"`
			Name string  `json:"name"`

			// PhoneNumber Phone number of contact
			PhoneNumber *string `json:"phoneNumber"`

			// Role Role/Label of the contact.
			Role *string `json:"role"`

			// VendorId ID of vendor that contact will be associated to
			VendorId float32 `json:"vendorId"`
		} `json:"contacts"`

		// NextCursor The cursor to retrieve the next page of Contacts.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Contacts.
		NextPageUrl *string `json:"nextPageUrl"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetVendorsIdContactsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVendorsIdContactsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVendorsIdContactsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Email Email address of contact.
		Email *string `json:"email"`

		// Extension Phone number extension
		Extension *string `json:"extension"`

		// Id Global ID of the contact
		Id   float32 `json:"id"`
		Name string  `json:"name"`

		// PhoneNumber Phone number of contact
		PhoneNumber *string `json:"phoneNumber"`

		// Role Role/Label of the contact.
		Role *string `json:"role"`

		// VendorId ID of vendor that contact will be associated to
		VendorId float32 `json:"vendorId"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                       `json:"error"`
			FieldPath  *string                                      `json:"fieldPath"`
			FieldValue *PostVendorsIdContacts_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON429 *struct {
		Error string `json:"error"`
	}
}
type PostVendorsIdContacts400ErrorsFieldValue0 = string
type PostVendorsIdContacts400ErrorsFieldValue1 = float32
type PostVendorsIdContacts400ErrorsFieldValue2 = bool
type PostVendorsIdContacts_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostVendorsIdContactsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVendorsIdContactsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVendorsIdContactsContactIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                                  `json:"error"`
			FieldPath  *string                                                 `json:"fieldPath"`
			FieldValue *DeleteVendorsIdContactsContactId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteVendorsIdContactsContactId400ErrorsFieldValue0 = string
type DeleteVendorsIdContactsContactId400ErrorsFieldValue1 = float32
type DeleteVendorsIdContactsContactId400ErrorsFieldValue2 = bool
type DeleteVendorsIdContactsContactId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteVendorsIdContactsContactIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVendorsIdContactsContactIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVendorsIdContactsContactIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		VendorContact struct {
			// Email Email address of contact.
			Email *string `json:"email"`

			// Extension Phone number extension
			Extension *string `json:"extension"`

			// Id Global ID of the contact
			Id   float32 `json:"id"`
			Name string  `json:"name"`

			// PhoneNumber Phone number of contact
			PhoneNumber *string `json:"phoneNumber"`

			// Role Role/Label of the contact.
			Role *string `json:"role"`

			// VendorId ID of vendor that contact will be associated to
			VendorId float32 `json:"vendorId"`
		} `json:"vendorContact"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                               `json:"error"`
			FieldPath  *string                                              `json:"fieldPath"`
			FieldValue *GetVendorsIdContactsContactId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetVendorsIdContactsContactId400ErrorsFieldValue0 = string
type GetVendorsIdContactsContactId400ErrorsFieldValue1 = float32
type GetVendorsIdContactsContactId400ErrorsFieldValue2 = bool
type GetVendorsIdContactsContactId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r GetVendorsIdContactsContactIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVendorsIdContactsContactIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchVendorsIdContactsContactIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Contact struct {
			// Email Email address of contact.
			Email *string `json:"email"`

			// Extension Phone number extension
			Extension *string `json:"extension"`

			// Id Global ID of the contact
			Id   float32 `json:"id"`
			Name string  `json:"name"`

			// PhoneNumber Phone number of contact
			PhoneNumber *string `json:"phoneNumber"`

			// Role Role/Label of the contact.
			Role *string `json:"role"`

			// VendorId ID of vendor that contact will be associated to
			VendorId float32 `json:"vendorId"`
		} `json:"contact"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                                 `json:"error"`
			FieldPath  *string                                                `json:"fieldPath"`
			FieldValue *PatchVendorsIdContactsContactId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchVendorsIdContactsContactId400ErrorsFieldValue0 = string
type PatchVendorsIdContactsContactId400ErrorsFieldValue1 = float32
type PatchVendorsIdContactsContactId400ErrorsFieldValue2 = bool
type PatchVendorsIdContactsContactId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchVendorsIdContactsContactIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchVendorsIdContactsContactIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutVendorsIdThumbnailFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                               `json:"error"`
			FieldPath  *string                                              `json:"fieldPath"`
			FieldValue *PutVendorsIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}
type PutVendorsIdThumbnailFilename400ErrorsFieldValue0 = string
type PutVendorsIdThumbnailFilename400ErrorsFieldValue1 = float32
type PutVendorsIdThumbnailFilename400ErrorsFieldValue2 = bool
type PutVendorsIdThumbnailFilename_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PutVendorsIdThumbnailFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutVendorsIdThumbnailFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Version string `json:"version"`
	}
}

// Status returns HTTPResponse.Status
func (r GetVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWorkPermitsIdSignResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Success   bool `json:"success"`
		WorkOrder struct {
			BlockedByWorkPermitReason *string `json:"blockedByWorkPermitReason"`
			Id                        int     `json:"id"`
		} `json:"workOrder"`
		WorkPermit struct {
			Id     int    `json:"id"`
			Status string `json:"status"`
		} `json:"workPermit"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                       `json:"error"`
			FieldPath  *string                                      `json:"fieldPath"`
			FieldValue *PostWorkPermitsIdSign_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                       `json:"error"`
			FieldPath  *string                                      `json:"fieldPath"`
			FieldValue *PostWorkPermitsIdSign_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostWorkPermitsIdSign400ErrorsFieldValue0 = string
type PostWorkPermitsIdSign400ErrorsFieldValue1 = float32
type PostWorkPermitsIdSign400ErrorsFieldValue2 = bool
type PostWorkPermitsIdSign_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PostWorkPermitsIdSign403ErrorsFieldValue0 = string
type PostWorkPermitsIdSign403ErrorsFieldValue1 = float32
type PostWorkPermitsIdSign403ErrorsFieldValue2 = bool
type PostWorkPermitsIdSign_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostWorkPermitsIdSignResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWorkPermitsIdSignResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkordersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor The cursor to retrieve the next page of Work Orders.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Work Orders.
		NextPageUrl *string `json:"nextPageUrl"`
		WorkOrders  []struct {
			// Asset Asset linked to the element (expand with query parameter)
			Asset *struct {
				// CreatedAt Date & time at which the asset was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId ID of the asset creator
				CreatorId *int `json:"creatorId"`

				// CriticalityId ID of the criticality of the asset
				CriticalityId *int    `json:"criticalityId"`
				Description   *string `json:"description"`

				// Id Global ID of the asset
				Id int `json:"id"`

				// LocationId ID of the location where the asset is located
				LocationId *int   `json:"locationId"`
				Name       string `json:"name"`

				// ParentId ID of the parent asset
				ParentId *int `json:"parentId"`

				// SerialNumber Serial number of the asset
				SerialNumber *string `json:"serialNumber"`

				// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"asset"`

			// Assignees Either the teamId, the userId or the user email address (expand with query parameter)
			Assignees *[]struct {
				Id   GetWorkorders_200_WorkOrders_Assignees_Id `json:"id"`
				Type GetWorkorders200WorkOrdersAssigneesType   `json:"type"`
			} `json:"assignees,omitempty"`

			// Categories List of categories that identify the work order (expand with query parameter)
			Categories *[]string `json:"categories,omitempty"`

			// CompletedAt Date & time at which the work order was last marked as DONE
			CompletedAt *time.Time `json:"completedAt"`

			// CompleterId ID of the user who completed the work order
			CompleterId *int `json:"completerId"`

			// CreatedAt Date & time at which the work order was created
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// CreatorId ID of the user who created the work order
			CreatorId *int `json:"creatorId"`

			// DeletedAt Date & time at which the work order was deleted
			DeletedAt   *time.Time `json:"deletedAt"`
			Description *string    `json:"description"`

			// DueDate Date & time at which the work order is due
			DueDate          *time.Time `json:"dueDate"`
			DueDateIsFullDay *bool      `json:"dueDateIsFullDay"`
			Expenditures     *[]struct {
				// CostPerUnit Cost per part in cents or cents per hour
				CostPerUnit *float32 `json:"costPerUnit"`

				// Description Description of the expense or part description
				Description *string `json:"description"`

				// DurationTotal Total duration in seconds
				DurationTotal *float32 `json:"durationTotal,omitempty"`

				// PartId ID of the part used in this cost entry
				PartId *int `json:"partId"`

				// Quantity Number of parts or number of hours
				Quantity *float32 `json:"quantity,omitempty"`

				// RowTotal Total cost in cents
				RowTotal *float32 `json:"rowTotal,omitempty"`

				// Type Type of the entry
				Type *GetWorkorders200WorkOrdersExpendituresType `json:"type,omitempty"`

				// UserId ID of the user who logged the time entry
				UserId *int `json:"userId"`
			} `json:"expenditures,omitempty"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Budget") (expand with query parameter)
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the work order
			Id int `json:"id"`

			// Location Location linked to the element (expand with query parameter)
			Location *struct {
				// Address Postal address of the location
				Address *string `json:"address"`

				// CreatedAt Date & time at which the location was created
				CreatedAt   *time.Time `json:"createdAt,omitempty"`
				Description *string    `json:"description"`

				// Id Global ID of the location
				Id   int    `json:"id"`
				Name string `json:"name"`

				// ParentId ID of the parent location
				ParentId *int `json:"parentId"`

				// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"location"`

			// LocationId Global ID of the location assigned to the work order
			LocationId     *int     `json:"locationId"`
			NextId         *int     `json:"nextId"`
			OrganizationId *float32 `json:"organizationId,omitempty"`

			// Parts Parts attached to the work order (expand with query parameter)
			Parts *[]struct {
				Area *string `json:"area"`

				// AvailableQuantity Quantity currently in stock
				AvailableQuantity int `json:"availableQuantity"`

				// Barcode String encoded barcode
				Barcode *string `json:"barcode"`

				// CopyOnRecurring Indicates if the parts will be copied to the next work order in the chain (if applicable).
				CopyOnRecurring GetWorkorders200WorkOrdersPartsCopyOnRecurring `json:"copyOnRecurring"`
				Description     *string                                        `json:"description"`
				ExtraFields     *map[string]string                             `json:"extraFields,omitempty"`

				// Id Global ID of the part
				Id int `json:"id"`

				// LocationId Global ID of the location of the part
				LocationId *float32 `json:"locationId"`

				// MinimumQuantity Minimum quantity before you should restock
				MinimumQuantity int    `json:"minimumQuantity"`
				Name            string `json:"name"`

				// QuantityUsed Quantity used in the work order.
				QuantityUsed int `json:"quantityUsed"`

				// UnitCost Cost in cents. For example, for $1.20, put 120.
				UnitCost *int `json:"unitCost"`
			} `json:"parts,omitempty"`
			PreviousId *int                                `json:"previousId"`
			Priority   *GetWorkorders200WorkOrdersPriority `json:"priority,omitempty"`

			// Procedure Procedure attached to the work order (expand with query parameter)
			Procedure *struct {
				Fields []struct {
					Assignees *struct {
						TeamIds *[]float32 `json:"teamIds,omitempty"`
						UserIds *[]float32 `json:"userIds,omitempty"`
					} `json:"assignees"`

					// Description Description of the procedure field
					Description *string `json:"description"`

					// Id ID of the procedure field
					Id float32 `json:"id"`

					// IsDateAndTime Indicate if a DATE field also contains the time
					IsDateAndTime *bool `json:"isDateAndTime"`

					// Label Label of a procedure field
					Label string `json:"label"`

					// MaxScore Maximum score of a procedure field
					MaxScore *float32 `json:"maxScore,omitempty"`

					// Meter Meter of a procedure field. Will be filled if the type of the field is meter
					Meter *struct {
						// Id Global ID of the meter.
						Id *float32 `json:"id,omitempty"`

						// Name Name of the meters
						Name *string `json:"name,omitempty"`
					} `json:"meter"`

					// ParentId ID of the parent of the current procedure field
					ParentId *float32 `json:"parentId"`

					// Required Indicate if field is required to be filled.
					Required bool `json:"required"`

					// Score Score of a procedure field
					Score *float32 `json:"score,omitempty"`

					// Type Type of procedure field
					Type GetWorkorders200WorkOrdersProcedureFieldsType `json:"type"`

					// Value Current value of a procedure field
					Value struct {
						// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
						Attachment *struct {
							// CreatedAt Date & time at which the attachment was uploaded
							CreatedAt time.Time `json:"createdAt"`

							// FileName Attachment's file name
							FileName string `json:"fileName"`

							// Height Height if the file is an image
							Height *float32 `json:"height"`

							// Id Global ID of the attachment
							Id float32 `json:"id"`

							// MimeType MIME type of the file
							MimeType string `json:"mimeType"`

							// Url Url of the file
							Url string `json:"url"`

							// Width Width if the file is an image
							Width *float32 `json:"width"`
						} `json:"attachment,omitempty"`
						Attachments *[]struct {
							// CreatedAt Date & time at which the attachment was uploaded
							CreatedAt time.Time `json:"createdAt"`

							// FileName Attachment's file name
							FileName string `json:"fileName"`

							// Height Height if the file is an image
							Height *float32 `json:"height"`

							// Id Global ID of the attachment
							Id float32 `json:"id"`

							// MimeType MIME type of the file
							MimeType string `json:"mimeType"`

							// Url Url of the file
							Url string `json:"url"`

							// Width Width if the file is an image
							Width *float32 `json:"width"`
						} `json:"attachments,omitempty"`
						HasAttachments *bool `json:"hasAttachments"`

						// Notes Note added to a procedure field
						Notes *struct {
							Text *string `json:"text,omitempty"`
						} `json:"notes"`
						Text *string `json:"text"`
					} `json:"value"`
				} `json:"fields"`

				// Id ID representing a procedure
				Id *float32 `json:"id,omitempty"`

				// MaxScore Maximum score of a procedure
				MaxScore *float32 `json:"maxScore,omitempty"`

				// Score Score of a procedure
				Score *float32 `json:"score,omitempty"`

				// TemplateIds IDs of the procedure template of the procedure
				TemplateIds *[]float32 `json:"templateIds"`

				// Title Title of the procedure
				Title string `json:"title"`
			} `json:"procedure,omitempty"`
			RecurrenceInfo *GetWorkorders_200_WorkOrders_RecurrenceInfo `json:"recurrenceInfo"`

			// RequesterId ID of the user who requested the work order through the Work Request feature
			RequesterId *int `json:"requesterId"`

			// SequentialId Organization specific ID of the work order
			SequentialId int `json:"sequentialId"`

			// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
			StartDate *time.Time `json:"startDate"`

			// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
			Status GetWorkorders200WorkOrdersStatus `json:"status"`

			// Thumbnail (expand with query parameter)
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail,omitempty"`
			TimeItems *[]struct {
				// CostPerUnit Cost per part in cents or cents per hour
				CostPerUnit *float32 `json:"costPerUnit"`

				// Description Description of the expense or part description
				Description *string `json:"description"`

				// DurationTotal Total duration in seconds
				DurationTotal *float32 `json:"durationTotal,omitempty"`

				// PartId ID of the part used in this cost entry
				PartId *int `json:"partId"`

				// Quantity Number of parts or number of hours
				Quantity *float32 `json:"quantity,omitempty"`

				// RowTotal Total cost in cents
				RowTotal *float32 `json:"rowTotal,omitempty"`

				// Type Type of the entry
				Type *GetWorkorders200WorkOrdersTimeItemsType `json:"type,omitempty"`

				// UserId ID of the user who logged the time entry
				UserId *int `json:"userId"`
			} `json:"timeItems,omitempty"`
			Times *[]struct {
				// CostPerUnit Cost per part in cents or cents per hour
				CostPerUnit *float32 `json:"costPerUnit"`

				// Description Description of the expense or part description
				Description *string `json:"description"`

				// DurationTotal Total duration in seconds
				DurationTotal *float32 `json:"durationTotal,omitempty"`

				// PartId ID of the part used in this cost entry
				PartId *int `json:"partId"`

				// Quantity Number of parts or number of hours
				Quantity *float32 `json:"quantity,omitempty"`

				// RowTotal Total cost in cents
				RowTotal *float32 `json:"rowTotal,omitempty"`

				// Type Type of the entry
				Type *GetWorkorders200WorkOrdersTimesType `json:"type,omitempty"`

				// UserId ID of the user who logged the time entry
				UserId *int `json:"userId"`
			} `json:"times,omitempty"`
			Title string `json:"title"`

			// Type Valid types of Work Orders, including options that are not available for creation/update. Historical Work Orders may have a null type.
			Type *GetWorkorders200WorkOrdersType `json:"type"`

			// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
			UpdatedAt time.Time `json:"updatedAt"`

			// VendorIds Vendor IDs
			VendorIds *[]float32 `json:"vendorIds,omitempty"`
		} `json:"workOrders"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}
type GetWorkorders200WorkOrdersAssigneesId0 = int
type GetWorkorders200WorkOrdersAssigneesId1 = string
type GetWorkorders_200_WorkOrders_Assignees_Id struct {
	union json.RawMessage
}
type GetWorkorders200WorkOrdersAssigneesType string
type GetWorkorders200WorkOrdersExpendituresType string
type GetWorkorders200WorkOrdersPartsCopyOnRecurring string
type GetWorkorders200WorkOrdersPriority string
type GetWorkorders200WorkOrdersProcedureFieldsType string
type GetWorkorders200WorkOrdersRecurrenceInfo0 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkorders200WorkOrdersRecurrenceInfo0AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`
	Type GetWorkorders200WorkOrdersRecurrenceInfo0Type `json:"type"`
}
type GetWorkorders200WorkOrdersRecurrenceInfo0AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkorders200WorkOrdersRecurrenceInfo0Type string
type GetWorkorders200WorkOrdersRecurrenceInfo1 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkorders200WorkOrdersRecurrenceInfo1AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Days Days of the week the event will occur
	Days []GetWorkorders200WorkOrdersRecurrenceInfo1Days `json:"days"`

	// Interval Number of weeks between events
	Interval *int                                          `json:"interval,omitempty"`
	Type     GetWorkorders200WorkOrdersRecurrenceInfo1Type `json:"type"`
}
type GetWorkorders200WorkOrdersRecurrenceInfo1AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkorders200WorkOrdersRecurrenceInfo1Days string
type GetWorkorders200WorkOrdersRecurrenceInfo1Type string
type GetWorkorders200WorkOrdersRecurrenceInfo2 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkorders200WorkOrdersRecurrenceInfo2AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Day Day of the month the event will occur
	Day int `json:"day"`

	// Interval Number of months between events
	Interval *int                                          `json:"interval,omitempty"`
	Type     GetWorkorders200WorkOrdersRecurrenceInfo2Type `json:"type"`
}
type GetWorkorders200WorkOrdersRecurrenceInfo2AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkorders200WorkOrdersRecurrenceInfo2Type string
type GetWorkorders200WorkOrdersRecurrenceInfo3 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkorders200WorkOrdersRecurrenceInfo3AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Interval Number of years between events
	Interval *int                                          `json:"interval,omitempty"`
	Type     GetWorkorders200WorkOrdersRecurrenceInfo3Type `json:"type"`
}
type GetWorkorders200WorkOrdersRecurrenceInfo3AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkorders200WorkOrdersRecurrenceInfo3Type string
type GetWorkorders200WorkOrdersRecurrenceInfo4 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkorders200WorkOrdersRecurrenceInfo4AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Interval Number of seconds between events
	Interval *int                                          `json:"interval,omitempty"`
	Type     GetWorkorders200WorkOrdersRecurrenceInfo4Type `json:"type"`
}
type GetWorkorders200WorkOrdersRecurrenceInfo4AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkorders200WorkOrdersRecurrenceInfo4Type string
type GetWorkorders_200_WorkOrders_RecurrenceInfo struct {
	union json.RawMessage
}
type GetWorkorders200WorkOrdersStatus string
type GetWorkorders200WorkOrdersTimeItemsType string
type GetWorkorders200WorkOrdersTimesType string
type GetWorkorders200WorkOrdersType string

// Status returns HTTPResponse.Status
func (r GetWorkordersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkordersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWorkordersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id float32 `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                `json:"error"`
			FieldPath  *string                               `json:"fieldPath"`
			FieldValue *PostWorkorders_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostWorkorders400ErrorsFieldValue0 = string
type PostWorkorders400ErrorsFieldValue1 = float32
type PostWorkorders400ErrorsFieldValue2 = bool
type PostWorkorders_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostWorkordersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWorkordersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkordersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                    `json:"error"`
			FieldPath  *string                                   `json:"fieldPath"`
			FieldValue *DeleteWorkordersId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteWorkordersId400ErrorsFieldValue0 = string
type DeleteWorkordersId400ErrorsFieldValue1 = float32
type DeleteWorkordersId400ErrorsFieldValue2 = bool
type DeleteWorkordersId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteWorkordersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkordersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkordersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		WorkOrder struct {
			// Asset Asset linked to the element (expand with query parameter)
			Asset *struct {
				// CreatedAt Date & time at which the asset was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId ID of the asset creator
				CreatorId *int `json:"creatorId"`

				// CriticalityId ID of the criticality of the asset
				CriticalityId *int    `json:"criticalityId"`
				Description   *string `json:"description"`

				// Id Global ID of the asset
				Id int `json:"id"`

				// LocationId ID of the location where the asset is located
				LocationId *int   `json:"locationId"`
				Name       string `json:"name"`

				// ParentId ID of the parent asset
				ParentId *int `json:"parentId"`

				// SerialNumber Serial number of the asset
				SerialNumber *string `json:"serialNumber"`

				// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"asset"`
			AssetId *int `json:"assetId"`

			// AssigneeIds List of user ids assigned to the work order
			AssigneeIds *[]int `json:"assigneeIds,omitempty"`

			// Assignees Either the teamId, the userId or the user email address (expand with query parameter)
			Assignees *[]struct {
				Id   GetWorkordersId_200_WorkOrder_Assignees_Id `json:"id"`
				Type GetWorkordersId200WorkOrderAssigneesType   `json:"type"`
			} `json:"assignees,omitempty"`

			// Attachments List of attachments linked to the work order
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// Categories List of categories that identify the work order
			Categories *[]string `json:"categories,omitempty"`

			// CompletedAt Date & time at which the work order was last marked as DONE
			CompletedAt *time.Time `json:"completedAt"`

			// CompleterId ID of the user who completed the work order
			CompleterId *int `json:"completerId"`

			// CreatedAt Date & time at which the work order was created
			CreatedAt time.Time `json:"createdAt"`

			// CreatorId ID of the user who created the work order
			CreatorId *int `json:"creatorId"`

			// DeletedAt Date & time at which the work order was deleted
			DeletedAt   *time.Time `json:"deletedAt"`
			Description *string    `json:"description"`

			// DueDate Date & time at which the work order is due
			DueDate          *time.Time `json:"dueDate"`
			DueDateIsFullDay *bool      `json:"dueDateIsFullDay"`

			// EstimatedTime The estimated time taken in seconds to complete the work order (expand with query parameter)
			EstimatedTime *int `json:"estimatedTime"`

			// Expenditures Other cost entries on the Work Order. Grouped by users (expand with query parameter)
			Expenditures *[]struct {
				// CostPerUnit Cost per part in cents or cents per hour
				CostPerUnit *float32 `json:"costPerUnit"`

				// Description Description of the expense or part description
				Description *string `json:"description"`

				// DurationTotal Total duration in seconds
				DurationTotal *float32 `json:"durationTotal,omitempty"`

				// PartId ID of the part used in this cost entry
				PartId *int `json:"partId"`

				// Quantity Number of parts or number of hours
				Quantity *float32 `json:"quantity,omitempty"`

				// RowTotal Total cost in cents
				RowTotal *float32 `json:"rowTotal,omitempty"`

				// Type Type of the entry
				Type *GetWorkordersId200WorkOrderExpendituresType `json:"type,omitempty"`

				// UserId ID of the user who logged the time entry
				UserId *int `json:"userId"`
			} `json:"expenditures,omitempty"`

			// ExternalData Extra data that can be attached to the work order, for example to help reference to a matching record in an external system.
			ExternalData *GetWorkordersId_200_WorkOrder_ExternalData `json:"externalData"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Budget") (expand with query parameter)
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the work order
			Id int `json:"id"`

			// IsParent If this is a parent work order
			IsParent *bool `json:"isParent"`

			// Location Location linked to the element (expand with query parameter)
			Location *struct {
				// Address Postal address of the location
				Address *string `json:"address"`

				// CreatedAt Date & time at which the location was created
				CreatedAt   *time.Time `json:"createdAt,omitempty"`
				Description *string    `json:"description"`

				// Id Global ID of the location
				Id   int    `json:"id"`
				Name string `json:"name"`

				// ParentId ID of the parent location
				ParentId *int `json:"parentId"`

				// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"location"`

			// LocationId Global ID of the location assigned to the work order
			LocationId     *int    `json:"locationId"`
			NextId         *int    `json:"nextId"`
			OrganizationId float32 `json:"organizationId"`

			// ParentId The ID of the parent work order
			ParentId *int `json:"parentId"`

			// Parts Parts attached to the Work Order (expand with query parameter)
			Parts *[]struct {
				Area *string `json:"area"`

				// AvailableQuantity Quantity currently in stock
				AvailableQuantity int `json:"availableQuantity"`

				// Barcode String encoded barcode
				Barcode *string `json:"barcode"`

				// CopyOnRecurring Indicates if the parts will be copied to the next work order in the chain (if applicable).
				CopyOnRecurring GetWorkordersId200WorkOrderPartsCopyOnRecurring `json:"copyOnRecurring"`
				Description     *string                                         `json:"description"`
				ExtraFields     *map[string]string                              `json:"extraFields,omitempty"`

				// Id Global ID of the part
				Id int `json:"id"`

				// LocationId Global ID of the location of the part
				LocationId *float32 `json:"locationId"`

				// MinimumQuantity Minimum quantity before you should restock
				MinimumQuantity int    `json:"minimumQuantity"`
				Name            string `json:"name"`

				// QuantityUsed Quantity used in the work order.
				QuantityUsed int `json:"quantityUsed"`

				// UnitCost Cost in cents. For example, for $1.20, put 120.
				UnitCost *int `json:"unitCost"`
			} `json:"parts,omitempty"`
			PreviousId *int                                 `json:"previousId"`
			Priority   *GetWorkordersId200WorkOrderPriority `json:"priority,omitempty"`

			// Procedure Procedure attached to the work order
			Procedure *struct {
				Fields []struct {
					Assignees *struct {
						TeamIds *[]float32 `json:"teamIds,omitempty"`
						UserIds *[]float32 `json:"userIds,omitempty"`
					} `json:"assignees"`

					// Description Description of the procedure field
					Description *string `json:"description"`

					// Id ID of the procedure field
					Id float32 `json:"id"`

					// IsDateAndTime Indicate if a DATE field also contains the time
					IsDateAndTime *bool `json:"isDateAndTime"`

					// Label Label of a procedure field
					Label string `json:"label"`

					// MaxScore Maximum score of a procedure field
					MaxScore *float32 `json:"maxScore,omitempty"`

					// Meter Meter of a procedure field. Will be filled if the type of the field is meter
					Meter *struct {
						// Id Global ID of the meter.
						Id *float32 `json:"id,omitempty"`

						// Name Name of the meters
						Name *string `json:"name,omitempty"`
					} `json:"meter"`

					// ParentId ID of the parent of the current procedure field
					ParentId *float32 `json:"parentId"`

					// Required Indicate if field is required to be filled.
					Required bool `json:"required"`

					// Score Score of a procedure field
					Score *float32 `json:"score,omitempty"`

					// Type Type of procedure field
					Type GetWorkordersId200WorkOrderProcedureFieldsType `json:"type"`

					// Value Current value of a procedure field
					Value struct {
						// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
						Attachment *struct {
							// CreatedAt Date & time at which the attachment was uploaded
							CreatedAt time.Time `json:"createdAt"`

							// FileName Attachment's file name
							FileName string `json:"fileName"`

							// Height Height if the file is an image
							Height *float32 `json:"height"`

							// Id Global ID of the attachment
							Id float32 `json:"id"`

							// MimeType MIME type of the file
							MimeType string `json:"mimeType"`

							// Url Url of the file
							Url string `json:"url"`

							// Width Width if the file is an image
							Width *float32 `json:"width"`
						} `json:"attachment,omitempty"`
						Attachments *[]struct {
							// CreatedAt Date & time at which the attachment was uploaded
							CreatedAt time.Time `json:"createdAt"`

							// FileName Attachment's file name
							FileName string `json:"fileName"`

							// Height Height if the file is an image
							Height *float32 `json:"height"`

							// Id Global ID of the attachment
							Id float32 `json:"id"`

							// MimeType MIME type of the file
							MimeType string `json:"mimeType"`

							// Url Url of the file
							Url string `json:"url"`

							// Width Width if the file is an image
							Width *float32 `json:"width"`
						} `json:"attachments,omitempty"`
						HasAttachments *bool `json:"hasAttachments"`

						// Notes Note added to a procedure field
						Notes *struct {
							Text *string `json:"text,omitempty"`
						} `json:"notes"`
						Text *string `json:"text"`
					} `json:"value"`
				} `json:"fields"`

				// Id ID representing a procedure
				Id *float32 `json:"id,omitempty"`

				// MaxScore Maximum score of a procedure
				MaxScore *float32 `json:"maxScore,omitempty"`

				// Score Score of a procedure
				Score *float32 `json:"score,omitempty"`

				// TemplateIds IDs of the procedure template of the procedure
				TemplateIds *[]float32 `json:"templateIds"`

				// Title Title of the procedure
				Title string `json:"title"`
			} `json:"procedure"`

			// Progress Progress information on the work order
			Progress *struct {
				DoneCount       *float32 `json:"doneCount,omitempty"`
				InProgressCount *float32 `json:"inProgressCount,omitempty"`
				OnHoldCount     *float32 `json:"onHoldCount,omitempty"`
				OpenCount       *float32 `json:"openCount,omitempty"`
			} `json:"progress"`
			RecurrenceInfo *GetWorkordersId_200_WorkOrder_RecurrenceInfo `json:"recurrenceInfo"`

			// RequesterId ID of the user who requested the work order through the Work Request feature
			RequesterId *int `json:"requesterId"`

			// SequentialId Organization specific ID of the work order
			SequentialId int `json:"sequentialId"`

			// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
			StartDate *time.Time `json:"startDate"`

			// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
			Status GetWorkordersId200WorkOrderStatus `json:"status"`

			// TeamIds List of team ids assigned to the work order
			TeamIds   *[]int `json:"teamIds,omitempty"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`

			// TimeItems Time entries on the Work Order. (expand with query parameter)
			TimeItems *[]struct {
				// CostPerUnit Cost per part in cents or cents per hour
				CostPerUnit *float32 `json:"costPerUnit"`

				// Description Description of the expense or part description
				Description *string `json:"description"`

				// DurationTotal Total duration in seconds
				DurationTotal *float32 `json:"durationTotal,omitempty"`

				// PartId ID of the part used in this cost entry
				PartId *int `json:"partId"`

				// Quantity Number of parts or number of hours
				Quantity *float32 `json:"quantity,omitempty"`

				// RowTotal Total cost in cents
				RowTotal *float32 `json:"rowTotal,omitempty"`

				// Type Type of the entry
				Type *GetWorkordersId200WorkOrderTimeItemsType `json:"type,omitempty"`

				// UserId ID of the user who logged the time entry
				UserId *int `json:"userId"`
			} `json:"timeItems,omitempty"`

			// Times Time entries on the Work Order. Grouped by users (expand with query parameter)
			Times *[]struct {
				// CostPerUnit Cost per part in cents or cents per hour
				CostPerUnit *float32 `json:"costPerUnit"`

				// Description Description of the expense or part description
				Description *string `json:"description"`

				// DurationTotal Total duration in seconds
				DurationTotal *float32 `json:"durationTotal,omitempty"`

				// PartId ID of the part used in this cost entry
				PartId *int `json:"partId"`

				// Quantity Number of parts or number of hours
				Quantity *float32 `json:"quantity,omitempty"`

				// RowTotal Total cost in cents
				RowTotal *float32 `json:"rowTotal,omitempty"`

				// Type Type of the entry
				Type *GetWorkordersId200WorkOrderTimesType `json:"type,omitempty"`

				// UserId ID of the user who logged the time entry
				UserId *int `json:"userId"`
			} `json:"times,omitempty"`
			Title string `json:"title"`

			// Type Valid types of Work Orders, including options that are not available for creation/update. Historical Work Orders may have a null type.
			Type *GetWorkordersId200WorkOrderType `json:"type"`

			// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
			UpdatedAt time.Time `json:"updatedAt"`

			// VendorIds Vendor IDs
			VendorIds *[]float32 `json:"vendorIds,omitempty"`
		} `json:"workOrder"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetWorkordersId200WorkOrderAssigneesId0 = int
type GetWorkordersId200WorkOrderAssigneesId1 = string
type GetWorkordersId_200_WorkOrder_Assignees_Id struct {
	union json.RawMessage
}
type GetWorkordersId200WorkOrderAssigneesType string
type GetWorkordersId200WorkOrderExpendituresType string
type GetWorkordersId200WorkOrderExternalData0 = map[string]interface{}
type GetWorkordersId200WorkOrderExternalData1 = float32
type GetWorkordersId200WorkOrderExternalData2 = string
type GetWorkordersId_200_WorkOrder_ExternalData struct {
	union json.RawMessage
}
type GetWorkordersId200WorkOrderPartsCopyOnRecurring string
type GetWorkordersId200WorkOrderPriority string
type GetWorkordersId200WorkOrderProcedureFieldsType string
type GetWorkordersId200WorkOrderRecurrenceInfo0 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkordersId200WorkOrderRecurrenceInfo0AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`
	Type GetWorkordersId200WorkOrderRecurrenceInfo0Type `json:"type"`
}
type GetWorkordersId200WorkOrderRecurrenceInfo0AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkordersId200WorkOrderRecurrenceInfo0Type string
type GetWorkordersId200WorkOrderRecurrenceInfo1 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkordersId200WorkOrderRecurrenceInfo1AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Days Days of the week the event will occur
	Days []GetWorkordersId200WorkOrderRecurrenceInfo1Days `json:"days"`

	// Interval Number of weeks between events
	Interval *int                                           `json:"interval,omitempty"`
	Type     GetWorkordersId200WorkOrderRecurrenceInfo1Type `json:"type"`
}
type GetWorkordersId200WorkOrderRecurrenceInfo1AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkordersId200WorkOrderRecurrenceInfo1Days string
type GetWorkordersId200WorkOrderRecurrenceInfo1Type string
type GetWorkordersId200WorkOrderRecurrenceInfo2 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkordersId200WorkOrderRecurrenceInfo2AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Day Day of the month the event will occur
	Day int `json:"day"`

	// Interval Number of months between events
	Interval *int                                           `json:"interval,omitempty"`
	Type     GetWorkordersId200WorkOrderRecurrenceInfo2Type `json:"type"`
}
type GetWorkordersId200WorkOrderRecurrenceInfo2AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkordersId200WorkOrderRecurrenceInfo2Type string
type GetWorkordersId200WorkOrderRecurrenceInfo3 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkordersId200WorkOrderRecurrenceInfo3AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Interval Number of years between events
	Interval *int                                           `json:"interval,omitempty"`
	Type     GetWorkordersId200WorkOrderRecurrenceInfo3Type `json:"type"`
}
type GetWorkordersId200WorkOrderRecurrenceInfo3AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkordersId200WorkOrderRecurrenceInfo3Type string
type GetWorkordersId200WorkOrderRecurrenceInfo4 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkordersId200WorkOrderRecurrenceInfo4AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Interval Number of seconds between events
	Interval *int                                           `json:"interval,omitempty"`
	Type     GetWorkordersId200WorkOrderRecurrenceInfo4Type `json:"type"`
}
type GetWorkordersId200WorkOrderRecurrenceInfo4AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkordersId200WorkOrderRecurrenceInfo4Type string
type GetWorkordersId_200_WorkOrder_RecurrenceInfo struct {
	union json.RawMessage
}
type GetWorkordersId200WorkOrderStatus string
type GetWorkordersId200WorkOrderTimeItemsType string
type GetWorkordersId200WorkOrderTimesType string
type GetWorkordersId200WorkOrderType string

// Status returns HTTPResponse.Status
func (r GetWorkordersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkordersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchWorkordersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		WorkOrder *struct {
			AssetId *int `json:"assetId"`

			// AssigneeIds List of user ids assigned to the work order
			AssigneeIds *[]int `json:"assigneeIds,omitempty"`

			// Attachments List of attachments linked to the work order
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// Categories List of categories that identify the work order
			Categories *[]string `json:"categories,omitempty"`

			// CompletedAt Date & time at which the work order was last marked as DONE
			CompletedAt *time.Time `json:"completedAt"`

			// CompleterId ID of the user who completed the work order
			CompleterId *int `json:"completerId"`

			// CreatedAt Date & time at which the work order was created
			CreatedAt time.Time `json:"createdAt"`

			// CreatorId ID of the user who created the work order
			CreatorId *int `json:"creatorId"`

			// DeletedAt Date & time at which the work order was deleted
			DeletedAt   *time.Time `json:"deletedAt"`
			Description *string    `json:"description"`

			// DueDate Date & time at which the work order is due
			DueDate          *time.Time `json:"dueDate"`
			DueDateIsFullDay *bool      `json:"dueDateIsFullDay"`

			// EstimatedTime The estimated time taken in seconds to complete the work order
			EstimatedTime *int `json:"estimatedTime"`

			// ExternalData Extra data that can be attached to the work order, for example to help reference to a matching record in an external system.
			ExternalData *PatchWorkordersId_200_WorkOrder_ExternalData `json:"externalData"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Time Allotted")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the work order
			Id int `json:"id"`

			// IsParent If this is a parent work order
			IsParent *bool `json:"isParent"`

			// LocationId Global ID of the location assigned to the work order
			LocationId     *int    `json:"locationId"`
			NextId         *int    `json:"nextId"`
			OrganizationId float32 `json:"organizationId"`

			// ParentId The ID of the parent work order
			ParentId   *int                                   `json:"parentId"`
			PreviousId *int                                   `json:"previousId"`
			Priority   *PatchWorkordersId200WorkOrderPriority `json:"priority,omitempty"`

			// Procedure Procedure attached to the work order
			Procedure *struct {
				Fields []struct {
					Assignees *struct {
						TeamIds *[]float32 `json:"teamIds,omitempty"`
						UserIds *[]float32 `json:"userIds,omitempty"`
					} `json:"assignees"`

					// Description Description of the procedure field
					Description *string `json:"description"`

					// Id ID of the procedure field
					Id float32 `json:"id"`

					// IsDateAndTime Indicate if a DATE field also contains the time
					IsDateAndTime *bool `json:"isDateAndTime"`

					// Label Label of a procedure field
					Label string `json:"label"`

					// MaxScore Maximum score of a procedure field
					MaxScore *float32 `json:"maxScore,omitempty"`

					// Meter Meter of a procedure field. Will be filled if the type of the field is meter
					Meter *struct {
						// Id Global ID of the meter.
						Id *float32 `json:"id,omitempty"`

						// Name Name of the meters
						Name *string `json:"name,omitempty"`
					} `json:"meter"`

					// ParentId ID of the parent of the current procedure field
					ParentId *float32 `json:"parentId"`

					// Required Indicate if field is required to be filled.
					Required bool `json:"required"`

					// Score Score of a procedure field
					Score *float32 `json:"score,omitempty"`

					// Type Type of procedure field
					Type PatchWorkordersId200WorkOrderProcedureFieldsType `json:"type"`

					// Value Current value of a procedure field
					Value struct {
						// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
						Attachment *struct {
							// CreatedAt Date & time at which the attachment was uploaded
							CreatedAt time.Time `json:"createdAt"`

							// FileName Attachment's file name
							FileName string `json:"fileName"`

							// Height Height if the file is an image
							Height *float32 `json:"height"`

							// Id Global ID of the attachment
							Id float32 `json:"id"`

							// MimeType MIME type of the file
							MimeType string `json:"mimeType"`

							// Url Url of the file
							Url string `json:"url"`

							// Width Width if the file is an image
							Width *float32 `json:"width"`
						} `json:"attachment,omitempty"`
						Attachments *[]struct {
							// CreatedAt Date & time at which the attachment was uploaded
							CreatedAt time.Time `json:"createdAt"`

							// FileName Attachment's file name
							FileName string `json:"fileName"`

							// Height Height if the file is an image
							Height *float32 `json:"height"`

							// Id Global ID of the attachment
							Id float32 `json:"id"`

							// MimeType MIME type of the file
							MimeType string `json:"mimeType"`

							// Url Url of the file
							Url string `json:"url"`

							// Width Width if the file is an image
							Width *float32 `json:"width"`
						} `json:"attachments,omitempty"`
						HasAttachments *bool `json:"hasAttachments"`

						// Notes Note added to a procedure field
						Notes *struct {
							Text *string `json:"text,omitempty"`
						} `json:"notes"`
						Text *string `json:"text"`
					} `json:"value"`
				} `json:"fields"`

				// Id ID representing a procedure
				Id *float32 `json:"id,omitempty"`

				// MaxScore Maximum score of a procedure
				MaxScore *float32 `json:"maxScore,omitempty"`

				// Score Score of a procedure
				Score *float32 `json:"score,omitempty"`

				// TemplateIds IDs of the procedure template of the procedure
				TemplateIds *[]float32 `json:"templateIds"`

				// Title Title of the procedure
				Title string `json:"title"`
			} `json:"procedure"`

			// Progress Progress information on the work order
			Progress *struct {
				DoneCount       *float32 `json:"doneCount,omitempty"`
				InProgressCount *float32 `json:"inProgressCount,omitempty"`
				OnHoldCount     *float32 `json:"onHoldCount,omitempty"`
				OpenCount       *float32 `json:"openCount,omitempty"`
			} `json:"progress"`
			RecurrenceInfo *PatchWorkordersId_200_WorkOrder_RecurrenceInfo `json:"recurrenceInfo"`

			// RequesterId ID of the user who requested the work order through the Work Request feature
			RequesterId *int `json:"requesterId"`

			// SequentialId Organization specific ID of the work order
			SequentialId int `json:"sequentialId"`

			// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
			StartDate *time.Time `json:"startDate"`

			// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
			Status PatchWorkordersId200WorkOrderStatus `json:"status"`

			// TeamIds List of team ids assigned to the work order
			TeamIds   *[]int `json:"teamIds,omitempty"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`
			Title string `json:"title"`

			// Type Valid types of Work Orders, including options that are not available for creation/update. Historical Work Orders may have a null type.
			Type *PatchWorkordersId200WorkOrderType `json:"type"`

			// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
			UpdatedAt time.Time `json:"updatedAt"`

			// VendorIds Vendor IDs
			VendorIds *[]float32 `json:"vendorIds,omitempty"`
		} `json:"workOrder,omitempty"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                   `json:"error"`
			FieldPath  *string                                  `json:"fieldPath"`
			FieldValue *PatchWorkordersId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchWorkordersId200WorkOrderExternalData0 = map[string]interface{}
type PatchWorkordersId200WorkOrderExternalData1 = float32
type PatchWorkordersId200WorkOrderExternalData2 = string
type PatchWorkordersId_200_WorkOrder_ExternalData struct {
	union json.RawMessage
}
type PatchWorkordersId200WorkOrderPriority string
type PatchWorkordersId200WorkOrderProcedureFieldsType string
type PatchWorkordersId200WorkOrderRecurrenceInfo0 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator PatchWorkordersId200WorkOrderRecurrenceInfo0AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`
	Type PatchWorkordersId200WorkOrderRecurrenceInfo0Type `json:"type"`
}
type PatchWorkordersId200WorkOrderRecurrenceInfo0AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type PatchWorkordersId200WorkOrderRecurrenceInfo0Type string
type PatchWorkordersId200WorkOrderRecurrenceInfo1 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator PatchWorkordersId200WorkOrderRecurrenceInfo1AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Days Days of the week the event will occur
	Days []PatchWorkordersId200WorkOrderRecurrenceInfo1Days `json:"days"`

	// Interval Number of weeks between events
	Interval *int                                             `json:"interval,omitempty"`
	Type     PatchWorkordersId200WorkOrderRecurrenceInfo1Type `json:"type"`
}
type PatchWorkordersId200WorkOrderRecurrenceInfo1AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type PatchWorkordersId200WorkOrderRecurrenceInfo1Days string
type PatchWorkordersId200WorkOrderRecurrenceInfo1Type string
type PatchWorkordersId200WorkOrderRecurrenceInfo2 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator PatchWorkordersId200WorkOrderRecurrenceInfo2AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Day Day of the month the event will occur
	Day int `json:"day"`

	// Interval Number of months between events
	Interval *int                                             `json:"interval,omitempty"`
	Type     PatchWorkordersId200WorkOrderRecurrenceInfo2Type `json:"type"`
}
type PatchWorkordersId200WorkOrderRecurrenceInfo2AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type PatchWorkordersId200WorkOrderRecurrenceInfo2Type string
type PatchWorkordersId200WorkOrderRecurrenceInfo3 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator PatchWorkordersId200WorkOrderRecurrenceInfo3AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Interval Number of years between events
	Interval *int                                             `json:"interval,omitempty"`
	Type     PatchWorkordersId200WorkOrderRecurrenceInfo3Type `json:"type"`
}
type PatchWorkordersId200WorkOrderRecurrenceInfo3AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type PatchWorkordersId200WorkOrderRecurrenceInfo3Type string
type PatchWorkordersId200WorkOrderRecurrenceInfo4 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator PatchWorkordersId200WorkOrderRecurrenceInfo4AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Interval Number of seconds between events
	Interval *int                                             `json:"interval,omitempty"`
	Type     PatchWorkordersId200WorkOrderRecurrenceInfo4Type `json:"type"`
}
type PatchWorkordersId200WorkOrderRecurrenceInfo4AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type PatchWorkordersId200WorkOrderRecurrenceInfo4Type string
type PatchWorkordersId_200_WorkOrder_RecurrenceInfo struct {
	union json.RawMessage
}
type PatchWorkordersId200WorkOrderStatus string
type PatchWorkordersId200WorkOrderType string
type PatchWorkordersId400ErrorsFieldValue0 = string
type PatchWorkordersId400ErrorsFieldValue1 = float32
type PatchWorkordersId400ErrorsFieldValue2 = bool
type PatchWorkordersId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchWorkordersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchWorkordersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkordersIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteWorkordersIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkordersIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutWorkordersIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *string
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r PutWorkordersIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutWorkordersIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkordersIdCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Comments []struct {
			// AuthorId ID of the user who created the comment
			AuthorId float32 `json:"authorId"`

			// Content Content of the comment to post
			Content string `json:"content"`

			// CreatedAt Date & time at which the comment was created
			CreatedAt time.Time `json:"createdAt"`

			// Id Global ID of the comment
			Id float32 `json:"id"`
		} `json:"comments"`

		// NextCursor The cursor to retrieve the next page of Comments.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Comments.
		NextPageUrl *string `json:"nextPageUrl"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWorkordersIdCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkordersIdCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWorkordersIdCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the comment
		Id float32 `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                          `json:"error"`
			FieldPath  *string                                         `json:"fieldPath"`
			FieldValue *PostWorkordersIdComments_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PostWorkordersIdComments400ErrorsFieldValue0 = string
type PostWorkordersIdComments400ErrorsFieldValue1 = float32
type PostWorkordersIdComments400ErrorsFieldValue2 = bool
type PostWorkordersIdComments_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostWorkordersIdCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWorkordersIdCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkordersIdCostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Costs struct {
			Rows []struct {
				// CostPerUnit Cost per part in cents or cents per hour
				CostPerUnit *float32 `json:"costPerUnit"`

				// Description Description of the expense or part description
				Description *string `json:"description"`

				// DurationTotal Total duration in seconds
				DurationTotal *float32 `json:"durationTotal,omitempty"`

				// PartId ID of the part used in this cost entry
				PartId *int `json:"partId"`

				// Quantity Number of parts or number of hours
				Quantity *float32 `json:"quantity,omitempty"`

				// RowTotal Total cost in cents
				RowTotal *float32 `json:"rowTotal,omitempty"`

				// Type Type of the entry
				Type *GetWorkordersIdCosts200CostsRowsType `json:"type,omitempty"`

				// UserId ID of the user who logged the time entry
				UserId *int `json:"userId"`
			} `json:"rows"`

			// Total Total cost in cents of the Work order
			Total float32 `json:"total"`
		} `json:"costs"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetWorkordersIdCosts200CostsRowsType string

// Status returns HTTPResponse.Status
func (r GetWorkordersIdCostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkordersIdCostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWorkordersIdCostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// CostPerUnit Cost per part in cents or cents per hour
		CostPerUnit *float32 `json:"costPerUnit"`

		// Description Description of the expense or part description
		Description *string `json:"description"`

		// DurationTotal Total duration in seconds
		DurationTotal *float32 `json:"durationTotal,omitempty"`

		// Id Created cost Id
		Id float32 `json:"id"`

		// PartId ID of the part used in this cost entry
		PartId *int `json:"partId"`

		// Quantity Number of parts or number of hours
		Quantity *float32 `json:"quantity,omitempty"`

		// RowTotal Total cost in cents
		RowTotal *float32 `json:"rowTotal,omitempty"`

		// Total Total cost in cents of the Work order
		Total float32 `json:"total"`

		// Type Type of the entry
		Type *PostWorkordersIdCosts201Type `json:"type,omitempty"`

		// UserId ID of the user who logged the time entry
		UserId *int `json:"userId"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                       `json:"error"`
			FieldPath  *string                                      `json:"fieldPath"`
			FieldValue *PostWorkordersIdCosts_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PostWorkordersIdCosts201Type string
type PostWorkordersIdCosts400ErrorsFieldValue0 = string
type PostWorkordersIdCosts400ErrorsFieldValue1 = float32
type PostWorkordersIdCosts400ErrorsFieldValue2 = bool
type PostWorkordersIdCosts_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostWorkordersIdCostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWorkordersIdCostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWorkordersIdEmailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the work order
		Id *int `json:"id,omitempty"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                        `json:"error"`
			FieldPath  *string                                       `json:"fieldPath"`
			FieldValue *PostWorkordersIdEmails_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                        `json:"error"`
			FieldPath  *string                                       `json:"fieldPath"`
			FieldValue *PostWorkordersIdEmails_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PostWorkordersIdEmails400ErrorsFieldValue0 = string
type PostWorkordersIdEmails400ErrorsFieldValue1 = float32
type PostWorkordersIdEmails400ErrorsFieldValue2 = bool
type PostWorkordersIdEmails_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PostWorkordersIdEmails403ErrorsFieldValue0 = string
type PostWorkordersIdEmails403ErrorsFieldValue1 = float32
type PostWorkordersIdEmails403ErrorsFieldValue2 = bool
type PostWorkordersIdEmails_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostWorkordersIdEmailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWorkordersIdEmailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkordersIdProcedureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                             `json:"error"`
			FieldPath  *string                                            `json:"fieldPath"`
			FieldValue *DeleteWorkordersIdProcedure_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteWorkordersIdProcedure400ErrorsFieldValue0 = string
type DeleteWorkordersIdProcedure400ErrorsFieldValue1 = float32
type DeleteWorkordersIdProcedure400ErrorsFieldValue2 = bool
type DeleteWorkordersIdProcedure_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteWorkordersIdProcedureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkordersIdProcedureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkordersIdProcedureFieldsIndexAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *string
	JSON404      *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteWorkordersIdProcedureFieldsIndexAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkordersIdProcedureFieldsIndexAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutWorkordersIdProcedureFieldsIndexAttachmentFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *string
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r PutWorkordersIdProcedureFieldsIndexAttachmentFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutWorkordersIdProcedureFieldsIndexAttachmentFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchWorkordersIdStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		WorkOrder *struct {
			AssetId *int `json:"assetId"`

			// AssigneeIds List of user ids assigned to the work order
			AssigneeIds *[]int `json:"assigneeIds,omitempty"`

			// Attachments List of attachments linked to the work order
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// Categories List of categories that identify the work order
			Categories *[]string `json:"categories,omitempty"`

			// CompletedAt Date & time at which the work order was last marked as DONE
			CompletedAt *time.Time `json:"completedAt"`

			// CompleterId ID of the user who completed the work order
			CompleterId *int `json:"completerId"`

			// CreatedAt Date & time at which the work order was created
			CreatedAt time.Time `json:"createdAt"`

			// CreatorId ID of the user who created the work order
			CreatorId *int `json:"creatorId"`

			// DeletedAt Date & time at which the work order was deleted
			DeletedAt   *time.Time `json:"deletedAt"`
			Description *string    `json:"description"`

			// DueDate Date & time at which the work order is due
			DueDate          *time.Time `json:"dueDate"`
			DueDateIsFullDay *bool      `json:"dueDateIsFullDay"`

			// ExternalData Extra data that can be attached to the work order, for example to help reference to a matching record in an external system.
			ExternalData *PatchWorkordersIdStatus_200_WorkOrder_ExternalData `json:"externalData"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Time Allotted")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the work order
			Id int `json:"id"`

			// LocationId Global ID of the location assigned to the work order
			LocationId     *int                                         `json:"locationId"`
			NextId         *int                                         `json:"nextId"`
			OrganizationId float32                                      `json:"organizationId"`
			PreviousId     *int                                         `json:"previousId"`
			Priority       *PatchWorkordersIdStatus200WorkOrderPriority `json:"priority,omitempty"`

			// Procedure Procedure attached to the work order
			Procedure *struct {
				Fields []struct {
					Assignees *struct {
						TeamIds *[]float32 `json:"teamIds,omitempty"`
						UserIds *[]float32 `json:"userIds,omitempty"`
					} `json:"assignees"`

					// Description Description of the procedure field
					Description *string `json:"description"`

					// Id ID of the procedure field
					Id float32 `json:"id"`

					// IsDateAndTime Indicate if a DATE field also contains the time
					IsDateAndTime *bool `json:"isDateAndTime"`

					// Label Label of a procedure field
					Label string `json:"label"`

					// MaxScore Maximum score of a procedure field
					MaxScore *float32 `json:"maxScore,omitempty"`

					// Meter Meter of a procedure field. Will be filled if the type of the field is meter
					Meter *struct {
						// Id Global ID of the meter.
						Id *float32 `json:"id,omitempty"`

						// Name Name of the meters
						Name *string `json:"name,omitempty"`
					} `json:"meter"`

					// ParentId ID of the parent of the current procedure field
					ParentId *float32 `json:"parentId"`

					// Required Indicate if field is required to be filled.
					Required bool `json:"required"`

					// Score Score of a procedure field
					Score *float32 `json:"score,omitempty"`

					// Type Type of procedure field
					Type PatchWorkordersIdStatus200WorkOrderProcedureFieldsType `json:"type"`

					// Value Current value of a procedure field
					Value struct {
						// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
						Attachment *struct {
							// CreatedAt Date & time at which the attachment was uploaded
							CreatedAt time.Time `json:"createdAt"`

							// FileName Attachment's file name
							FileName string `json:"fileName"`

							// Height Height if the file is an image
							Height *float32 `json:"height"`

							// Id Global ID of the attachment
							Id float32 `json:"id"`

							// MimeType MIME type of the file
							MimeType string `json:"mimeType"`

							// Url Url of the file
							Url string `json:"url"`

							// Width Width if the file is an image
							Width *float32 `json:"width"`
						} `json:"attachment,omitempty"`
						Attachments *[]struct {
							// CreatedAt Date & time at which the attachment was uploaded
							CreatedAt time.Time `json:"createdAt"`

							// FileName Attachment's file name
							FileName string `json:"fileName"`

							// Height Height if the file is an image
							Height *float32 `json:"height"`

							// Id Global ID of the attachment
							Id float32 `json:"id"`

							// MimeType MIME type of the file
							MimeType string `json:"mimeType"`

							// Url Url of the file
							Url string `json:"url"`

							// Width Width if the file is an image
							Width *float32 `json:"width"`
						} `json:"attachments,omitempty"`
						HasAttachments *bool `json:"hasAttachments"`

						// Notes Note added to a procedure field
						Notes *struct {
							Text *string `json:"text,omitempty"`
						} `json:"notes"`
						Text *string `json:"text"`
					} `json:"value"`
				} `json:"fields"`

				// Id ID representing a procedure
				Id *float32 `json:"id,omitempty"`

				// MaxScore Maximum score of a procedure
				MaxScore *float32 `json:"maxScore,omitempty"`

				// Score Score of a procedure
				Score *float32 `json:"score,omitempty"`

				// TemplateIds IDs of the procedure template of the procedure
				TemplateIds *[]float32 `json:"templateIds"`

				// Title Title of the procedure
				Title string `json:"title"`
			} `json:"procedure"`

			// Progress Progress information on the work order
			Progress *struct {
				DoneCount       *float32 `json:"doneCount,omitempty"`
				InProgressCount *float32 `json:"inProgressCount,omitempty"`
				OnHoldCount     *float32 `json:"onHoldCount,omitempty"`
				OpenCount       *float32 `json:"openCount,omitempty"`
			} `json:"progress"`
			RecurrenceInfo *PatchWorkordersIdStatus_200_WorkOrder_RecurrenceInfo `json:"recurrenceInfo"`

			// RequesterId ID of the user who requested the work order through the Work Request feature
			RequesterId *int `json:"requesterId"`

			// SequentialId Organization specific ID of the work order
			SequentialId int `json:"sequentialId"`

			// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
			StartDate *time.Time `json:"startDate"`

			// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
			Status PatchWorkordersIdStatus200WorkOrderStatus `json:"status"`

			// TeamIds List of team ids assigned to the work order
			TeamIds   *[]int `json:"teamIds,omitempty"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`
			Title string `json:"title"`

			// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
			UpdatedAt time.Time `json:"updatedAt"`

			// VendorIds Vendor IDs
			VendorIds *[]float32 `json:"vendorIds,omitempty"`
		} `json:"workOrder,omitempty"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                         `json:"error"`
			FieldPath  *string                                        `json:"fieldPath"`
			FieldValue *PatchWorkordersIdStatus_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchWorkordersIdStatus200WorkOrderExternalData0 = map[string]interface{}
type PatchWorkordersIdStatus200WorkOrderExternalData1 = float32
type PatchWorkordersIdStatus200WorkOrderExternalData2 = string
type PatchWorkordersIdStatus_200_WorkOrder_ExternalData struct {
	union json.RawMessage
}
type PatchWorkordersIdStatus200WorkOrderPriority string
type PatchWorkordersIdStatus200WorkOrderProcedureFieldsType string
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo0 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator PatchWorkordersIdStatus200WorkOrderRecurrenceInfo0AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`
	Type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo0Type `json:"type"`
}
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo0AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo0Type string
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo1 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator PatchWorkordersIdStatus200WorkOrderRecurrenceInfo1AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Days Days of the week the event will occur
	Days []PatchWorkordersIdStatus200WorkOrderRecurrenceInfo1Days `json:"days"`

	// Interval Number of weeks between events
	Interval *int                                                   `json:"interval,omitempty"`
	Type     PatchWorkordersIdStatus200WorkOrderRecurrenceInfo1Type `json:"type"`
}
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo1AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo1Days string
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo1Type string
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo2 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator PatchWorkordersIdStatus200WorkOrderRecurrenceInfo2AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Day Day of the month the event will occur
	Day int `json:"day"`

	// Interval Number of months between events
	Interval *int                                                   `json:"interval,omitempty"`
	Type     PatchWorkordersIdStatus200WorkOrderRecurrenceInfo2Type `json:"type"`
}
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo2AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo2Type string
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo3 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator PatchWorkordersIdStatus200WorkOrderRecurrenceInfo3AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Interval Number of years between events
	Interval *int                                                   `json:"interval,omitempty"`
	Type     PatchWorkordersIdStatus200WorkOrderRecurrenceInfo3Type `json:"type"`
}
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo3AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo3Type string
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo4 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator PatchWorkordersIdStatus200WorkOrderRecurrenceInfo4AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Interval Number of seconds between events
	Interval *int                                                   `json:"interval,omitempty"`
	Type     PatchWorkordersIdStatus200WorkOrderRecurrenceInfo4Type `json:"type"`
}
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo4AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type PatchWorkordersIdStatus200WorkOrderRecurrenceInfo4Type string
type PatchWorkordersIdStatus_200_WorkOrder_RecurrenceInfo struct {
	union json.RawMessage
}
type PatchWorkordersIdStatus200WorkOrderStatus string
type PatchWorkordersIdStatus400ErrorsFieldValue0 = string
type PatchWorkordersIdStatus400ErrorsFieldValue1 = float32
type PatchWorkordersIdStatus400ErrorsFieldValue2 = bool
type PatchWorkordersIdStatus_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchWorkordersIdStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchWorkordersIdStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkordersIdSubworkordersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor The cursor to retrieve the next page of Subworkorders.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Subworkorders.
		NextPageUrl   *string `json:"nextPageUrl"`
		Subworkorders []struct {
			// Asset Asset linked to the element (expand with query parameter)
			Asset *struct {
				// CreatedAt Date & time at which the asset was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId ID of the asset creator
				CreatorId *int `json:"creatorId"`

				// CriticalityId ID of the criticality of the asset
				CriticalityId *int    `json:"criticalityId"`
				Description   *string `json:"description"`

				// Id Global ID of the asset
				Id int `json:"id"`

				// LocationId ID of the location where the asset is located
				LocationId *int   `json:"locationId"`
				Name       string `json:"name"`

				// ParentId ID of the parent asset
				ParentId *int `json:"parentId"`

				// SerialNumber Serial number of the asset
				SerialNumber *string `json:"serialNumber"`

				// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"asset"`
			AssetId *int `json:"assetId"`

			// Assignees Either the teamId, the userId or the user email address (expand with query parameter)
			Assignees *[]struct {
				Id   GetWorkordersIdSubworkorders_200_Subworkorders_Assignees_Id `json:"id"`
				Type GetWorkordersIdSubworkorders200SubworkordersAssigneesType   `json:"type"`
			} `json:"assignees,omitempty"`

			// Categories List of categories that identify the work order (expand with query parameter)
			Categories *[]string `json:"categories,omitempty"`

			// CompletedAt Date & time at which the work order was last marked as DONE
			CompletedAt *time.Time `json:"completedAt"`

			// CompleterId ID of the user who completed the work order
			CompleterId *int `json:"completerId"`

			// CreatedAt Date & time at which the work order was created
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// CreatorId ID of the user who created the work order
			CreatorId *int `json:"creatorId"`

			// DeletedAt Date & time at which the work order was deleted
			DeletedAt   *time.Time `json:"deletedAt"`
			Description *string    `json:"description"`

			// DueDate Date & time at which the work order is due
			DueDate *time.Time `json:"dueDate"`

			// EstimatedTime The estimated time taken in seconds to complete the work order (expand with query parameter)
			EstimatedTime *int `json:"estimatedTime"`

			// Expenditures Other cost entries on the Work Order. Grouped by users (expand with query parameter)
			Expenditures *[]struct {
				// CostPerUnit Cost per part in cents or cents per hour
				CostPerUnit *float32 `json:"costPerUnit"`

				// Description Description of the expense or part description
				Description *string `json:"description"`

				// DurationTotal Total duration in seconds
				DurationTotal *float32 `json:"durationTotal,omitempty"`

				// PartId ID of the part used in this cost entry
				PartId *int `json:"partId"`

				// Quantity Number of parts or number of hours
				Quantity *float32 `json:"quantity,omitempty"`

				// RowTotal Total cost in cents
				RowTotal *float32 `json:"rowTotal,omitempty"`

				// Type Type of the entry
				Type *GetWorkordersIdSubworkorders200SubworkordersExpendituresType `json:"type,omitempty"`

				// UserId ID of the user who logged the time entry
				UserId *int `json:"userId"`
			} `json:"expenditures,omitempty"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Budget") (expand with query parameter)
			ExtraFields *map[string]string `json:"extraFields"`

			// Id Global ID of the work order
			Id int `json:"id"`

			// Location Location linked to the element (expand with query parameter)
			Location *struct {
				// Address Postal address of the location
				Address *string `json:"address"`

				// CreatedAt Date & time at which the location was created
				CreatedAt   *time.Time `json:"createdAt,omitempty"`
				Description *string    `json:"description"`

				// Id Global ID of the location
				Id   int    `json:"id"`
				Name string `json:"name"`

				// ParentId ID of the parent location
				ParentId *int `json:"parentId"`

				// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"location"`

			// LocationId Global ID of the location assigned to the work order
			LocationId     *int     `json:"locationId"`
			NextId         *int     `json:"nextId"`
			OrganizationId *float32 `json:"organizationId,omitempty"`

			// Parts Parts attached to the Work Order (expand with query parameter)
			Parts *[]struct {
				Area *string `json:"area"`

				// AvailableQuantity Quantity currently in stock
				AvailableQuantity int `json:"availableQuantity"`

				// Barcode String encoded barcode
				Barcode *string `json:"barcode"`

				// CopyOnRecurring Indicates if the parts will be copied to the next work order in the chain (if applicable).
				CopyOnRecurring GetWorkordersIdSubworkorders200SubworkordersPartsCopyOnRecurring `json:"copyOnRecurring"`
				Description     *string                                                          `json:"description"`
				ExtraFields     *map[string]string                                               `json:"extraFields,omitempty"`

				// Id Global ID of the part
				Id int `json:"id"`

				// LocationId Global ID of the location of the part
				LocationId *float32 `json:"locationId"`

				// MinimumQuantity Minimum quantity before you should restock
				MinimumQuantity int    `json:"minimumQuantity"`
				Name            string `json:"name"`

				// QuantityUsed Quantity used in the work order.
				QuantityUsed int `json:"quantityUsed"`

				// UnitCost Cost in cents. For example, for $1.20, put 120.
				UnitCost *int `json:"unitCost"`
			} `json:"parts,omitempty"`
			PreviousId *int                                                  `json:"previousId"`
			Priority   *GetWorkordersIdSubworkorders200SubworkordersPriority `json:"priority,omitempty"`

			// Procedure Procedure attached to the work order (expand with query parameter)
			Procedure *struct {
				Fields []struct {
					Assignees *struct {
						TeamIds *[]float32 `json:"teamIds,omitempty"`
						UserIds *[]float32 `json:"userIds,omitempty"`
					} `json:"assignees"`

					// Description Description of the procedure field
					Description *string `json:"description"`

					// Id ID of the procedure field
					Id float32 `json:"id"`

					// IsDateAndTime Indicate if a DATE field also contains the time
					IsDateAndTime *bool `json:"isDateAndTime"`

					// Label Label of a procedure field
					Label string `json:"label"`

					// MaxScore Maximum score of a procedure field
					MaxScore *float32 `json:"maxScore,omitempty"`

					// Meter Meter of a procedure field. Will be filled if the type of the field is meter
					Meter *struct {
						// Id Global ID of the meter.
						Id *float32 `json:"id,omitempty"`

						// Name Name of the meters
						Name *string `json:"name,omitempty"`
					} `json:"meter"`

					// ParentId ID of the parent of the current procedure field
					ParentId *float32 `json:"parentId"`

					// Required Indicate if field is required to be filled.
					Required bool `json:"required"`

					// Score Score of a procedure field
					Score *float32 `json:"score,omitempty"`

					// Type Type of procedure field
					Type GetWorkordersIdSubworkorders200SubworkordersProcedureFieldsType `json:"type"`

					// Value Current value of a procedure field
					Value struct {
						// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
						Attachment *struct {
							// CreatedAt Date & time at which the attachment was uploaded
							CreatedAt time.Time `json:"createdAt"`

							// FileName Attachment's file name
							FileName string `json:"fileName"`

							// Height Height if the file is an image
							Height *float32 `json:"height"`

							// Id Global ID of the attachment
							Id float32 `json:"id"`

							// MimeType MIME type of the file
							MimeType string `json:"mimeType"`

							// Url Url of the file
							Url string `json:"url"`

							// Width Width if the file is an image
							Width *float32 `json:"width"`
						} `json:"attachment,omitempty"`
						Attachments *[]struct {
							// CreatedAt Date & time at which the attachment was uploaded
							CreatedAt time.Time `json:"createdAt"`

							// FileName Attachment's file name
							FileName string `json:"fileName"`

							// Height Height if the file is an image
							Height *float32 `json:"height"`

							// Id Global ID of the attachment
							Id float32 `json:"id"`

							// MimeType MIME type of the file
							MimeType string `json:"mimeType"`

							// Url Url of the file
							Url string `json:"url"`

							// Width Width if the file is an image
							Width *float32 `json:"width"`
						} `json:"attachments,omitempty"`
						HasAttachments *bool `json:"hasAttachments"`

						// Notes Note added to a procedure field
						Notes *struct {
							Text *string `json:"text,omitempty"`
						} `json:"notes"`
						Text *string `json:"text"`
					} `json:"value"`
				} `json:"fields"`

				// Id ID representing a procedure
				Id *float32 `json:"id,omitempty"`

				// MaxScore Maximum score of a procedure
				MaxScore *float32 `json:"maxScore,omitempty"`

				// Score Score of a procedure
				Score *float32 `json:"score,omitempty"`

				// TemplateIds IDs of the procedure template of the procedure
				TemplateIds *[]float32 `json:"templateIds"`

				// Title Title of the procedure
				Title string `json:"title"`
			} `json:"procedure"`

			// RequesterId ID of the user who requested the work order through the Work Request feature
			RequesterId *int `json:"requesterId"`

			// SequentialId Organization specific ID of the work order
			SequentialId int `json:"sequentialId"`

			// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
			StartDate *time.Time `json:"startDate"`

			// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
			Status GetWorkordersIdSubworkorders200SubworkordersStatus `json:"status"`

			// TimeItems Time entries on the Work Order. (expand with query parameter)
			TimeItems *[]struct {
				// CostPerUnit Cost per part in cents or cents per hour
				CostPerUnit *float32 `json:"costPerUnit"`

				// Description Description of the expense or part description
				Description *string `json:"description"`

				// DurationTotal Total duration in seconds
				DurationTotal *float32 `json:"durationTotal,omitempty"`

				// PartId ID of the part used in this cost entry
				PartId *int `json:"partId"`

				// Quantity Number of parts or number of hours
				Quantity *float32 `json:"quantity,omitempty"`

				// RowTotal Total cost in cents
				RowTotal *float32 `json:"rowTotal,omitempty"`

				// Type Type of the entry
				Type *GetWorkordersIdSubworkorders200SubworkordersTimeItemsType `json:"type,omitempty"`

				// UserId ID of the user who logged the time entry
				UserId *int `json:"userId"`
			} `json:"timeItems,omitempty"`

			// Times Time entries on the Work Order. Grouped by users (expand with query parameter)
			Times *[]struct {
				// CostPerUnit Cost per part in cents or cents per hour
				CostPerUnit *float32 `json:"costPerUnit"`

				// Description Description of the expense or part description
				Description *string `json:"description"`

				// DurationTotal Total duration in seconds
				DurationTotal *float32 `json:"durationTotal,omitempty"`

				// PartId ID of the part used in this cost entry
				PartId *int `json:"partId"`

				// Quantity Number of parts or number of hours
				Quantity *float32 `json:"quantity,omitempty"`

				// RowTotal Total cost in cents
				RowTotal *float32 `json:"rowTotal,omitempty"`

				// Type Type of the entry
				Type *GetWorkordersIdSubworkorders200SubworkordersTimesType `json:"type,omitempty"`

				// UserId ID of the user who logged the time entry
				UserId *int `json:"userId"`
			} `json:"times,omitempty"`
			Title string `json:"title"`

			// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
			UpdatedAt time.Time `json:"updatedAt"`
		} `json:"subworkorders"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}
type GetWorkordersIdSubworkorders200SubworkordersAssigneesId0 = int
type GetWorkordersIdSubworkorders200SubworkordersAssigneesId1 = string
type GetWorkordersIdSubworkorders_200_Subworkorders_Assignees_Id struct {
	union json.RawMessage
}
type GetWorkordersIdSubworkorders200SubworkordersAssigneesType string
type GetWorkordersIdSubworkorders200SubworkordersExpendituresType string
type GetWorkordersIdSubworkorders200SubworkordersPartsCopyOnRecurring string
type GetWorkordersIdSubworkorders200SubworkordersPriority string
type GetWorkordersIdSubworkorders200SubworkordersProcedureFieldsType string
type GetWorkordersIdSubworkorders200SubworkordersStatus string
type GetWorkordersIdSubworkorders200SubworkordersTimeItemsType string
type GetWorkordersIdSubworkorders200SubworkordersTimesType string

// Status returns HTTPResponse.Status
func (r GetWorkordersIdSubworkordersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkordersIdSubworkordersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutWorkordersIdThumbnailFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                                  `json:"error"`
			FieldPath  *string                                                 `json:"fieldPath"`
			FieldValue *PutWorkordersIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}
type PutWorkordersIdThumbnailFilename400ErrorsFieldValue0 = string
type PutWorkordersIdThumbnailFilename400ErrorsFieldValue1 = float32
type PutWorkordersIdThumbnailFilename400ErrorsFieldValue2 = bool
type PutWorkordersIdThumbnailFilename_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PutWorkordersIdThumbnailFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutWorkordersIdThumbnailFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkrequestportalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor The cursor to retrieve the next page of Work Request Portals.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Work Request Portals.
		NextPageUrl        *string `json:"nextPageUrl"`
		WorkRequestPortals []struct {
			// AssetId ID of the asset related to the portal
			AssetId *int `json:"assetId"`

			// ContactInformation Contact of the person creating the portal (email or phone number)
			ContactInformation *string `json:"contactInformation"`

			// DescriptionPlaceholder Placeholder text for the description field
			DescriptionPlaceholder *string `json:"descriptionPlaceholder"`

			// EmailOnly Allow request creation with email only to contact the requester
			EmailOnly *bool `json:"emailOnly"`

			// Id Global ID of the portal
			Id int `json:"id"`

			// LocationId ID of the location where the portal is located
			LocationId *int `json:"locationId"`

			// PortalUrl Url to access the portal
			PortalUrl string `json:"portalUrl"`

			// SendEmailNotification Send email notifications to the portal requesters with status updates on their requests
			SendEmailNotification *bool `json:"sendEmailNotification"`

			// Title Title of the portal
			Title string `json:"title"`

			// WelcomeText Description text describing the portal
			WelcomeText *string `json:"welcomeText"`
		} `json:"workRequestPortals"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWorkrequestportalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkrequestportalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWorkrequestportalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id Global ID of the portal
		Id int `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                        `json:"error"`
			FieldPath  *string                                       `json:"fieldPath"`
			FieldValue *PostWorkrequestportals_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON403 *struct {
		Errors []struct {
			Error      string                                        `json:"error"`
			FieldPath  *string                                       `json:"fieldPath"`
			FieldValue *PostWorkrequestportals_403_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostWorkrequestportals400ErrorsFieldValue0 = string
type PostWorkrequestportals400ErrorsFieldValue1 = float32
type PostWorkrequestportals400ErrorsFieldValue2 = bool
type PostWorkrequestportals_400_Errors_FieldValue struct {
	union json.RawMessage
}
type PostWorkrequestportals403ErrorsFieldValue0 = string
type PostWorkrequestportals403ErrorsFieldValue1 = float32
type PostWorkrequestportals403ErrorsFieldValue2 = bool
type PostWorkrequestportals_403_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostWorkrequestportalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWorkrequestportalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkrequestportalsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                            `json:"error"`
			FieldPath  *string                                           `json:"fieldPath"`
			FieldValue *DeleteWorkrequestportalsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteWorkrequestportalsId400ErrorsFieldValue0 = string
type DeleteWorkrequestportalsId400ErrorsFieldValue1 = float32
type DeleteWorkrequestportalsId400ErrorsFieldValue2 = bool
type DeleteWorkrequestportalsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteWorkrequestportalsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkrequestportalsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkrequestportalsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		WorkRequestPortal struct {
			// AssetId ID of the asset related to the portal
			AssetId *int `json:"assetId"`

			// ContactInformation Contact of the person creating the portal (email or phone number)
			ContactInformation *string `json:"contactInformation"`

			// DescriptionPlaceholder Placeholder text for the description field
			DescriptionPlaceholder *string `json:"descriptionPlaceholder"`

			// EmailOnly Allow request creation with email only to contact the requester
			EmailOnly *bool `json:"emailOnly"`

			// Id Global ID of the portal
			Id int `json:"id"`

			// LocationId ID of the location where the portal is located
			LocationId *int `json:"locationId"`

			// PortalUrl Url to access the portal
			PortalUrl *string `json:"portalUrl,omitempty"`

			// SendEmailNotification Send email notifications to the portal requesters with status updates on their requests
			SendEmailNotification *bool `json:"sendEmailNotification"`

			// Title Title of the portal
			Title *string `json:"title,omitempty"`

			// WelcomeText Description text describing the portal
			WelcomeText *string `json:"welcomeText"`
		} `json:"workRequestPortal"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWorkrequestportalsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkrequestportalsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchWorkrequestportalsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		WorkRequestPortal struct {
			// AssetId ID of the asset related to the portal
			AssetId *int `json:"assetId"`

			// ContactInformation Contact of the person creating the portal (email or phone number)
			ContactInformation *string `json:"contactInformation"`

			// DescriptionPlaceholder Placeholder text for the description field
			DescriptionPlaceholder *string `json:"descriptionPlaceholder"`

			// EmailOnly Allow request creation with email only to contact the requester
			EmailOnly *bool `json:"emailOnly"`

			// Id Global ID of the portal
			Id int `json:"id"`

			// LocationId ID of the location where the portal is located
			LocationId *int `json:"locationId"`

			// PortalUrl Url to access the portal
			PortalUrl *string `json:"portalUrl,omitempty"`

			// SendEmailNotification Send email notifications to the portal requesters with status updates on their requests
			SendEmailNotification *bool `json:"sendEmailNotification"`

			// Title Title of the portal
			Title string `json:"title"`

			// WelcomeText Description text describing the portal
			WelcomeText *string `json:"welcomeText"`
		} `json:"workRequestPortal"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                           `json:"error"`
			FieldPath  *string                                          `json:"fieldPath"`
			FieldValue *PatchWorkrequestportalsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchWorkrequestportalsId400ErrorsFieldValue0 = string
type PatchWorkrequestportalsId400ErrorsFieldValue1 = float32
type PatchWorkrequestportalsId400ErrorsFieldValue2 = bool
type PatchWorkrequestportalsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchWorkrequestportalsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchWorkrequestportalsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkrequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextCursor The cursor to retrieve the next page of Work Requests.
		NextCursor *string `json:"nextCursor"`

		// NextPageUrl Path with query parameters that can be used to retrieve the next page of Work Requests.
		NextPageUrl  *string `json:"nextPageUrl"`
		WorkRequests []struct {
			// ApproverTeamId ID of the team that is reponsible for approving the request.
			ApproverTeamId *float32 `json:"approverTeamId"`

			// Asset Asset linked to the element (expand with query parameter)
			Asset *struct {
				// CreatedAt Date & time at which the asset was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId ID of the asset creator
				CreatorId *int `json:"creatorId"`

				// CriticalityId ID of the criticality of the asset
				CriticalityId *int    `json:"criticalityId"`
				Description   *string `json:"description"`

				// Id Global ID of the asset
				Id int `json:"id"`

				// LocationId ID of the location where the asset is located
				LocationId *int   `json:"locationId"`
				Name       string `json:"name"`

				// ParentId ID of the parent asset
				ParentId *int `json:"parentId"`

				// SerialNumber Serial number of the asset
				SerialNumber *string `json:"serialNumber"`

				// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"asset,omitempty"`
			AssetId *float32 `json:"assetId"`

			// Attachments List of attachments linked to the Work Request
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// CreatedAt Date & time at which the work request was created
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// CreatorContactInfo The creator's contact information associated with this work order request
			CreatorContactInfo *struct {
				Type  *GetWorkrequests200WorkRequestsCreatorContactInfoType `json:"type,omitempty"`
				Value *string                                               `json:"value,omitempty"`
			} `json:"creatorContactInfo"`
			Description *string `json:"description"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Request Type") (expand with query parameter)
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the work request
			Id float32 `json:"id"`

			// Location Location linked to the element (expand with query parameter)
			Location *struct {
				// Address Postal address of the location
				Address *string `json:"address"`

				// CreatedAt Date & time at which the location was created
				CreatedAt   *time.Time `json:"createdAt,omitempty"`
				Description *string    `json:"description"`

				// Id Global ID of the location
				Id   int    `json:"id"`
				Name string `json:"name"`

				// ParentId ID of the parent location
				ParentId *int `json:"parentId"`

				// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"location,omitempty"`
			LocationId            *float32                                    `json:"locationId"`
			Priority              GetWorkrequests200WorkRequestsPriority      `json:"priority"`
			RequestStatus         GetWorkrequests200WorkRequestsRequestStatus `json:"requestStatus"`
			SendEmailNotification *bool                                       `json:"sendEmailNotification,omitempty"`
			Thumbnail             *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`
			Title string `json:"title"`

			// UpdatedAt Date & time at which the work request was last updated
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`

			// WorkOrder Work Order linked to the element (expand with query parameter)
			WorkOrder *struct {
				AssetId *int `json:"assetId"`

				// AssigneeIds List of user ids assigned to the work order
				AssigneeIds *[]int `json:"assigneeIds,omitempty"`

				// Attachments List of attachments linked to the work order
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// Categories List of categories that identify the work order
				Categories *[]string `json:"categories,omitempty"`

				// CompletedAt Date & time at which the work order was last marked as DONE
				CompletedAt *time.Time `json:"completedAt"`

				// CompleterId ID of the user who completed the work order
				CompleterId *int `json:"completerId"`

				// CreatedAt Date & time at which the work order was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId ID of the user who created the work order
				CreatorId *int `json:"creatorId"`

				// DeletedAt Date & time at which the work order was deleted
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// DueDate Date & time at which the work order is due
				DueDate          *time.Time `json:"dueDate"`
				DueDateIsFullDay *bool      `json:"dueDateIsFullDay"`

				// EstimatedTime The estimated time taken in seconds to complete the work order
				EstimatedTime *int `json:"estimatedTime"`

				// ExternalData Extra data that can be attached to the work order, for example to help reference to a matching record in an external system.
				ExternalData *GetWorkrequests_200_WorkRequests_WorkOrder_ExternalData `json:"externalData"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Time Allotted")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the work order
				Id int `json:"id"`

				// IsParent If this is a parent work order
				IsParent *bool `json:"isParent"`

				// LocationId Global ID of the location assigned to the work order
				LocationId     *int    `json:"locationId"`
				NextId         *int    `json:"nextId"`
				OrganizationId float32 `json:"organizationId"`

				// ParentId The ID of the parent work order
				ParentId   *int                                             `json:"parentId"`
				PreviousId *int                                             `json:"previousId"`
				Priority   *GetWorkrequests200WorkRequestsWorkOrderPriority `json:"priority,omitempty"`

				// Procedure Procedure attached to the work order
				Procedure *struct {
					Fields []struct {
						Assignees *struct {
							TeamIds *[]float32 `json:"teamIds,omitempty"`
							UserIds *[]float32 `json:"userIds,omitempty"`
						} `json:"assignees"`

						// Description Description of the procedure field
						Description *string `json:"description"`

						// Id ID of the procedure field
						Id float32 `json:"id"`

						// IsDateAndTime Indicate if a DATE field also contains the time
						IsDateAndTime *bool `json:"isDateAndTime"`

						// Label Label of a procedure field
						Label string `json:"label"`

						// MaxScore Maximum score of a procedure field
						MaxScore *float32 `json:"maxScore,omitempty"`

						// Meter Meter of a procedure field. Will be filled if the type of the field is meter
						Meter *struct {
							// Id Global ID of the meter.
							Id *float32 `json:"id,omitempty"`

							// Name Name of the meters
							Name *string `json:"name,omitempty"`
						} `json:"meter"`

						// ParentId ID of the parent of the current procedure field
						ParentId *float32 `json:"parentId"`

						// Required Indicate if field is required to be filled.
						Required bool `json:"required"`

						// Score Score of a procedure field
						Score *float32 `json:"score,omitempty"`

						// Type Type of procedure field
						Type GetWorkrequests200WorkRequestsWorkOrderProcedureFieldsType `json:"type"`

						// Value Current value of a procedure field
						Value struct {
							// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
							Attachment *struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachment,omitempty"`
							Attachments *[]struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachments,omitempty"`
							HasAttachments *bool `json:"hasAttachments"`

							// Notes Note added to a procedure field
							Notes *struct {
								Text *string `json:"text,omitempty"`
							} `json:"notes"`
							Text *string `json:"text"`
						} `json:"value"`
					} `json:"fields"`

					// Id ID representing a procedure
					Id *float32 `json:"id,omitempty"`

					// MaxScore Maximum score of a procedure
					MaxScore *float32 `json:"maxScore,omitempty"`

					// Score Score of a procedure
					Score *float32 `json:"score,omitempty"`

					// TemplateIds IDs of the procedure template of the procedure
					TemplateIds *[]float32 `json:"templateIds"`

					// Title Title of the procedure
					Title string `json:"title"`
				} `json:"procedure"`

				// Progress Progress information on the work order
				Progress *struct {
					DoneCount       *float32 `json:"doneCount,omitempty"`
					InProgressCount *float32 `json:"inProgressCount,omitempty"`
					OnHoldCount     *float32 `json:"onHoldCount,omitempty"`
					OpenCount       *float32 `json:"openCount,omitempty"`
				} `json:"progress"`
				RecurrenceInfo *GetWorkrequests_200_WorkRequests_WorkOrder_RecurrenceInfo `json:"recurrenceInfo"`

				// RequesterId ID of the user who requested the work order through the Work Request feature
				RequesterId *int `json:"requesterId"`

				// SequentialId Organization specific ID of the work order
				SequentialId int `json:"sequentialId"`

				// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
				StartDate *time.Time `json:"startDate"`

				// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
				Status GetWorkrequests200WorkRequestsWorkOrderStatus `json:"status"`

				// TeamIds List of team ids assigned to the work order
				TeamIds   *[]int `json:"teamIds,omitempty"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`
				Title string `json:"title"`

				// Type Valid types of Work Orders, including options that are not available for creation/update. Historical Work Orders may have a null type.
				Type *GetWorkrequests200WorkRequestsWorkOrderType `json:"type"`

				// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`

				// VendorIds Vendor IDs
				VendorIds *[]float32 `json:"vendorIds,omitempty"`
			} `json:"workOrder,omitempty"`

			// WorkOrderId Global ID of the work order attached to the work request. A work order is created once a work request is approved.
			WorkOrderId *float32 `json:"workOrderId"`
		} `json:"workRequests"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
}
type GetWorkrequests200WorkRequestsCreatorContactInfoType string
type GetWorkrequests200WorkRequestsPriority string
type GetWorkrequests200WorkRequestsRequestStatus string
type GetWorkrequests200WorkRequestsWorkOrderExternalData0 = map[string]interface{}
type GetWorkrequests200WorkRequestsWorkOrderExternalData1 = float32
type GetWorkrequests200WorkRequestsWorkOrderExternalData2 = string
type GetWorkrequests_200_WorkRequests_WorkOrder_ExternalData struct {
	union json.RawMessage
}
type GetWorkrequests200WorkRequestsWorkOrderPriority string
type GetWorkrequests200WorkRequestsWorkOrderProcedureFieldsType string
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo0 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo0AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`
	Type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo0Type `json:"type"`
}
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo0AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo0Type string
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo1 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo1AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Days Days of the week the event will occur
	Days []GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo1Days `json:"days"`

	// Interval Number of weeks between events
	Interval *int                                                       `json:"interval,omitempty"`
	Type     GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo1Type `json:"type"`
}
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo1AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo1Days string
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo1Type string
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo2 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo2AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Day Day of the month the event will occur
	Day int `json:"day"`

	// Interval Number of months between events
	Interval *int                                                       `json:"interval,omitempty"`
	Type     GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo2Type `json:"type"`
}
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo2AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo2Type string
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo3 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo3AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Interval Number of years between events
	Interval *int                                                       `json:"interval,omitempty"`
	Type     GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo3Type `json:"type"`
}
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo3AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo3Type string
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo4 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo4AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Interval Number of seconds between events
	Interval *int                                                       `json:"interval,omitempty"`
	Type     GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo4Type `json:"type"`
}
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo4AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkrequests200WorkRequestsWorkOrderRecurrenceInfo4Type string
type GetWorkrequests_200_WorkRequests_WorkOrder_RecurrenceInfo struct {
	union json.RawMessage
}
type GetWorkrequests200WorkRequestsWorkOrderStatus string
type GetWorkrequests200WorkRequestsWorkOrderType string

// Status returns HTTPResponse.Status
func (r GetWorkrequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkrequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWorkrequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id Global ID of the work request
		Id float32 `json:"id"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                  `json:"error"`
			FieldPath  *string                                 `json:"fieldPath"`
			FieldValue *PostWorkrequests_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
}
type PostWorkrequests400ErrorsFieldValue0 = string
type PostWorkrequests400ErrorsFieldValue1 = float32
type PostWorkrequests400ErrorsFieldValue2 = bool
type PostWorkrequests_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostWorkrequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWorkrequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkrequestsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Errors []struct {
			Error      string                                      `json:"error"`
			FieldPath  *string                                     `json:"fieldPath"`
			FieldValue *DeleteWorkrequestsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type DeleteWorkrequestsId400ErrorsFieldValue0 = string
type DeleteWorkrequestsId400ErrorsFieldValue1 = float32
type DeleteWorkrequestsId400ErrorsFieldValue2 = bool
type DeleteWorkrequestsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteWorkrequestsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkrequestsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkrequestsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		WorkRequest struct {
			// ApproverTeamId ID of the team that is reponsible for approving the request.
			ApproverTeamId *float32 `json:"approverTeamId"`

			// Asset Asset linked to the element (expand with query parameter)
			Asset *struct {
				// CreatedAt Date & time at which the asset was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId ID of the asset creator
				CreatorId *int `json:"creatorId"`

				// CriticalityId ID of the criticality of the asset
				CriticalityId *int    `json:"criticalityId"`
				Description   *string `json:"description"`

				// Id Global ID of the asset
				Id int `json:"id"`

				// LocationId ID of the location where the asset is located
				LocationId *int   `json:"locationId"`
				Name       string `json:"name"`

				// ParentId ID of the parent asset
				ParentId *int `json:"parentId"`

				// SerialNumber Serial number of the asset
				SerialNumber *string `json:"serialNumber"`

				// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"asset,omitempty"`
			AssetId *float32 `json:"assetId"`

			// Attachments List of attachments linked to the Work Request
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// CreatedAt Date & time at which the work request was created
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// CreatorContactInfo The creator's contact information associated with this work order request
			CreatorContactInfo *struct {
				Type  *GetWorkrequestsId200WorkRequestCreatorContactInfoType `json:"type,omitempty"`
				Value *string                                                `json:"value,omitempty"`
			} `json:"creatorContactInfo"`
			Description *string `json:"description"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Request Type") (expand with query parameter)
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the work request
			Id float32 `json:"id"`

			// Location Location linked to the element (expand with query parameter)
			Location *struct {
				// Address Postal address of the location
				Address *string `json:"address"`

				// CreatedAt Date & time at which the location was created
				CreatedAt   *time.Time `json:"createdAt,omitempty"`
				Description *string    `json:"description"`

				// Id Global ID of the location
				Id   int    `json:"id"`
				Name string `json:"name"`

				// ParentId ID of the parent location
				ParentId *int `json:"parentId"`

				// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"location,omitempty"`
			LocationId            *float32                                     `json:"locationId"`
			Priority              GetWorkrequestsId200WorkRequestPriority      `json:"priority"`
			RequestStatus         GetWorkrequestsId200WorkRequestRequestStatus `json:"requestStatus"`
			SendEmailNotification *bool                                        `json:"sendEmailNotification,omitempty"`
			Thumbnail             *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`
			Title string `json:"title"`

			// UpdatedAt Date & time at which the work request was last updated
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`

			// WorkOrder Work Order linked to the element (expand with query parameter)
			WorkOrder *struct {
				AssetId *int `json:"assetId"`

				// AssigneeIds List of user ids assigned to the work order
				AssigneeIds *[]int `json:"assigneeIds,omitempty"`

				// Attachments List of attachments linked to the work order
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// Categories List of categories that identify the work order
				Categories *[]string `json:"categories,omitempty"`

				// CompletedAt Date & time at which the work order was last marked as DONE
				CompletedAt *time.Time `json:"completedAt"`

				// CompleterId ID of the user who completed the work order
				CompleterId *int `json:"completerId"`

				// CreatedAt Date & time at which the work order was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId ID of the user who created the work order
				CreatorId *int `json:"creatorId"`

				// DeletedAt Date & time at which the work order was deleted
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// DueDate Date & time at which the work order is due
				DueDate          *time.Time `json:"dueDate"`
				DueDateIsFullDay *bool      `json:"dueDateIsFullDay"`

				// EstimatedTime The estimated time taken in seconds to complete the work order
				EstimatedTime *int `json:"estimatedTime"`

				// ExternalData Extra data that can be attached to the work order, for example to help reference to a matching record in an external system.
				ExternalData *GetWorkrequestsId_200_WorkRequest_WorkOrder_ExternalData `json:"externalData"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Time Allotted")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the work order
				Id int `json:"id"`

				// IsParent If this is a parent work order
				IsParent *bool `json:"isParent"`

				// LocationId Global ID of the location assigned to the work order
				LocationId     *int    `json:"locationId"`
				NextId         *int    `json:"nextId"`
				OrganizationId float32 `json:"organizationId"`

				// ParentId The ID of the parent work order
				ParentId   *int                                              `json:"parentId"`
				PreviousId *int                                              `json:"previousId"`
				Priority   *GetWorkrequestsId200WorkRequestWorkOrderPriority `json:"priority,omitempty"`

				// Procedure Procedure attached to the work order
				Procedure *struct {
					Fields []struct {
						Assignees *struct {
							TeamIds *[]float32 `json:"teamIds,omitempty"`
							UserIds *[]float32 `json:"userIds,omitempty"`
						} `json:"assignees"`

						// Description Description of the procedure field
						Description *string `json:"description"`

						// Id ID of the procedure field
						Id float32 `json:"id"`

						// IsDateAndTime Indicate if a DATE field also contains the time
						IsDateAndTime *bool `json:"isDateAndTime"`

						// Label Label of a procedure field
						Label string `json:"label"`

						// MaxScore Maximum score of a procedure field
						MaxScore *float32 `json:"maxScore,omitempty"`

						// Meter Meter of a procedure field. Will be filled if the type of the field is meter
						Meter *struct {
							// Id Global ID of the meter.
							Id *float32 `json:"id,omitempty"`

							// Name Name of the meters
							Name *string `json:"name,omitempty"`
						} `json:"meter"`

						// ParentId ID of the parent of the current procedure field
						ParentId *float32 `json:"parentId"`

						// Required Indicate if field is required to be filled.
						Required bool `json:"required"`

						// Score Score of a procedure field
						Score *float32 `json:"score,omitempty"`

						// Type Type of procedure field
						Type GetWorkrequestsId200WorkRequestWorkOrderProcedureFieldsType `json:"type"`

						// Value Current value of a procedure field
						Value struct {
							// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
							Attachment *struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachment,omitempty"`
							Attachments *[]struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachments,omitempty"`
							HasAttachments *bool `json:"hasAttachments"`

							// Notes Note added to a procedure field
							Notes *struct {
								Text *string `json:"text,omitempty"`
							} `json:"notes"`
							Text *string `json:"text"`
						} `json:"value"`
					} `json:"fields"`

					// Id ID representing a procedure
					Id *float32 `json:"id,omitempty"`

					// MaxScore Maximum score of a procedure
					MaxScore *float32 `json:"maxScore,omitempty"`

					// Score Score of a procedure
					Score *float32 `json:"score,omitempty"`

					// TemplateIds IDs of the procedure template of the procedure
					TemplateIds *[]float32 `json:"templateIds"`

					// Title Title of the procedure
					Title string `json:"title"`
				} `json:"procedure"`

				// Progress Progress information on the work order
				Progress *struct {
					DoneCount       *float32 `json:"doneCount,omitempty"`
					InProgressCount *float32 `json:"inProgressCount,omitempty"`
					OnHoldCount     *float32 `json:"onHoldCount,omitempty"`
					OpenCount       *float32 `json:"openCount,omitempty"`
				} `json:"progress"`
				RecurrenceInfo *GetWorkrequestsId_200_WorkRequest_WorkOrder_RecurrenceInfo `json:"recurrenceInfo"`

				// RequesterId ID of the user who requested the work order through the Work Request feature
				RequesterId *int `json:"requesterId"`

				// SequentialId Organization specific ID of the work order
				SequentialId int `json:"sequentialId"`

				// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
				StartDate *time.Time `json:"startDate"`

				// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
				Status GetWorkrequestsId200WorkRequestWorkOrderStatus `json:"status"`

				// TeamIds List of team ids assigned to the work order
				TeamIds   *[]int `json:"teamIds,omitempty"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`
				Title string `json:"title"`

				// Type Valid types of Work Orders, including options that are not available for creation/update. Historical Work Orders may have a null type.
				Type *GetWorkrequestsId200WorkRequestWorkOrderType `json:"type"`

				// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`

				// VendorIds Vendor IDs
				VendorIds *[]float32 `json:"vendorIds,omitempty"`
			} `json:"workOrder,omitempty"`

			// WorkOrderId Global ID of the work order attached to the work request. A work order is created once a work request is approved.
			WorkOrderId *float32 `json:"workOrderId"`
		} `json:"workRequest"`
	}
	JSON400 *struct {
		// Error Description of error
		Error string `json:"error"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type GetWorkrequestsId200WorkRequestCreatorContactInfoType string
type GetWorkrequestsId200WorkRequestPriority string
type GetWorkrequestsId200WorkRequestRequestStatus string
type GetWorkrequestsId200WorkRequestWorkOrderExternalData0 = map[string]interface{}
type GetWorkrequestsId200WorkRequestWorkOrderExternalData1 = float32
type GetWorkrequestsId200WorkRequestWorkOrderExternalData2 = string
type GetWorkrequestsId_200_WorkRequest_WorkOrder_ExternalData struct {
	union json.RawMessage
}
type GetWorkrequestsId200WorkRequestWorkOrderPriority string
type GetWorkrequestsId200WorkRequestWorkOrderProcedureFieldsType string
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo0 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo0AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`
	Type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo0Type `json:"type"`
}
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo0AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo0Type string
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo1 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo1AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Days Days of the week the event will occur
	Days []GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo1Days `json:"days"`

	// Interval Number of weeks between events
	Interval *int                                                        `json:"interval,omitempty"`
	Type     GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo1Type `json:"type"`
}
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo1AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo1Days string
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo1Type string
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo2 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo2AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Day Day of the month the event will occur
	Day int `json:"day"`

	// Interval Number of months between events
	Interval *int                                                        `json:"interval,omitempty"`
	Type     GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo2Type `json:"type"`
}
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo2AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo2Type string
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo3 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo3AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Interval Number of years between events
	Interval *int                                                        `json:"interval,omitempty"`
	Type     GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo3Type `json:"type"`
}
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo3AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo3Type string
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo4 struct {
	// AutomationMeterTrigger Automation meter trigger configuration
	AutomationMeterTrigger *struct {
		AutomationTriggerInput *struct {
			// Conditions Conditions to trigger automation
			Conditions []struct {
				// Operator Operator for the condition
				Operator GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo4AutomationMeterTriggerAutomationTriggerInputConditionsOperator `json:"operator"`

				// Value Value for the condition
				Value float32 `json:"value"`
			} `json:"conditions"`

			// MeterId ID of the meter to trigger the automation
			MeterId int `json:"meterId"`
		} `json:"automationTriggerInput,omitempty"`

		// LastTriggerValue Last trigger value for the meter
		LastTriggerValue *float32 `json:"lastTriggerValue,omitempty"`

		// NewDueDateOffsetSeconds Offset in seconds for new due date. If you want to set the due date to 2 days from now set this to 172800 - (24 * 60 * 60 * 2)
		NewDueDateOffsetSeconds *int `json:"newDueDateOffsetSeconds,omitempty"`
	} `json:"automationMeterTrigger"`

	// Interval Number of seconds between events
	Interval *int                                                        `json:"interval,omitempty"`
	Type     GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo4Type `json:"type"`
}
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo4AutomationMeterTriggerAutomationTriggerInputConditionsOperator string
type GetWorkrequestsId200WorkRequestWorkOrderRecurrenceInfo4Type string
type GetWorkrequestsId_200_WorkRequest_WorkOrder_RecurrenceInfo struct {
	union json.RawMessage
}
type GetWorkrequestsId200WorkRequestWorkOrderStatus string
type GetWorkrequestsId200WorkRequestWorkOrderType string

// Status returns HTTPResponse.Status
func (r GetWorkrequestsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkrequestsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchWorkrequestsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		WorkRequest struct {
			// ApproverTeamId ID of the team that is reponsible for approving the request.
			ApproverTeamId *float32 `json:"approverTeamId"`
			AssetId        *float32 `json:"assetId"`

			// Attachments List of attachments linked to the Work Request
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// CreatedAt Date & time at which the work request was created
			CreatedAt *time.Time `json:"createdAt,omitempty"`

			// CreatorContactInfo The creator's contact information associated with this work order request
			CreatorContactInfo *struct {
				Type  *PatchWorkrequestsId200WorkRequestCreatorContactInfoType `json:"type,omitempty"`
				Value *string                                                  `json:"value,omitempty"`
			} `json:"creatorContactInfo"`
			Description *string `json:"description"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Request Type")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the work request
			Id                    float32                                        `json:"id"`
			LocationId            *float32                                       `json:"locationId"`
			Priority              PatchWorkrequestsId200WorkRequestPriority      `json:"priority"`
			RequestStatus         PatchWorkrequestsId200WorkRequestRequestStatus `json:"requestStatus"`
			SendEmailNotification *bool                                          `json:"sendEmailNotification,omitempty"`
			Thumbnail             *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`
			Title string `json:"title"`

			// UpdatedAt Date & time at which the work request was last updated
			UpdatedAt *time.Time `json:"updatedAt,omitempty"`

			// WorkOrderId Global ID of the work order attached to the work request. A work order is created once a work request is approved.
			WorkOrderId *float32 `json:"workOrderId"`
		} `json:"workRequest"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                     `json:"error"`
			FieldPath  *string                                    `json:"fieldPath"`
			FieldValue *PatchWorkrequestsId_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
}
type PatchWorkrequestsId200WorkRequestCreatorContactInfoType string
type PatchWorkrequestsId200WorkRequestPriority string
type PatchWorkrequestsId200WorkRequestRequestStatus string
type PatchWorkrequestsId400ErrorsFieldValue0 = string
type PatchWorkrequestsId400ErrorsFieldValue1 = float32
type PatchWorkrequestsId400ErrorsFieldValue2 = bool
type PatchWorkrequestsId_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PatchWorkrequestsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchWorkrequestsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkrequestsIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteWorkrequestsIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkrequestsIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutWorkrequestsIdAttachmentsFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *string
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r PutWorkrequestsIdAttachmentsFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutWorkrequestsIdAttachmentsFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutWorkrequestsIdThumbnailFilenameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		FileKey   *string `json:"fileKey,omitempty"`
		Filename  *string `json:"filename,omitempty"`
		PublicUrl *string `json:"publicUrl,omitempty"`
	}
	JSON400 *struct {
		Errors []struct {
			Error      string                                                    `json:"error"`
			FieldPath  *string                                                   `json:"fieldPath"`
			FieldValue *PutWorkrequestsIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
		} `json:"errors"`
	}
	JSON404 *struct {
		Error string `json:"error"`
	}
	JSON413 *struct {
		Error string `json:"error"`
	}
}
type PutWorkrequestsIdThumbnailFilename400ErrorsFieldValue0 = string
type PutWorkrequestsIdThumbnailFilename400ErrorsFieldValue1 = float32
type PutWorkrequestsIdThumbnailFilename400ErrorsFieldValue2 = bool
type PutWorkrequestsIdThumbnailFilename_400_Errors_FieldValue struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PutWorkrequestsIdThumbnailFilenameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutWorkrequestsIdThumbnailFilenameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAssetcriticalitiesWithResponse request returning *GetAssetcriticalitiesResponse
func (c *ClientWithResponses) GetAssetcriticalitiesWithResponse(ctx context.Context, params *GetAssetcriticalitiesParams, reqEditors ...RequestEditorFn) (*GetAssetcriticalitiesResponse, error) {
	rsp, err := c.GetAssetcriticalities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetcriticalitiesResponse(rsp)
}

// GetAssetcriticalitiesIdWithResponse request returning *GetAssetcriticalitiesIdResponse
func (c *ClientWithResponses) GetAssetcriticalitiesIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAssetcriticalitiesIdResponse, error) {
	rsp, err := c.GetAssetcriticalitiesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetcriticalitiesIdResponse(rsp)
}

// GetAssetcustomstatusesWithResponse request returning *GetAssetcustomstatusesResponse
func (c *ClientWithResponses) GetAssetcustomstatusesWithResponse(ctx context.Context, params *GetAssetcustomstatusesParams, reqEditors ...RequestEditorFn) (*GetAssetcustomstatusesResponse, error) {
	rsp, err := c.GetAssetcustomstatuses(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetcustomstatusesResponse(rsp)
}

// PostAssetcustomstatusesWithBodyWithResponse request with arbitrary body returning *PostAssetcustomstatusesResponse
func (c *ClientWithResponses) PostAssetcustomstatusesWithBodyWithResponse(ctx context.Context, params *PostAssetcustomstatusesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAssetcustomstatusesResponse, error) {
	rsp, err := c.PostAssetcustomstatusesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAssetcustomstatusesResponse(rsp)
}

func (c *ClientWithResponses) PostAssetcustomstatusesWithResponse(ctx context.Context, params *PostAssetcustomstatusesParams, body PostAssetcustomstatusesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAssetcustomstatusesResponse, error) {
	rsp, err := c.PostAssetcustomstatuses(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAssetcustomstatusesResponse(rsp)
}

// DeleteAssetcustomstatusesIdWithResponse request returning *DeleteAssetcustomstatusesIdResponse
func (c *ClientWithResponses) DeleteAssetcustomstatusesIdWithResponse(ctx context.Context, id int, params *DeleteAssetcustomstatusesIdParams, reqEditors ...RequestEditorFn) (*DeleteAssetcustomstatusesIdResponse, error) {
	rsp, err := c.DeleteAssetcustomstatusesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAssetcustomstatusesIdResponse(rsp)
}

// GetAssetcustomstatusesIdWithResponse request returning *GetAssetcustomstatusesIdResponse
func (c *ClientWithResponses) GetAssetcustomstatusesIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAssetcustomstatusesIdResponse, error) {
	rsp, err := c.GetAssetcustomstatusesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetcustomstatusesIdResponse(rsp)
}

// PatchAssetcustomstatusesIdWithBodyWithResponse request with arbitrary body returning *PatchAssetcustomstatusesIdResponse
func (c *ClientWithResponses) PatchAssetcustomstatusesIdWithBodyWithResponse(ctx context.Context, id int, params *PatchAssetcustomstatusesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAssetcustomstatusesIdResponse, error) {
	rsp, err := c.PatchAssetcustomstatusesIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAssetcustomstatusesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchAssetcustomstatusesIdWithResponse(ctx context.Context, id int, params *PatchAssetcustomstatusesIdParams, body PatchAssetcustomstatusesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAssetcustomstatusesIdResponse, error) {
	rsp, err := c.PatchAssetcustomstatusesId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAssetcustomstatusesIdResponse(rsp)
}

// GetAssetsWithResponse request returning *GetAssetsResponse
func (c *ClientWithResponses) GetAssetsWithResponse(ctx context.Context, params *GetAssetsParams, reqEditors ...RequestEditorFn) (*GetAssetsResponse, error) {
	rsp, err := c.GetAssets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetsResponse(rsp)
}

// PostAssetsWithBodyWithResponse request with arbitrary body returning *PostAssetsResponse
func (c *ClientWithResponses) PostAssetsWithBodyWithResponse(ctx context.Context, params *PostAssetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAssetsResponse, error) {
	rsp, err := c.PostAssetsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAssetsResponse(rsp)
}

func (c *ClientWithResponses) PostAssetsWithResponse(ctx context.Context, params *PostAssetsParams, body PostAssetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAssetsResponse, error) {
	rsp, err := c.PostAssets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAssetsResponse(rsp)
}

// PostAssetsAssetIdStatusWithBodyWithResponse request with arbitrary body returning *PostAssetsAssetIdStatusResponse
func (c *ClientWithResponses) PostAssetsAssetIdStatusWithBodyWithResponse(ctx context.Context, assetId int, params *PostAssetsAssetIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAssetsAssetIdStatusResponse, error) {
	rsp, err := c.PostAssetsAssetIdStatusWithBody(ctx, assetId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAssetsAssetIdStatusResponse(rsp)
}

func (c *ClientWithResponses) PostAssetsAssetIdStatusWithResponse(ctx context.Context, assetId int, params *PostAssetsAssetIdStatusParams, body PostAssetsAssetIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAssetsAssetIdStatusResponse, error) {
	rsp, err := c.PostAssetsAssetIdStatus(ctx, assetId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAssetsAssetIdStatusResponse(rsp)
}

// DeleteAssetsIdWithResponse request returning *DeleteAssetsIdResponse
func (c *ClientWithResponses) DeleteAssetsIdWithResponse(ctx context.Context, id int, params *DeleteAssetsIdParams, reqEditors ...RequestEditorFn) (*DeleteAssetsIdResponse, error) {
	rsp, err := c.DeleteAssetsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAssetsIdResponse(rsp)
}

// GetAssetsIdWithResponse request returning *GetAssetsIdResponse
func (c *ClientWithResponses) GetAssetsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAssetsIdResponse, error) {
	rsp, err := c.GetAssetsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetsIdResponse(rsp)
}

// PatchAssetsIdWithBodyWithResponse request with arbitrary body returning *PatchAssetsIdResponse
func (c *ClientWithResponses) PatchAssetsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchAssetsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAssetsIdResponse, error) {
	rsp, err := c.PatchAssetsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAssetsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchAssetsIdWithResponse(ctx context.Context, id int, params *PatchAssetsIdParams, body PatchAssetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAssetsIdResponse, error) {
	rsp, err := c.PatchAssetsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAssetsIdResponse(rsp)
}

// DeleteAssetsIdAttachmentsFilenameWithResponse request returning *DeleteAssetsIdAttachmentsFilenameResponse
func (c *ClientWithResponses) DeleteAssetsIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeleteAssetsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeleteAssetsIdAttachmentsFilenameResponse, error) {
	rsp, err := c.DeleteAssetsIdAttachmentsFilename(ctx, id, filename, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAssetsIdAttachmentsFilenameResponse(rsp)
}

// PutAssetsIdAttachmentsFilenameWithBodyWithResponse request with arbitrary body returning *PutAssetsIdAttachmentsFilenameResponse
func (c *ClientWithResponses) PutAssetsIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutAssetsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAssetsIdAttachmentsFilenameResponse, error) {
	rsp, err := c.PutAssetsIdAttachmentsFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAssetsIdAttachmentsFilenameResponse(rsp)
}

// PutAssetsIdThumbnailFilenameWithBodyWithResponse request with arbitrary body returning *PutAssetsIdThumbnailFilenameResponse
func (c *ClientWithResponses) PutAssetsIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutAssetsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAssetsIdThumbnailFilenameResponse, error) {
	rsp, err := c.PutAssetsIdThumbnailFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAssetsIdThumbnailFilenameResponse(rsp)
}

// GetAssetstatusesWithResponse request returning *GetAssetstatusesResponse
func (c *ClientWithResponses) GetAssetstatusesWithResponse(ctx context.Context, params *GetAssetstatusesParams, reqEditors ...RequestEditorFn) (*GetAssetstatusesResponse, error) {
	rsp, err := c.GetAssetstatuses(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetstatusesResponse(rsp)
}

// PatchAssetstatusesIdWithBodyWithResponse request with arbitrary body returning *PatchAssetstatusesIdResponse
func (c *ClientWithResponses) PatchAssetstatusesIdWithBodyWithResponse(ctx context.Context, id int, params *PatchAssetstatusesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAssetstatusesIdResponse, error) {
	rsp, err := c.PatchAssetstatusesIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAssetstatusesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchAssetstatusesIdWithResponse(ctx context.Context, id int, params *PatchAssetstatusesIdParams, body PatchAssetstatusesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAssetstatusesIdResponse, error) {
	rsp, err := c.PatchAssetstatusesId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAssetstatusesIdResponse(rsp)
}

// GetCategoriesWithResponse request returning *GetCategoriesResponse
func (c *ClientWithResponses) GetCategoriesWithResponse(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*GetCategoriesResponse, error) {
	rsp, err := c.GetCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoriesResponse(rsp)
}

// PostCategoriesWithBodyWithResponse request with arbitrary body returning *PostCategoriesResponse
func (c *ClientWithResponses) PostCategoriesWithBodyWithResponse(ctx context.Context, params *PostCategoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCategoriesResponse, error) {
	rsp, err := c.PostCategoriesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCategoriesResponse(rsp)
}

func (c *ClientWithResponses) PostCategoriesWithResponse(ctx context.Context, params *PostCategoriesParams, body PostCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCategoriesResponse, error) {
	rsp, err := c.PostCategories(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCategoriesResponse(rsp)
}

// DeleteCategoriesIdWithResponse request returning *DeleteCategoriesIdResponse
func (c *ClientWithResponses) DeleteCategoriesIdWithResponse(ctx context.Context, id int, params *DeleteCategoriesIdParams, reqEditors ...RequestEditorFn) (*DeleteCategoriesIdResponse, error) {
	rsp, err := c.DeleteCategoriesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCategoriesIdResponse(rsp)
}

// GetCategoriesIdWithResponse request returning *GetCategoriesIdResponse
func (c *ClientWithResponses) GetCategoriesIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCategoriesIdResponse, error) {
	rsp, err := c.GetCategoriesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoriesIdResponse(rsp)
}

// PatchCategoriesIdWithBodyWithResponse request with arbitrary body returning *PatchCategoriesIdResponse
func (c *ClientWithResponses) PatchCategoriesIdWithBodyWithResponse(ctx context.Context, id int, params *PatchCategoriesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchCategoriesIdResponse, error) {
	rsp, err := c.PatchCategoriesIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchCategoriesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchCategoriesIdWithResponse(ctx context.Context, id int, params *PatchCategoriesIdParams, body PatchCategoriesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchCategoriesIdResponse, error) {
	rsp, err := c.PatchCategoriesId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchCategoriesIdResponse(rsp)
}

// GetConversationsWithResponse request returning *GetConversationsResponse
func (c *ClientWithResponses) GetConversationsWithResponse(ctx context.Context, params *GetConversationsParams, reqEditors ...RequestEditorFn) (*GetConversationsResponse, error) {
	rsp, err := c.GetConversations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConversationsResponse(rsp)
}

// GetConversationsIdMembersWithResponse request returning *GetConversationsIdMembersResponse
func (c *ClientWithResponses) GetConversationsIdMembersWithResponse(ctx context.Context, id int, params *GetConversationsIdMembersParams, reqEditors ...RequestEditorFn) (*GetConversationsIdMembersResponse, error) {
	rsp, err := c.GetConversationsIdMembers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConversationsIdMembersResponse(rsp)
}

// PostConversationsIdMessagesWithBodyWithResponse request with arbitrary body returning *PostConversationsIdMessagesResponse
func (c *ClientWithResponses) PostConversationsIdMessagesWithBodyWithResponse(ctx context.Context, id int, params *PostConversationsIdMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostConversationsIdMessagesResponse, error) {
	rsp, err := c.PostConversationsIdMessagesWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostConversationsIdMessagesResponse(rsp)
}

func (c *ClientWithResponses) PostConversationsIdMessagesWithResponse(ctx context.Context, id int, params *PostConversationsIdMessagesParams, body PostConversationsIdMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostConversationsIdMessagesResponse, error) {
	rsp, err := c.PostConversationsIdMessages(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostConversationsIdMessagesResponse(rsp)
}

// GetCustomfieldsEntityWithResponse request returning *GetCustomfieldsEntityResponse
func (c *ClientWithResponses) GetCustomfieldsEntityWithResponse(ctx context.Context, entity GetCustomfieldsEntityParamsEntity, params *GetCustomfieldsEntityParams, reqEditors ...RequestEditorFn) (*GetCustomfieldsEntityResponse, error) {
	rsp, err := c.GetCustomfieldsEntity(ctx, entity, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomfieldsEntityResponse(rsp)
}

// PostCustomfieldsEntityWithBodyWithResponse request with arbitrary body returning *PostCustomfieldsEntityResponse
func (c *ClientWithResponses) PostCustomfieldsEntityWithBodyWithResponse(ctx context.Context, entity PostCustomfieldsEntityParamsEntity, params *PostCustomfieldsEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomfieldsEntityResponse, error) {
	rsp, err := c.PostCustomfieldsEntityWithBody(ctx, entity, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomfieldsEntityResponse(rsp)
}

func (c *ClientWithResponses) PostCustomfieldsEntityWithResponse(ctx context.Context, entity PostCustomfieldsEntityParamsEntity, params *PostCustomfieldsEntityParams, body PostCustomfieldsEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomfieldsEntityResponse, error) {
	rsp, err := c.PostCustomfieldsEntity(ctx, entity, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomfieldsEntityResponse(rsp)
}

// DeleteCustomfieldsEntityIdWithResponse request returning *DeleteCustomfieldsEntityIdResponse
func (c *ClientWithResponses) DeleteCustomfieldsEntityIdWithResponse(ctx context.Context, entity DeleteCustomfieldsEntityIdParamsEntity, id int, params *DeleteCustomfieldsEntityIdParams, reqEditors ...RequestEditorFn) (*DeleteCustomfieldsEntityIdResponse, error) {
	rsp, err := c.DeleteCustomfieldsEntityId(ctx, entity, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomfieldsEntityIdResponse(rsp)
}

// PatchCustomfieldsEntityIdWithBodyWithResponse request with arbitrary body returning *PatchCustomfieldsEntityIdResponse
func (c *ClientWithResponses) PatchCustomfieldsEntityIdWithBodyWithResponse(ctx context.Context, entity PatchCustomfieldsEntityIdParamsEntity, id int, params *PatchCustomfieldsEntityIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchCustomfieldsEntityIdResponse, error) {
	rsp, err := c.PatchCustomfieldsEntityIdWithBody(ctx, entity, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchCustomfieldsEntityIdResponse(rsp)
}

func (c *ClientWithResponses) PatchCustomfieldsEntityIdWithResponse(ctx context.Context, entity PatchCustomfieldsEntityIdParamsEntity, id int, params *PatchCustomfieldsEntityIdParams, body PatchCustomfieldsEntityIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchCustomfieldsEntityIdResponse, error) {
	rsp, err := c.PatchCustomfieldsEntityId(ctx, entity, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchCustomfieldsEntityIdResponse(rsp)
}

// GetLocationsWithResponse request returning *GetLocationsResponse
func (c *ClientWithResponses) GetLocationsWithResponse(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*GetLocationsResponse, error) {
	rsp, err := c.GetLocations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationsResponse(rsp)
}

// PostLocationsWithBodyWithResponse request with arbitrary body returning *PostLocationsResponse
func (c *ClientWithResponses) PostLocationsWithBodyWithResponse(ctx context.Context, params *PostLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLocationsResponse, error) {
	rsp, err := c.PostLocationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLocationsResponse(rsp)
}

func (c *ClientWithResponses) PostLocationsWithResponse(ctx context.Context, params *PostLocationsParams, body PostLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLocationsResponse, error) {
	rsp, err := c.PostLocations(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLocationsResponse(rsp)
}

// DeleteLocationsIdWithResponse request returning *DeleteLocationsIdResponse
func (c *ClientWithResponses) DeleteLocationsIdWithResponse(ctx context.Context, id int, params *DeleteLocationsIdParams, reqEditors ...RequestEditorFn) (*DeleteLocationsIdResponse, error) {
	rsp, err := c.DeleteLocationsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLocationsIdResponse(rsp)
}

// GetLocationsIdWithResponse request returning *GetLocationsIdResponse
func (c *ClientWithResponses) GetLocationsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetLocationsIdResponse, error) {
	rsp, err := c.GetLocationsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationsIdResponse(rsp)
}

// PatchLocationsIdWithBodyWithResponse request with arbitrary body returning *PatchLocationsIdResponse
func (c *ClientWithResponses) PatchLocationsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchLocationsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLocationsIdResponse, error) {
	rsp, err := c.PatchLocationsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLocationsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchLocationsIdWithResponse(ctx context.Context, id int, params *PatchLocationsIdParams, body PatchLocationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLocationsIdResponse, error) {
	rsp, err := c.PatchLocationsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLocationsIdResponse(rsp)
}

// DeleteLocationsIdAttachmentsFilenameWithResponse request returning *DeleteLocationsIdAttachmentsFilenameResponse
func (c *ClientWithResponses) DeleteLocationsIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeleteLocationsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeleteLocationsIdAttachmentsFilenameResponse, error) {
	rsp, err := c.DeleteLocationsIdAttachmentsFilename(ctx, id, filename, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLocationsIdAttachmentsFilenameResponse(rsp)
}

// PutLocationsIdAttachmentsFilenameWithBodyWithResponse request with arbitrary body returning *PutLocationsIdAttachmentsFilenameResponse
func (c *ClientWithResponses) PutLocationsIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutLocationsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutLocationsIdAttachmentsFilenameResponse, error) {
	rsp, err := c.PutLocationsIdAttachmentsFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutLocationsIdAttachmentsFilenameResponse(rsp)
}

// PutLocationsIdThumbnailFilenameWithBodyWithResponse request with arbitrary body returning *PutLocationsIdThumbnailFilenameResponse
func (c *ClientWithResponses) PutLocationsIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutLocationsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutLocationsIdThumbnailFilenameResponse, error) {
	rsp, err := c.PutLocationsIdThumbnailFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutLocationsIdThumbnailFilenameResponse(rsp)
}

// PostMeterreadingsWithBodyWithResponse request with arbitrary body returning *PostMeterreadingsResponse
func (c *ClientWithResponses) PostMeterreadingsWithBodyWithResponse(ctx context.Context, params *PostMeterreadingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMeterreadingsResponse, error) {
	rsp, err := c.PostMeterreadingsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMeterreadingsResponse(rsp)
}

func (c *ClientWithResponses) PostMeterreadingsWithResponse(ctx context.Context, params *PostMeterreadingsParams, body PostMeterreadingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMeterreadingsResponse, error) {
	rsp, err := c.PostMeterreadings(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMeterreadingsResponse(rsp)
}

// GetMetersWithResponse request returning *GetMetersResponse
func (c *ClientWithResponses) GetMetersWithResponse(ctx context.Context, params *GetMetersParams, reqEditors ...RequestEditorFn) (*GetMetersResponse, error) {
	rsp, err := c.GetMeters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetersResponse(rsp)
}

// PostMetersWithBodyWithResponse request with arbitrary body returning *PostMetersResponse
func (c *ClientWithResponses) PostMetersWithBodyWithResponse(ctx context.Context, params *PostMetersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMetersResponse, error) {
	rsp, err := c.PostMetersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMetersResponse(rsp)
}

func (c *ClientWithResponses) PostMetersWithResponse(ctx context.Context, params *PostMetersParams, body PostMetersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMetersResponse, error) {
	rsp, err := c.PostMeters(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMetersResponse(rsp)
}

// DeleteMetersIdWithResponse request returning *DeleteMetersIdResponse
func (c *ClientWithResponses) DeleteMetersIdWithResponse(ctx context.Context, id int, params *DeleteMetersIdParams, reqEditors ...RequestEditorFn) (*DeleteMetersIdResponse, error) {
	rsp, err := c.DeleteMetersId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMetersIdResponse(rsp)
}

// GetMetersIdWithResponse request returning *GetMetersIdResponse
func (c *ClientWithResponses) GetMetersIdWithResponse(ctx context.Context, id int, params *GetMetersIdParams, reqEditors ...RequestEditorFn) (*GetMetersIdResponse, error) {
	rsp, err := c.GetMetersId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetersIdResponse(rsp)
}

// PatchMetersIdWithBodyWithResponse request with arbitrary body returning *PatchMetersIdResponse
func (c *ClientWithResponses) PatchMetersIdWithBodyWithResponse(ctx context.Context, id int, params *PatchMetersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchMetersIdResponse, error) {
	rsp, err := c.PatchMetersIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchMetersIdResponse(rsp)
}

func (c *ClientWithResponses) PatchMetersIdWithResponse(ctx context.Context, id int, params *PatchMetersIdParams, body PatchMetersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchMetersIdResponse, error) {
	rsp, err := c.PatchMetersId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchMetersIdResponse(rsp)
}

// PostMetersMeterIdReadingsWithBodyWithResponse request with arbitrary body returning *PostMetersMeterIdReadingsResponse
func (c *ClientWithResponses) PostMetersMeterIdReadingsWithBodyWithResponse(ctx context.Context, meterId int, params *PostMetersMeterIdReadingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMetersMeterIdReadingsResponse, error) {
	rsp, err := c.PostMetersMeterIdReadingsWithBody(ctx, meterId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMetersMeterIdReadingsResponse(rsp)
}

func (c *ClientWithResponses) PostMetersMeterIdReadingsWithResponse(ctx context.Context, meterId int, params *PostMetersMeterIdReadingsParams, body PostMetersMeterIdReadingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMetersMeterIdReadingsResponse, error) {
	rsp, err := c.PostMetersMeterIdReadings(ctx, meterId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMetersMeterIdReadingsResponse(rsp)
}

// GetMetertriggersWithResponse request returning *GetMetertriggersResponse
func (c *ClientWithResponses) GetMetertriggersWithResponse(ctx context.Context, params *GetMetertriggersParams, reqEditors ...RequestEditorFn) (*GetMetertriggersResponse, error) {
	rsp, err := c.GetMetertriggers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetertriggersResponse(rsp)
}

// PostMetertriggersWithBodyWithResponse request with arbitrary body returning *PostMetertriggersResponse
func (c *ClientWithResponses) PostMetertriggersWithBodyWithResponse(ctx context.Context, params *PostMetertriggersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMetertriggersResponse, error) {
	rsp, err := c.PostMetertriggersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMetertriggersResponse(rsp)
}

func (c *ClientWithResponses) PostMetertriggersWithResponse(ctx context.Context, params *PostMetertriggersParams, body PostMetertriggersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMetertriggersResponse, error) {
	rsp, err := c.PostMetertriggers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMetertriggersResponse(rsp)
}

// DeleteMetertriggersIdWithResponse request returning *DeleteMetertriggersIdResponse
func (c *ClientWithResponses) DeleteMetertriggersIdWithResponse(ctx context.Context, id int, params *DeleteMetertriggersIdParams, reqEditors ...RequestEditorFn) (*DeleteMetertriggersIdResponse, error) {
	rsp, err := c.DeleteMetertriggersId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMetertriggersIdResponse(rsp)
}

// GetMetertriggersIdWithResponse request returning *GetMetertriggersIdResponse
func (c *ClientWithResponses) GetMetertriggersIdWithResponse(ctx context.Context, id int, params *GetMetertriggersIdParams, reqEditors ...RequestEditorFn) (*GetMetertriggersIdResponse, error) {
	rsp, err := c.GetMetertriggersId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetertriggersIdResponse(rsp)
}

// PatchMetertriggersIdWithBodyWithResponse request with arbitrary body returning *PatchMetertriggersIdResponse
func (c *ClientWithResponses) PatchMetertriggersIdWithBodyWithResponse(ctx context.Context, id int, params *PatchMetertriggersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchMetertriggersIdResponse, error) {
	rsp, err := c.PatchMetertriggersIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchMetertriggersIdResponse(rsp)
}

func (c *ClientWithResponses) PatchMetertriggersIdWithResponse(ctx context.Context, id int, params *PatchMetertriggersIdParams, body PatchMetertriggersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchMetertriggersIdResponse, error) {
	rsp, err := c.PatchMetertriggersId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchMetertriggersIdResponse(rsp)
}

// PutMetertriggersIdThumbnailFilenameWithBodyWithResponse request with arbitrary body returning *PutMetertriggersIdThumbnailFilenameResponse
func (c *ClientWithResponses) PutMetertriggersIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutMetertriggersIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutMetertriggersIdThumbnailFilenameResponse, error) {
	rsp, err := c.PutMetertriggersIdThumbnailFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutMetertriggersIdThumbnailFilenameResponse(rsp)
}

// PatchMetertriggersIdWorkordertemplatesWithBodyWithResponse request with arbitrary body returning *PatchMetertriggersIdWorkordertemplatesResponse
func (c *ClientWithResponses) PatchMetertriggersIdWorkordertemplatesWithBodyWithResponse(ctx context.Context, id int, params *PatchMetertriggersIdWorkordertemplatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchMetertriggersIdWorkordertemplatesResponse, error) {
	rsp, err := c.PatchMetertriggersIdWorkordertemplatesWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchMetertriggersIdWorkordertemplatesResponse(rsp)
}

func (c *ClientWithResponses) PatchMetertriggersIdWorkordertemplatesWithResponse(ctx context.Context, id int, params *PatchMetertriggersIdWorkordertemplatesParams, body PatchMetertriggersIdWorkordertemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchMetertriggersIdWorkordertemplatesResponse, error) {
	rsp, err := c.PatchMetertriggersIdWorkordertemplates(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchMetertriggersIdWorkordertemplatesResponse(rsp)
}

// DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameWithResponse request returning *DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse
func (c *ClientWithResponses) DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse, error) {
	rsp, err := c.DeleteMetertriggersIdWorkordertemplatesAttachmentsFilename(ctx, id, filename, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse(rsp)
}

// PutMetertriggersIdWorkordertemplatesAttachmentsFilenameWithBodyWithResponse request with arbitrary body returning *PutMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse
func (c *ClientWithResponses) PutMetertriggersIdWorkordertemplatesAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutMetertriggersIdWorkordertemplatesAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse, error) {
	rsp, err := c.PutMetertriggersIdWorkordertemplatesAttachmentsFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse(rsp)
}

// GetOrganizationsWithResponse request returning *GetOrganizationsResponse
func (c *ClientWithResponses) GetOrganizationsWithResponse(ctx context.Context, params *GetOrganizationsParams, reqEditors ...RequestEditorFn) (*GetOrganizationsResponse, error) {
	rsp, err := c.GetOrganizations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationsResponse(rsp)
}

// GetPartsWithResponse request returning *GetPartsResponse
func (c *ClientWithResponses) GetPartsWithResponse(ctx context.Context, params *GetPartsParams, reqEditors ...RequestEditorFn) (*GetPartsResponse, error) {
	rsp, err := c.GetParts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPartsResponse(rsp)
}

// PostPartsWithBodyWithResponse request with arbitrary body returning *PostPartsResponse
func (c *ClientWithResponses) PostPartsWithBodyWithResponse(ctx context.Context, params *PostPartsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPartsResponse, error) {
	rsp, err := c.PostPartsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPartsResponse(rsp)
}

func (c *ClientWithResponses) PostPartsWithResponse(ctx context.Context, params *PostPartsParams, body PostPartsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPartsResponse, error) {
	rsp, err := c.PostParts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPartsResponse(rsp)
}

// DeletePartsIdWithResponse request returning *DeletePartsIdResponse
func (c *ClientWithResponses) DeletePartsIdWithResponse(ctx context.Context, id int, params *DeletePartsIdParams, reqEditors ...RequestEditorFn) (*DeletePartsIdResponse, error) {
	rsp, err := c.DeletePartsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePartsIdResponse(rsp)
}

// GetPartsIdWithResponse request returning *GetPartsIdResponse
func (c *ClientWithResponses) GetPartsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPartsIdResponse, error) {
	rsp, err := c.GetPartsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPartsIdResponse(rsp)
}

// PatchPartsIdWithBodyWithResponse request with arbitrary body returning *PatchPartsIdResponse
func (c *ClientWithResponses) PatchPartsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchPartsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPartsIdResponse, error) {
	rsp, err := c.PatchPartsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPartsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchPartsIdWithResponse(ctx context.Context, id int, params *PatchPartsIdParams, body PatchPartsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPartsIdResponse, error) {
	rsp, err := c.PatchPartsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPartsIdResponse(rsp)
}

// DeletePartsIdAttachmentsFilenameWithResponse request returning *DeletePartsIdAttachmentsFilenameResponse
func (c *ClientWithResponses) DeletePartsIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeletePartsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeletePartsIdAttachmentsFilenameResponse, error) {
	rsp, err := c.DeletePartsIdAttachmentsFilename(ctx, id, filename, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePartsIdAttachmentsFilenameResponse(rsp)
}

// PutPartsIdAttachmentsFilenameWithBodyWithResponse request with arbitrary body returning *PutPartsIdAttachmentsFilenameResponse
func (c *ClientWithResponses) PutPartsIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutPartsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPartsIdAttachmentsFilenameResponse, error) {
	rsp, err := c.PutPartsIdAttachmentsFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPartsIdAttachmentsFilenameResponse(rsp)
}

// PutPartsIdThumbnailFilenameWithBodyWithResponse request with arbitrary body returning *PutPartsIdThumbnailFilenameResponse
func (c *ClientWithResponses) PutPartsIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutPartsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPartsIdThumbnailFilenameResponse, error) {
	rsp, err := c.PutPartsIdThumbnailFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPartsIdThumbnailFilenameResponse(rsp)
}

// GetParttransferrequestsWithResponse request returning *GetParttransferrequestsResponse
func (c *ClientWithResponses) GetParttransferrequestsWithResponse(ctx context.Context, params *GetParttransferrequestsParams, reqEditors ...RequestEditorFn) (*GetParttransferrequestsResponse, error) {
	rsp, err := c.GetParttransferrequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetParttransferrequestsResponse(rsp)
}

// PostParttransferrequestsWithBodyWithResponse request with arbitrary body returning *PostParttransferrequestsResponse
func (c *ClientWithResponses) PostParttransferrequestsWithBodyWithResponse(ctx context.Context, params *PostParttransferrequestsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostParttransferrequestsResponse, error) {
	rsp, err := c.PostParttransferrequestsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostParttransferrequestsResponse(rsp)
}

func (c *ClientWithResponses) PostParttransferrequestsWithResponse(ctx context.Context, params *PostParttransferrequestsParams, body PostParttransferrequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostParttransferrequestsResponse, error) {
	rsp, err := c.PostParttransferrequests(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostParttransferrequestsResponse(rsp)
}

// GetParttransferrequestsIdWithResponse request returning *GetParttransferrequestsIdResponse
func (c *ClientWithResponses) GetParttransferrequestsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetParttransferrequestsIdResponse, error) {
	rsp, err := c.GetParttransferrequestsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetParttransferrequestsIdResponse(rsp)
}

// PatchParttransferrequestsIdWithBodyWithResponse request with arbitrary body returning *PatchParttransferrequestsIdResponse
func (c *ClientWithResponses) PatchParttransferrequestsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchParttransferrequestsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchParttransferrequestsIdResponse, error) {
	rsp, err := c.PatchParttransferrequestsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchParttransferrequestsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchParttransferrequestsIdWithResponse(ctx context.Context, id int, params *PatchParttransferrequestsIdParams, body PatchParttransferrequestsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchParttransferrequestsIdResponse, error) {
	rsp, err := c.PatchParttransferrequestsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchParttransferrequestsIdResponse(rsp)
}

// DeleteProceduretemplaterowsIdWithResponse request returning *DeleteProceduretemplaterowsIdResponse
func (c *ClientWithResponses) DeleteProceduretemplaterowsIdWithResponse(ctx context.Context, id int, params *DeleteProceduretemplaterowsIdParams, reqEditors ...RequestEditorFn) (*DeleteProceduretemplaterowsIdResponse, error) {
	rsp, err := c.DeleteProceduretemplaterowsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProceduretemplaterowsIdResponse(rsp)
}

// PatchProceduretemplaterowsIdWithBodyWithResponse request with arbitrary body returning *PatchProceduretemplaterowsIdResponse
func (c *ClientWithResponses) PatchProceduretemplaterowsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchProceduretemplaterowsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchProceduretemplaterowsIdResponse, error) {
	rsp, err := c.PatchProceduretemplaterowsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchProceduretemplaterowsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchProceduretemplaterowsIdWithResponse(ctx context.Context, id int, params *PatchProceduretemplaterowsIdParams, body PatchProceduretemplaterowsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchProceduretemplaterowsIdResponse, error) {
	rsp, err := c.PatchProceduretemplaterowsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchProceduretemplaterowsIdResponse(rsp)
}

// DeleteProceduretemplaterowsIdAttachmentsWithResponse request returning *DeleteProceduretemplaterowsIdAttachmentsResponse
func (c *ClientWithResponses) DeleteProceduretemplaterowsIdAttachmentsWithResponse(ctx context.Context, id int, params *DeleteProceduretemplaterowsIdAttachmentsParams, reqEditors ...RequestEditorFn) (*DeleteProceduretemplaterowsIdAttachmentsResponse, error) {
	rsp, err := c.DeleteProceduretemplaterowsIdAttachments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProceduretemplaterowsIdAttachmentsResponse(rsp)
}

// PutProceduretemplaterowsIdAttachmentsFilenameWithBodyWithResponse request with arbitrary body returning *PutProceduretemplaterowsIdAttachmentsFilenameResponse
func (c *ClientWithResponses) PutProceduretemplaterowsIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutProceduretemplaterowsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutProceduretemplaterowsIdAttachmentsFilenameResponse, error) {
	rsp, err := c.PutProceduretemplaterowsIdAttachmentsFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutProceduretemplaterowsIdAttachmentsFilenameResponse(rsp)
}

// GetProceduretemplatesWithResponse request returning *GetProceduretemplatesResponse
func (c *ClientWithResponses) GetProceduretemplatesWithResponse(ctx context.Context, params *GetProceduretemplatesParams, reqEditors ...RequestEditorFn) (*GetProceduretemplatesResponse, error) {
	rsp, err := c.GetProceduretemplates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProceduretemplatesResponse(rsp)
}

// PostProceduretemplatesWithBodyWithResponse request with arbitrary body returning *PostProceduretemplatesResponse
func (c *ClientWithResponses) PostProceduretemplatesWithBodyWithResponse(ctx context.Context, params *PostProceduretemplatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProceduretemplatesResponse, error) {
	rsp, err := c.PostProceduretemplatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProceduretemplatesResponse(rsp)
}

func (c *ClientWithResponses) PostProceduretemplatesWithResponse(ctx context.Context, params *PostProceduretemplatesParams, body PostProceduretemplatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProceduretemplatesResponse, error) {
	rsp, err := c.PostProceduretemplates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProceduretemplatesResponse(rsp)
}

// DeleteProceduretemplatesIdWithResponse request returning *DeleteProceduretemplatesIdResponse
func (c *ClientWithResponses) DeleteProceduretemplatesIdWithResponse(ctx context.Context, id int, params *DeleteProceduretemplatesIdParams, reqEditors ...RequestEditorFn) (*DeleteProceduretemplatesIdResponse, error) {
	rsp, err := c.DeleteProceduretemplatesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProceduretemplatesIdResponse(rsp)
}

// GetProceduretemplatesIdWithResponse request returning *GetProceduretemplatesIdResponse
func (c *ClientWithResponses) GetProceduretemplatesIdWithResponse(ctx context.Context, id int, params *GetProceduretemplatesIdParams, reqEditors ...RequestEditorFn) (*GetProceduretemplatesIdResponse, error) {
	rsp, err := c.GetProceduretemplatesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProceduretemplatesIdResponse(rsp)
}

// PatchProceduretemplatesIdWithBodyWithResponse request with arbitrary body returning *PatchProceduretemplatesIdResponse
func (c *ClientWithResponses) PatchProceduretemplatesIdWithBodyWithResponse(ctx context.Context, id int, params *PatchProceduretemplatesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchProceduretemplatesIdResponse, error) {
	rsp, err := c.PatchProceduretemplatesIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchProceduretemplatesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchProceduretemplatesIdWithResponse(ctx context.Context, id int, params *PatchProceduretemplatesIdParams, body PatchProceduretemplatesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchProceduretemplatesIdResponse, error) {
	rsp, err := c.PatchProceduretemplatesId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchProceduretemplatesIdResponse(rsp)
}

// GetPurchaseordersWithResponse request returning *GetPurchaseordersResponse
func (c *ClientWithResponses) GetPurchaseordersWithResponse(ctx context.Context, params *GetPurchaseordersParams, reqEditors ...RequestEditorFn) (*GetPurchaseordersResponse, error) {
	rsp, err := c.GetPurchaseorders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPurchaseordersResponse(rsp)
}

// PostPurchaseordersWithBodyWithResponse request with arbitrary body returning *PostPurchaseordersResponse
func (c *ClientWithResponses) PostPurchaseordersWithBodyWithResponse(ctx context.Context, params *PostPurchaseordersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPurchaseordersResponse, error) {
	rsp, err := c.PostPurchaseordersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPurchaseordersResponse(rsp)
}

func (c *ClientWithResponses) PostPurchaseordersWithResponse(ctx context.Context, params *PostPurchaseordersParams, body PostPurchaseordersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPurchaseordersResponse, error) {
	rsp, err := c.PostPurchaseorders(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPurchaseordersResponse(rsp)
}

// DeletePurchaseordersIdWithResponse request returning *DeletePurchaseordersIdResponse
func (c *ClientWithResponses) DeletePurchaseordersIdWithResponse(ctx context.Context, id int, params *DeletePurchaseordersIdParams, reqEditors ...RequestEditorFn) (*DeletePurchaseordersIdResponse, error) {
	rsp, err := c.DeletePurchaseordersId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePurchaseordersIdResponse(rsp)
}

// GetPurchaseordersIdWithResponse request returning *GetPurchaseordersIdResponse
func (c *ClientWithResponses) GetPurchaseordersIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPurchaseordersIdResponse, error) {
	rsp, err := c.GetPurchaseordersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPurchaseordersIdResponse(rsp)
}

// PatchPurchaseordersIdWithBodyWithResponse request with arbitrary body returning *PatchPurchaseordersIdResponse
func (c *ClientWithResponses) PatchPurchaseordersIdWithBodyWithResponse(ctx context.Context, id float32, params *PatchPurchaseordersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPurchaseordersIdResponse, error) {
	rsp, err := c.PatchPurchaseordersIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPurchaseordersIdResponse(rsp)
}

func (c *ClientWithResponses) PatchPurchaseordersIdWithResponse(ctx context.Context, id float32, params *PatchPurchaseordersIdParams, body PatchPurchaseordersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPurchaseordersIdResponse, error) {
	rsp, err := c.PatchPurchaseordersId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPurchaseordersIdResponse(rsp)
}

// DeletePurchaseordersIdAttachmentsFilenameWithResponse request returning *DeletePurchaseordersIdAttachmentsFilenameResponse
func (c *ClientWithResponses) DeletePurchaseordersIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeletePurchaseordersIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeletePurchaseordersIdAttachmentsFilenameResponse, error) {
	rsp, err := c.DeletePurchaseordersIdAttachmentsFilename(ctx, id, filename, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePurchaseordersIdAttachmentsFilenameResponse(rsp)
}

// PutPurchaseordersIdAttachmentsFilenameWithBodyWithResponse request with arbitrary body returning *PutPurchaseordersIdAttachmentsFilenameResponse
func (c *ClientWithResponses) PutPurchaseordersIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutPurchaseordersIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPurchaseordersIdAttachmentsFilenameResponse, error) {
	rsp, err := c.PutPurchaseordersIdAttachmentsFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPurchaseordersIdAttachmentsFilenameResponse(rsp)
}

// PostPurchaseordersIdCommentsWithBodyWithResponse request with arbitrary body returning *PostPurchaseordersIdCommentsResponse
func (c *ClientWithResponses) PostPurchaseordersIdCommentsWithBodyWithResponse(ctx context.Context, id int, params *PostPurchaseordersIdCommentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPurchaseordersIdCommentsResponse, error) {
	rsp, err := c.PostPurchaseordersIdCommentsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPurchaseordersIdCommentsResponse(rsp)
}

func (c *ClientWithResponses) PostPurchaseordersIdCommentsWithResponse(ctx context.Context, id int, params *PostPurchaseordersIdCommentsParams, body PostPurchaseordersIdCommentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPurchaseordersIdCommentsResponse, error) {
	rsp, err := c.PostPurchaseordersIdComments(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPurchaseordersIdCommentsResponse(rsp)
}

// PostPurchaseordersIdEmailsWithBodyWithResponse request with arbitrary body returning *PostPurchaseordersIdEmailsResponse
func (c *ClientWithResponses) PostPurchaseordersIdEmailsWithBodyWithResponse(ctx context.Context, id int, params *PostPurchaseordersIdEmailsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPurchaseordersIdEmailsResponse, error) {
	rsp, err := c.PostPurchaseordersIdEmailsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPurchaseordersIdEmailsResponse(rsp)
}

func (c *ClientWithResponses) PostPurchaseordersIdEmailsWithResponse(ctx context.Context, id int, params *PostPurchaseordersIdEmailsParams, body PostPurchaseordersIdEmailsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPurchaseordersIdEmailsResponse, error) {
	rsp, err := c.PostPurchaseordersIdEmails(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPurchaseordersIdEmailsResponse(rsp)
}

// PatchPurchaseordersIdFulfillmentWithBodyWithResponse request with arbitrary body returning *PatchPurchaseordersIdFulfillmentResponse
func (c *ClientWithResponses) PatchPurchaseordersIdFulfillmentWithBodyWithResponse(ctx context.Context, id float32, params *PatchPurchaseordersIdFulfillmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPurchaseordersIdFulfillmentResponse, error) {
	rsp, err := c.PatchPurchaseordersIdFulfillmentWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPurchaseordersIdFulfillmentResponse(rsp)
}

func (c *ClientWithResponses) PatchPurchaseordersIdFulfillmentWithResponse(ctx context.Context, id float32, params *PatchPurchaseordersIdFulfillmentParams, body PatchPurchaseordersIdFulfillmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPurchaseordersIdFulfillmentResponse, error) {
	rsp, err := c.PatchPurchaseordersIdFulfillment(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPurchaseordersIdFulfillmentResponse(rsp)
}

// PatchPurchaseordersIdStatusWithBodyWithResponse request with arbitrary body returning *PatchPurchaseordersIdStatusResponse
func (c *ClientWithResponses) PatchPurchaseordersIdStatusWithBodyWithResponse(ctx context.Context, id float32, params *PatchPurchaseordersIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPurchaseordersIdStatusResponse, error) {
	rsp, err := c.PatchPurchaseordersIdStatusWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPurchaseordersIdStatusResponse(rsp)
}

func (c *ClientWithResponses) PatchPurchaseordersIdStatusWithResponse(ctx context.Context, id float32, params *PatchPurchaseordersIdStatusParams, body PatchPurchaseordersIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPurchaseordersIdStatusResponse, error) {
	rsp, err := c.PatchPurchaseordersIdStatus(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPurchaseordersIdStatusResponse(rsp)
}

// PutPurchaseordersIdThumbnailFilenameWithBodyWithResponse request with arbitrary body returning *PutPurchaseordersIdThumbnailFilenameResponse
func (c *ClientWithResponses) PutPurchaseordersIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutPurchaseordersIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPurchaseordersIdThumbnailFilenameResponse, error) {
	rsp, err := c.PutPurchaseordersIdThumbnailFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPurchaseordersIdThumbnailFilenameResponse(rsp)
}

// PostSubscriptionsWithBodyWithResponse request with arbitrary body returning *PostSubscriptionsResponse
func (c *ClientWithResponses) PostSubscriptionsWithBodyWithResponse(ctx context.Context, params *PostSubscriptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSubscriptionsResponse, error) {
	rsp, err := c.PostSubscriptionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSubscriptionsResponse(rsp)
}

func (c *ClientWithResponses) PostSubscriptionsWithResponse(ctx context.Context, params *PostSubscriptionsParams, body PostSubscriptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSubscriptionsResponse, error) {
	rsp, err := c.PostSubscriptions(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSubscriptionsResponse(rsp)
}

// DeleteSubscriptionsIdWithResponse request returning *DeleteSubscriptionsIdResponse
func (c *ClientWithResponses) DeleteSubscriptionsIdWithResponse(ctx context.Context, id int, params *DeleteSubscriptionsIdParams, reqEditors ...RequestEditorFn) (*DeleteSubscriptionsIdResponse, error) {
	rsp, err := c.DeleteSubscriptionsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscriptionsIdResponse(rsp)
}

// GetSubscriptionsIdWithResponse request returning *GetSubscriptionsIdResponse
func (c *ClientWithResponses) GetSubscriptionsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetSubscriptionsIdResponse, error) {
	rsp, err := c.GetSubscriptionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionsIdResponse(rsp)
}

// PatchSubscriptionsIdWithBodyWithResponse request with arbitrary body returning *PatchSubscriptionsIdResponse
func (c *ClientWithResponses) PatchSubscriptionsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchSubscriptionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSubscriptionsIdResponse, error) {
	rsp, err := c.PatchSubscriptionsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSubscriptionsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSubscriptionsIdWithResponse(ctx context.Context, id int, params *PatchSubscriptionsIdParams, body PatchSubscriptionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSubscriptionsIdResponse, error) {
	rsp, err := c.PatchSubscriptionsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSubscriptionsIdResponse(rsp)
}

// GetSubscriptionsIdSecretWithResponse request returning *GetSubscriptionsIdSecretResponse
func (c *ClientWithResponses) GetSubscriptionsIdSecretWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetSubscriptionsIdSecretResponse, error) {
	rsp, err := c.GetSubscriptionsIdSecret(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionsIdSecretResponse(rsp)
}

// GetTeamsWithResponse request returning *GetTeamsResponse
func (c *ClientWithResponses) GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error) {
	rsp, err := c.GetTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsResponse(rsp)
}

// PostTeamsWithBodyWithResponse request with arbitrary body returning *PostTeamsResponse
func (c *ClientWithResponses) PostTeamsWithBodyWithResponse(ctx context.Context, params *PostTeamsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTeamsResponse, error) {
	rsp, err := c.PostTeamsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTeamsResponse(rsp)
}

func (c *ClientWithResponses) PostTeamsWithResponse(ctx context.Context, params *PostTeamsParams, body PostTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTeamsResponse, error) {
	rsp, err := c.PostTeams(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTeamsResponse(rsp)
}

// DeleteTeamsIdWithResponse request returning *DeleteTeamsIdResponse
func (c *ClientWithResponses) DeleteTeamsIdWithResponse(ctx context.Context, id int, params *DeleteTeamsIdParams, reqEditors ...RequestEditorFn) (*DeleteTeamsIdResponse, error) {
	rsp, err := c.DeleteTeamsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamsIdResponse(rsp)
}

// GetTeamsIdWithResponse request returning *GetTeamsIdResponse
func (c *ClientWithResponses) GetTeamsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTeamsIdResponse, error) {
	rsp, err := c.GetTeamsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsIdResponse(rsp)
}

// PatchTeamsIdWithBodyWithResponse request with arbitrary body returning *PatchTeamsIdResponse
func (c *ClientWithResponses) PatchTeamsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchTeamsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTeamsIdResponse, error) {
	rsp, err := c.PatchTeamsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTeamsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchTeamsIdWithResponse(ctx context.Context, id int, params *PatchTeamsIdParams, body PatchTeamsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTeamsIdResponse, error) {
	rsp, err := c.PatchTeamsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTeamsIdResponse(rsp)
}

// GetTeamsIdMembersWithResponse request returning *GetTeamsIdMembersResponse
func (c *ClientWithResponses) GetTeamsIdMembersWithResponse(ctx context.Context, id int, params *GetTeamsIdMembersParams, reqEditors ...RequestEditorFn) (*GetTeamsIdMembersResponse, error) {
	rsp, err := c.GetTeamsIdMembers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsIdMembersResponse(rsp)
}

// PostTeamsIdMembersWithBodyWithResponse request with arbitrary body returning *PostTeamsIdMembersResponse
func (c *ClientWithResponses) PostTeamsIdMembersWithBodyWithResponse(ctx context.Context, id int, params *PostTeamsIdMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTeamsIdMembersResponse, error) {
	rsp, err := c.PostTeamsIdMembersWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTeamsIdMembersResponse(rsp)
}

func (c *ClientWithResponses) PostTeamsIdMembersWithResponse(ctx context.Context, id int, params *PostTeamsIdMembersParams, body PostTeamsIdMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTeamsIdMembersResponse, error) {
	rsp, err := c.PostTeamsIdMembers(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTeamsIdMembersResponse(rsp)
}

// DeleteTeamsTeamIdMembersUserIdWithResponse request returning *DeleteTeamsTeamIdMembersUserIdResponse
func (c *ClientWithResponses) DeleteTeamsTeamIdMembersUserIdWithResponse(ctx context.Context, teamId int, userId int, params *DeleteTeamsTeamIdMembersUserIdParams, reqEditors ...RequestEditorFn) (*DeleteTeamsTeamIdMembersUserIdResponse, error) {
	rsp, err := c.DeleteTeamsTeamIdMembersUserId(ctx, teamId, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamsTeamIdMembersUserIdResponse(rsp)
}

// PatchTeamsTeamIdMembersUserIdWithBodyWithResponse request with arbitrary body returning *PatchTeamsTeamIdMembersUserIdResponse
func (c *ClientWithResponses) PatchTeamsTeamIdMembersUserIdWithBodyWithResponse(ctx context.Context, teamId int, userId int, params *PatchTeamsTeamIdMembersUserIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTeamsTeamIdMembersUserIdResponse, error) {
	rsp, err := c.PatchTeamsTeamIdMembersUserIdWithBody(ctx, teamId, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTeamsTeamIdMembersUserIdResponse(rsp)
}

func (c *ClientWithResponses) PatchTeamsTeamIdMembersUserIdWithResponse(ctx context.Context, teamId int, userId int, params *PatchTeamsTeamIdMembersUserIdParams, body PatchTeamsTeamIdMembersUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTeamsTeamIdMembersUserIdResponse, error) {
	rsp, err := c.PatchTeamsTeamIdMembersUserId(ctx, teamId, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTeamsTeamIdMembersUserIdResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// PostUsersWithBodyWithResponse request with arbitrary body returning *PostUsersResponse
func (c *ClientWithResponses) PostUsersWithBodyWithResponse(ctx context.Context, params *PostUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersResponse, error) {
	rsp, err := c.PostUsersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersResponse(rsp)
}

func (c *ClientWithResponses) PostUsersWithResponse(ctx context.Context, params *PostUsersParams, body PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersResponse, error) {
	rsp, err := c.PostUsers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersResponse(rsp)
}

// DeleteUsersIdWithResponse request returning *DeleteUsersIdResponse
func (c *ClientWithResponses) DeleteUsersIdWithResponse(ctx context.Context, id int, params *DeleteUsersIdParams, reqEditors ...RequestEditorFn) (*DeleteUsersIdResponse, error) {
	rsp, err := c.DeleteUsersId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUsersIdResponse(rsp)
}

// GetUsersIdWithResponse request returning *GetUsersIdResponse
func (c *ClientWithResponses) GetUsersIdWithResponse(ctx context.Context, id int, params *GetUsersIdParams, reqEditors ...RequestEditorFn) (*GetUsersIdResponse, error) {
	rsp, err := c.GetUsersId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersIdResponse(rsp)
}

// PatchUsersIdWithBodyWithResponse request with arbitrary body returning *PatchUsersIdResponse
func (c *ClientWithResponses) PatchUsersIdWithBodyWithResponse(ctx context.Context, id int, params *PatchUsersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUsersIdResponse, error) {
	rsp, err := c.PatchUsersIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUsersIdResponse(rsp)
}

func (c *ClientWithResponses) PatchUsersIdWithResponse(ctx context.Context, id int, params *PatchUsersIdParams, body PatchUsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUsersIdResponse, error) {
	rsp, err := c.PatchUsersId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUsersIdResponse(rsp)
}

// PostUsersIdMessagesWithBodyWithResponse request with arbitrary body returning *PostUsersIdMessagesResponse
func (c *ClientWithResponses) PostUsersIdMessagesWithBodyWithResponse(ctx context.Context, id int, params *PostUsersIdMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersIdMessagesResponse, error) {
	rsp, err := c.PostUsersIdMessagesWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersIdMessagesResponse(rsp)
}

func (c *ClientWithResponses) PostUsersIdMessagesWithResponse(ctx context.Context, id int, params *PostUsersIdMessagesParams, body PostUsersIdMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersIdMessagesResponse, error) {
	rsp, err := c.PostUsersIdMessages(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersIdMessagesResponse(rsp)
}

// GetVendorsWithResponse request returning *GetVendorsResponse
func (c *ClientWithResponses) GetVendorsWithResponse(ctx context.Context, params *GetVendorsParams, reqEditors ...RequestEditorFn) (*GetVendorsResponse, error) {
	rsp, err := c.GetVendors(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVendorsResponse(rsp)
}

// PostVendorsWithBodyWithResponse request with arbitrary body returning *PostVendorsResponse
func (c *ClientWithResponses) PostVendorsWithBodyWithResponse(ctx context.Context, params *PostVendorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVendorsResponse, error) {
	rsp, err := c.PostVendorsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVendorsResponse(rsp)
}

func (c *ClientWithResponses) PostVendorsWithResponse(ctx context.Context, params *PostVendorsParams, body PostVendorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVendorsResponse, error) {
	rsp, err := c.PostVendors(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVendorsResponse(rsp)
}

// DeleteVendorsIdWithResponse request returning *DeleteVendorsIdResponse
func (c *ClientWithResponses) DeleteVendorsIdWithResponse(ctx context.Context, id int, params *DeleteVendorsIdParams, reqEditors ...RequestEditorFn) (*DeleteVendorsIdResponse, error) {
	rsp, err := c.DeleteVendorsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVendorsIdResponse(rsp)
}

// GetVendorsIdWithResponse request returning *GetVendorsIdResponse
func (c *ClientWithResponses) GetVendorsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetVendorsIdResponse, error) {
	rsp, err := c.GetVendorsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVendorsIdResponse(rsp)
}

// PatchVendorsIdWithBodyWithResponse request with arbitrary body returning *PatchVendorsIdResponse
func (c *ClientWithResponses) PatchVendorsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchVendorsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchVendorsIdResponse, error) {
	rsp, err := c.PatchVendorsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchVendorsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchVendorsIdWithResponse(ctx context.Context, id int, params *PatchVendorsIdParams, body PatchVendorsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchVendorsIdResponse, error) {
	rsp, err := c.PatchVendorsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchVendorsIdResponse(rsp)
}

// DeleteVendorsIdAttachmentsFilenameWithResponse request returning *DeleteVendorsIdAttachmentsFilenameResponse
func (c *ClientWithResponses) DeleteVendorsIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeleteVendorsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeleteVendorsIdAttachmentsFilenameResponse, error) {
	rsp, err := c.DeleteVendorsIdAttachmentsFilename(ctx, id, filename, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVendorsIdAttachmentsFilenameResponse(rsp)
}

// PutVendorsIdAttachmentsFilenameWithBodyWithResponse request with arbitrary body returning *PutVendorsIdAttachmentsFilenameResponse
func (c *ClientWithResponses) PutVendorsIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutVendorsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutVendorsIdAttachmentsFilenameResponse, error) {
	rsp, err := c.PutVendorsIdAttachmentsFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutVendorsIdAttachmentsFilenameResponse(rsp)
}

// GetVendorsIdContactsWithResponse request returning *GetVendorsIdContactsResponse
func (c *ClientWithResponses) GetVendorsIdContactsWithResponse(ctx context.Context, id int, params *GetVendorsIdContactsParams, reqEditors ...RequestEditorFn) (*GetVendorsIdContactsResponse, error) {
	rsp, err := c.GetVendorsIdContacts(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVendorsIdContactsResponse(rsp)
}

// PostVendorsIdContactsWithBodyWithResponse request with arbitrary body returning *PostVendorsIdContactsResponse
func (c *ClientWithResponses) PostVendorsIdContactsWithBodyWithResponse(ctx context.Context, id int, params *PostVendorsIdContactsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVendorsIdContactsResponse, error) {
	rsp, err := c.PostVendorsIdContactsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVendorsIdContactsResponse(rsp)
}

func (c *ClientWithResponses) PostVendorsIdContactsWithResponse(ctx context.Context, id int, params *PostVendorsIdContactsParams, body PostVendorsIdContactsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVendorsIdContactsResponse, error) {
	rsp, err := c.PostVendorsIdContacts(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVendorsIdContactsResponse(rsp)
}

// DeleteVendorsIdContactsContactIdWithResponse request returning *DeleteVendorsIdContactsContactIdResponse
func (c *ClientWithResponses) DeleteVendorsIdContactsContactIdWithResponse(ctx context.Context, id int, contactId int, params *DeleteVendorsIdContactsContactIdParams, reqEditors ...RequestEditorFn) (*DeleteVendorsIdContactsContactIdResponse, error) {
	rsp, err := c.DeleteVendorsIdContactsContactId(ctx, id, contactId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVendorsIdContactsContactIdResponse(rsp)
}

// GetVendorsIdContactsContactIdWithResponse request returning *GetVendorsIdContactsContactIdResponse
func (c *ClientWithResponses) GetVendorsIdContactsContactIdWithResponse(ctx context.Context, id int, contactId int, reqEditors ...RequestEditorFn) (*GetVendorsIdContactsContactIdResponse, error) {
	rsp, err := c.GetVendorsIdContactsContactId(ctx, id, contactId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVendorsIdContactsContactIdResponse(rsp)
}

// PatchVendorsIdContactsContactIdWithBodyWithResponse request with arbitrary body returning *PatchVendorsIdContactsContactIdResponse
func (c *ClientWithResponses) PatchVendorsIdContactsContactIdWithBodyWithResponse(ctx context.Context, id int, contactId int, params *PatchVendorsIdContactsContactIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchVendorsIdContactsContactIdResponse, error) {
	rsp, err := c.PatchVendorsIdContactsContactIdWithBody(ctx, id, contactId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchVendorsIdContactsContactIdResponse(rsp)
}

func (c *ClientWithResponses) PatchVendorsIdContactsContactIdWithResponse(ctx context.Context, id int, contactId int, params *PatchVendorsIdContactsContactIdParams, body PatchVendorsIdContactsContactIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchVendorsIdContactsContactIdResponse, error) {
	rsp, err := c.PatchVendorsIdContactsContactId(ctx, id, contactId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchVendorsIdContactsContactIdResponse(rsp)
}

// PutVendorsIdThumbnailFilenameWithBodyWithResponse request with arbitrary body returning *PutVendorsIdThumbnailFilenameResponse
func (c *ClientWithResponses) PutVendorsIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutVendorsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutVendorsIdThumbnailFilenameResponse, error) {
	rsp, err := c.PutVendorsIdThumbnailFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutVendorsIdThumbnailFilenameResponse(rsp)
}

// GetVersionsWithResponse request returning *GetVersionsResponse
func (c *ClientWithResponses) GetVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionsResponse, error) {
	rsp, err := c.GetVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionsResponse(rsp)
}

// PostWorkPermitsIdSignWithBodyWithResponse request with arbitrary body returning *PostWorkPermitsIdSignResponse
func (c *ClientWithResponses) PostWorkPermitsIdSignWithBodyWithResponse(ctx context.Context, id int, params *PostWorkPermitsIdSignParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkPermitsIdSignResponse, error) {
	rsp, err := c.PostWorkPermitsIdSignWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkPermitsIdSignResponse(rsp)
}

func (c *ClientWithResponses) PostWorkPermitsIdSignWithResponse(ctx context.Context, id int, params *PostWorkPermitsIdSignParams, body PostWorkPermitsIdSignJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkPermitsIdSignResponse, error) {
	rsp, err := c.PostWorkPermitsIdSign(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkPermitsIdSignResponse(rsp)
}

// GetWorkordersWithResponse request returning *GetWorkordersResponse
func (c *ClientWithResponses) GetWorkordersWithResponse(ctx context.Context, params *GetWorkordersParams, reqEditors ...RequestEditorFn) (*GetWorkordersResponse, error) {
	rsp, err := c.GetWorkorders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkordersResponse(rsp)
}

// PostWorkordersWithBodyWithResponse request with arbitrary body returning *PostWorkordersResponse
func (c *ClientWithResponses) PostWorkordersWithBodyWithResponse(ctx context.Context, params *PostWorkordersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkordersResponse, error) {
	rsp, err := c.PostWorkordersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkordersResponse(rsp)
}

func (c *ClientWithResponses) PostWorkordersWithResponse(ctx context.Context, params *PostWorkordersParams, body PostWorkordersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkordersResponse, error) {
	rsp, err := c.PostWorkorders(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkordersResponse(rsp)
}

// DeleteWorkordersIdWithResponse request returning *DeleteWorkordersIdResponse
func (c *ClientWithResponses) DeleteWorkordersIdWithResponse(ctx context.Context, id int, params *DeleteWorkordersIdParams, reqEditors ...RequestEditorFn) (*DeleteWorkordersIdResponse, error) {
	rsp, err := c.DeleteWorkordersId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkordersIdResponse(rsp)
}

// GetWorkordersIdWithResponse request returning *GetWorkordersIdResponse
func (c *ClientWithResponses) GetWorkordersIdWithResponse(ctx context.Context, id int, params *GetWorkordersIdParams, reqEditors ...RequestEditorFn) (*GetWorkordersIdResponse, error) {
	rsp, err := c.GetWorkordersId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkordersIdResponse(rsp)
}

// PatchWorkordersIdWithBodyWithResponse request with arbitrary body returning *PatchWorkordersIdResponse
func (c *ClientWithResponses) PatchWorkordersIdWithBodyWithResponse(ctx context.Context, id int, params *PatchWorkordersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchWorkordersIdResponse, error) {
	rsp, err := c.PatchWorkordersIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchWorkordersIdResponse(rsp)
}

func (c *ClientWithResponses) PatchWorkordersIdWithResponse(ctx context.Context, id int, params *PatchWorkordersIdParams, body PatchWorkordersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchWorkordersIdResponse, error) {
	rsp, err := c.PatchWorkordersId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchWorkordersIdResponse(rsp)
}

// DeleteWorkordersIdAttachmentsFilenameWithResponse request returning *DeleteWorkordersIdAttachmentsFilenameResponse
func (c *ClientWithResponses) DeleteWorkordersIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeleteWorkordersIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeleteWorkordersIdAttachmentsFilenameResponse, error) {
	rsp, err := c.DeleteWorkordersIdAttachmentsFilename(ctx, id, filename, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkordersIdAttachmentsFilenameResponse(rsp)
}

// PutWorkordersIdAttachmentsFilenameWithBodyWithResponse request with arbitrary body returning *PutWorkordersIdAttachmentsFilenameResponse
func (c *ClientWithResponses) PutWorkordersIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutWorkordersIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWorkordersIdAttachmentsFilenameResponse, error) {
	rsp, err := c.PutWorkordersIdAttachmentsFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutWorkordersIdAttachmentsFilenameResponse(rsp)
}

// GetWorkordersIdCommentsWithResponse request returning *GetWorkordersIdCommentsResponse
func (c *ClientWithResponses) GetWorkordersIdCommentsWithResponse(ctx context.Context, id int, params *GetWorkordersIdCommentsParams, reqEditors ...RequestEditorFn) (*GetWorkordersIdCommentsResponse, error) {
	rsp, err := c.GetWorkordersIdComments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkordersIdCommentsResponse(rsp)
}

// PostWorkordersIdCommentsWithBodyWithResponse request with arbitrary body returning *PostWorkordersIdCommentsResponse
func (c *ClientWithResponses) PostWorkordersIdCommentsWithBodyWithResponse(ctx context.Context, id int, params *PostWorkordersIdCommentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkordersIdCommentsResponse, error) {
	rsp, err := c.PostWorkordersIdCommentsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkordersIdCommentsResponse(rsp)
}

func (c *ClientWithResponses) PostWorkordersIdCommentsWithResponse(ctx context.Context, id int, params *PostWorkordersIdCommentsParams, body PostWorkordersIdCommentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkordersIdCommentsResponse, error) {
	rsp, err := c.PostWorkordersIdComments(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkordersIdCommentsResponse(rsp)
}

// GetWorkordersIdCostsWithResponse request returning *GetWorkordersIdCostsResponse
func (c *ClientWithResponses) GetWorkordersIdCostsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetWorkordersIdCostsResponse, error) {
	rsp, err := c.GetWorkordersIdCosts(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkordersIdCostsResponse(rsp)
}

// PostWorkordersIdCostsWithBodyWithResponse request with arbitrary body returning *PostWorkordersIdCostsResponse
func (c *ClientWithResponses) PostWorkordersIdCostsWithBodyWithResponse(ctx context.Context, id int, params *PostWorkordersIdCostsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkordersIdCostsResponse, error) {
	rsp, err := c.PostWorkordersIdCostsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkordersIdCostsResponse(rsp)
}

func (c *ClientWithResponses) PostWorkordersIdCostsWithResponse(ctx context.Context, id int, params *PostWorkordersIdCostsParams, body PostWorkordersIdCostsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkordersIdCostsResponse, error) {
	rsp, err := c.PostWorkordersIdCosts(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkordersIdCostsResponse(rsp)
}

// PostWorkordersIdEmailsWithBodyWithResponse request with arbitrary body returning *PostWorkordersIdEmailsResponse
func (c *ClientWithResponses) PostWorkordersIdEmailsWithBodyWithResponse(ctx context.Context, id int, params *PostWorkordersIdEmailsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkordersIdEmailsResponse, error) {
	rsp, err := c.PostWorkordersIdEmailsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkordersIdEmailsResponse(rsp)
}

func (c *ClientWithResponses) PostWorkordersIdEmailsWithResponse(ctx context.Context, id int, params *PostWorkordersIdEmailsParams, body PostWorkordersIdEmailsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkordersIdEmailsResponse, error) {
	rsp, err := c.PostWorkordersIdEmails(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkordersIdEmailsResponse(rsp)
}

// DeleteWorkordersIdProcedureWithResponse request returning *DeleteWorkordersIdProcedureResponse
func (c *ClientWithResponses) DeleteWorkordersIdProcedureWithResponse(ctx context.Context, id int, params *DeleteWorkordersIdProcedureParams, reqEditors ...RequestEditorFn) (*DeleteWorkordersIdProcedureResponse, error) {
	rsp, err := c.DeleteWorkordersIdProcedure(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkordersIdProcedureResponse(rsp)
}

// DeleteWorkordersIdProcedureFieldsIndexAttachmentWithResponse request returning *DeleteWorkordersIdProcedureFieldsIndexAttachmentResponse
func (c *ClientWithResponses) DeleteWorkordersIdProcedureFieldsIndexAttachmentWithResponse(ctx context.Context, id int, index int, params *DeleteWorkordersIdProcedureFieldsIndexAttachmentParams, reqEditors ...RequestEditorFn) (*DeleteWorkordersIdProcedureFieldsIndexAttachmentResponse, error) {
	rsp, err := c.DeleteWorkordersIdProcedureFieldsIndexAttachment(ctx, id, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkordersIdProcedureFieldsIndexAttachmentResponse(rsp)
}

// PutWorkordersIdProcedureFieldsIndexAttachmentFilenameWithBodyWithResponse request with arbitrary body returning *PutWorkordersIdProcedureFieldsIndexAttachmentFilenameResponse
func (c *ClientWithResponses) PutWorkordersIdProcedureFieldsIndexAttachmentFilenameWithBodyWithResponse(ctx context.Context, id int, index int, filename string, params *PutWorkordersIdProcedureFieldsIndexAttachmentFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWorkordersIdProcedureFieldsIndexAttachmentFilenameResponse, error) {
	rsp, err := c.PutWorkordersIdProcedureFieldsIndexAttachmentFilenameWithBody(ctx, id, index, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutWorkordersIdProcedureFieldsIndexAttachmentFilenameResponse(rsp)
}

// PatchWorkordersIdStatusWithBodyWithResponse request with arbitrary body returning *PatchWorkordersIdStatusResponse
func (c *ClientWithResponses) PatchWorkordersIdStatusWithBodyWithResponse(ctx context.Context, id int, params *PatchWorkordersIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchWorkordersIdStatusResponse, error) {
	rsp, err := c.PatchWorkordersIdStatusWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchWorkordersIdStatusResponse(rsp)
}

func (c *ClientWithResponses) PatchWorkordersIdStatusWithResponse(ctx context.Context, id int, params *PatchWorkordersIdStatusParams, body PatchWorkordersIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchWorkordersIdStatusResponse, error) {
	rsp, err := c.PatchWorkordersIdStatus(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchWorkordersIdStatusResponse(rsp)
}

// GetWorkordersIdSubworkordersWithResponse request returning *GetWorkordersIdSubworkordersResponse
func (c *ClientWithResponses) GetWorkordersIdSubworkordersWithResponse(ctx context.Context, id int, params *GetWorkordersIdSubworkordersParams, reqEditors ...RequestEditorFn) (*GetWorkordersIdSubworkordersResponse, error) {
	rsp, err := c.GetWorkordersIdSubworkorders(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkordersIdSubworkordersResponse(rsp)
}

// PutWorkordersIdThumbnailFilenameWithBodyWithResponse request with arbitrary body returning *PutWorkordersIdThumbnailFilenameResponse
func (c *ClientWithResponses) PutWorkordersIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutWorkordersIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWorkordersIdThumbnailFilenameResponse, error) {
	rsp, err := c.PutWorkordersIdThumbnailFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutWorkordersIdThumbnailFilenameResponse(rsp)
}

// GetWorkrequestportalsWithResponse request returning *GetWorkrequestportalsResponse
func (c *ClientWithResponses) GetWorkrequestportalsWithResponse(ctx context.Context, params *GetWorkrequestportalsParams, reqEditors ...RequestEditorFn) (*GetWorkrequestportalsResponse, error) {
	rsp, err := c.GetWorkrequestportals(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkrequestportalsResponse(rsp)
}

// PostWorkrequestportalsWithBodyWithResponse request with arbitrary body returning *PostWorkrequestportalsResponse
func (c *ClientWithResponses) PostWorkrequestportalsWithBodyWithResponse(ctx context.Context, params *PostWorkrequestportalsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkrequestportalsResponse, error) {
	rsp, err := c.PostWorkrequestportalsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkrequestportalsResponse(rsp)
}

func (c *ClientWithResponses) PostWorkrequestportalsWithResponse(ctx context.Context, params *PostWorkrequestportalsParams, body PostWorkrequestportalsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkrequestportalsResponse, error) {
	rsp, err := c.PostWorkrequestportals(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkrequestportalsResponse(rsp)
}

// DeleteWorkrequestportalsIdWithResponse request returning *DeleteWorkrequestportalsIdResponse
func (c *ClientWithResponses) DeleteWorkrequestportalsIdWithResponse(ctx context.Context, id int, params *DeleteWorkrequestportalsIdParams, reqEditors ...RequestEditorFn) (*DeleteWorkrequestportalsIdResponse, error) {
	rsp, err := c.DeleteWorkrequestportalsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkrequestportalsIdResponse(rsp)
}

// GetWorkrequestportalsIdWithResponse request returning *GetWorkrequestportalsIdResponse
func (c *ClientWithResponses) GetWorkrequestportalsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetWorkrequestportalsIdResponse, error) {
	rsp, err := c.GetWorkrequestportalsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkrequestportalsIdResponse(rsp)
}

// PatchWorkrequestportalsIdWithBodyWithResponse request with arbitrary body returning *PatchWorkrequestportalsIdResponse
func (c *ClientWithResponses) PatchWorkrequestportalsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchWorkrequestportalsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchWorkrequestportalsIdResponse, error) {
	rsp, err := c.PatchWorkrequestportalsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchWorkrequestportalsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchWorkrequestportalsIdWithResponse(ctx context.Context, id int, params *PatchWorkrequestportalsIdParams, body PatchWorkrequestportalsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchWorkrequestportalsIdResponse, error) {
	rsp, err := c.PatchWorkrequestportalsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchWorkrequestportalsIdResponse(rsp)
}

// GetWorkrequestsWithResponse request returning *GetWorkrequestsResponse
func (c *ClientWithResponses) GetWorkrequestsWithResponse(ctx context.Context, params *GetWorkrequestsParams, reqEditors ...RequestEditorFn) (*GetWorkrequestsResponse, error) {
	rsp, err := c.GetWorkrequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkrequestsResponse(rsp)
}

// PostWorkrequestsWithBodyWithResponse request with arbitrary body returning *PostWorkrequestsResponse
func (c *ClientWithResponses) PostWorkrequestsWithBodyWithResponse(ctx context.Context, params *PostWorkrequestsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkrequestsResponse, error) {
	rsp, err := c.PostWorkrequestsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkrequestsResponse(rsp)
}

func (c *ClientWithResponses) PostWorkrequestsWithResponse(ctx context.Context, params *PostWorkrequestsParams, body PostWorkrequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkrequestsResponse, error) {
	rsp, err := c.PostWorkrequests(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkrequestsResponse(rsp)
}

// DeleteWorkrequestsIdWithResponse request returning *DeleteWorkrequestsIdResponse
func (c *ClientWithResponses) DeleteWorkrequestsIdWithResponse(ctx context.Context, id int, params *DeleteWorkrequestsIdParams, reqEditors ...RequestEditorFn) (*DeleteWorkrequestsIdResponse, error) {
	rsp, err := c.DeleteWorkrequestsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkrequestsIdResponse(rsp)
}

// GetWorkrequestsIdWithResponse request returning *GetWorkrequestsIdResponse
func (c *ClientWithResponses) GetWorkrequestsIdWithResponse(ctx context.Context, id int, params *GetWorkrequestsIdParams, reqEditors ...RequestEditorFn) (*GetWorkrequestsIdResponse, error) {
	rsp, err := c.GetWorkrequestsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkrequestsIdResponse(rsp)
}

// PatchWorkrequestsIdWithBodyWithResponse request with arbitrary body returning *PatchWorkrequestsIdResponse
func (c *ClientWithResponses) PatchWorkrequestsIdWithBodyWithResponse(ctx context.Context, id int, params *PatchWorkrequestsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchWorkrequestsIdResponse, error) {
	rsp, err := c.PatchWorkrequestsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchWorkrequestsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchWorkrequestsIdWithResponse(ctx context.Context, id int, params *PatchWorkrequestsIdParams, body PatchWorkrequestsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchWorkrequestsIdResponse, error) {
	rsp, err := c.PatchWorkrequestsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchWorkrequestsIdResponse(rsp)
}

// DeleteWorkrequestsIdAttachmentsFilenameWithResponse request returning *DeleteWorkrequestsIdAttachmentsFilenameResponse
func (c *ClientWithResponses) DeleteWorkrequestsIdAttachmentsFilenameWithResponse(ctx context.Context, id int, filename string, params *DeleteWorkrequestsIdAttachmentsFilenameParams, reqEditors ...RequestEditorFn) (*DeleteWorkrequestsIdAttachmentsFilenameResponse, error) {
	rsp, err := c.DeleteWorkrequestsIdAttachmentsFilename(ctx, id, filename, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkrequestsIdAttachmentsFilenameResponse(rsp)
}

// PutWorkrequestsIdAttachmentsFilenameWithBodyWithResponse request with arbitrary body returning *PutWorkrequestsIdAttachmentsFilenameResponse
func (c *ClientWithResponses) PutWorkrequestsIdAttachmentsFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutWorkrequestsIdAttachmentsFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWorkrequestsIdAttachmentsFilenameResponse, error) {
	rsp, err := c.PutWorkrequestsIdAttachmentsFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutWorkrequestsIdAttachmentsFilenameResponse(rsp)
}

// PutWorkrequestsIdThumbnailFilenameWithBodyWithResponse request with arbitrary body returning *PutWorkrequestsIdThumbnailFilenameResponse
func (c *ClientWithResponses) PutWorkrequestsIdThumbnailFilenameWithBodyWithResponse(ctx context.Context, id int, filename string, params *PutWorkrequestsIdThumbnailFilenameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWorkrequestsIdThumbnailFilenameResponse, error) {
	rsp, err := c.PutWorkrequestsIdThumbnailFilenameWithBody(ctx, id, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutWorkrequestsIdThumbnailFilenameResponse(rsp)
}

// ParseGetAssetcriticalitiesResponse parses an HTTP response from a GetAssetcriticalitiesWithResponse call
func ParseGetAssetcriticalitiesResponse(rsp *http.Response) (*GetAssetcriticalitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetcriticalitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AssetCriticalities []struct {
				// Id Global ID of the criticality. <a href='https://help.getmaintainx.com/about-assets#criticality' target='_blank'>Learn more</a>
				Id int `json:"id"`

				// Label The label of the criticality. <a href='https://help.getmaintainx.com/about-assets#criticality' target='_blank'>Learn more</a>
				Label string `json:"label"`

				// Level The level of the criticality. <a href='https://help.getmaintainx.com/about-assets#criticality' target='_blank'>Learn more</a>
				Level int `json:"level"`
			} `json:"assetCriticalities"`

			// NextCursor The cursor to retrieve the next page of Asset Criticalities.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Asset Criticalities.
			NextPageUrl *string `json:"nextPageUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAssetcriticalitiesIdResponse parses an HTTP response from a GetAssetcriticalitiesIdWithResponse call
func ParseGetAssetcriticalitiesIdResponse(rsp *http.Response) (*GetAssetcriticalitiesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetcriticalitiesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AssetCriticality struct {
				// Id Global ID of the criticality. <a href='https://help.getmaintainx.com/about-assets#criticality' target='_blank'>Learn more</a>
				Id int `json:"id"`

				// Label The label of the criticality. <a href='https://help.getmaintainx.com/about-assets#criticality' target='_blank'>Learn more</a>
				Label string `json:"label"`

				// Level The level of the criticality. <a href='https://help.getmaintainx.com/about-assets#criticality' target='_blank'>Learn more</a>
				Level int `json:"level"`
			} `json:"assetCriticality"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAssetcustomstatusesResponse parses an HTTP response from a GetAssetcustomstatusesWithResponse call
func ParseGetAssetcustomstatusesResponse(rsp *http.Response) (*GetAssetcustomstatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetcustomstatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AssetCustomStatuses []struct {
				BaseAssetStatus GetAssetcustomstatuses200AssetCustomStatusesBaseAssetStatus `json:"baseAssetStatus"`

				// CreatedAt Date & time at which the asset custom status was created.
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// DowntimeType Downtime type on asset custom statuses will always return null. Use downtime type on asset status instead.
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				DowntimeType *GetAssetcustomstatuses200AssetCustomStatusesDowntimeType `json:"downtimeType"`
				Id           float32                                                   `json:"id"`
				Label        string                                                    `json:"label"`

				// UpdatedAt Date & time at which the asset custom status was last updated.
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"assetCustomStatuses"`

			// NextCursor The cursor to retrieve the next page of Asset Custom Statuses.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Asset Custom Statuses.
			NextPageUrl *string `json:"nextPageUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostAssetcustomstatusesResponse parses an HTTP response from a PostAssetcustomstatusesWithResponse call
func ParsePostAssetcustomstatusesResponse(rsp *http.Response) (*PostAssetcustomstatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAssetcustomstatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Id float32 `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                         `json:"error"`
				FieldPath  *string                                        `json:"fieldPath"`
				FieldValue *PostAssetcustomstatuses_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteAssetcustomstatusesIdResponse parses an HTTP response from a DeleteAssetcustomstatusesIdWithResponse call
func ParseDeleteAssetcustomstatusesIdResponse(rsp *http.Response) (*DeleteAssetcustomstatusesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAssetcustomstatusesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                             `json:"error"`
				FieldPath  *string                                            `json:"fieldPath"`
				FieldValue *DeleteAssetcustomstatusesId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAssetcustomstatusesIdResponse parses an HTTP response from a GetAssetcustomstatusesIdWithResponse call
func ParseGetAssetcustomstatusesIdResponse(rsp *http.Response) (*GetAssetcustomstatusesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetcustomstatusesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AssetCustomStatus struct {
				BaseAssetStatus GetAssetcustomstatusesId200AssetCustomStatusBaseAssetStatus `json:"baseAssetStatus"`

				// CreatedAt Date & time at which the asset custom status was created.
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// DeletedAt Date at which the asset custom status was deleted.
				DeletedAt *time.Time `json:"deletedAt"`

				// DowntimeType Downtime type on asset custom statuses will always return null. Use downtime type on asset status instead.
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				DowntimeType *GetAssetcustomstatusesId200AssetCustomStatusDowntimeType `json:"downtimeType"`
				Id           *float32                                                  `json:"id,omitempty"`
				Label        string                                                    `json:"label"`

				// UpdatedAt Date & time at which the asset custom status was last updated.
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"assetCustomStatus"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchAssetcustomstatusesIdResponse parses an HTTP response from a PatchAssetcustomstatusesIdWithResponse call
func ParsePatchAssetcustomstatusesIdResponse(rsp *http.Response) (*PatchAssetcustomstatusesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchAssetcustomstatusesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Assetcustomstatus *struct {
				BaseAssetStatus *PatchAssetcustomstatusesId200AssetcustomstatusBaseAssetStatus `json:"baseAssetStatus,omitempty"`

				// CreatedAt Date & time at which the asset custom status was created.
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// DeletedAt Date at which the asset custom status was deleted.
				DeletedAt *time.Time `json:"deletedAt"`
				Id        float32    `json:"id"`
				Label     *string    `json:"label,omitempty"`

				// UpdatedAt Date & time at which the asset custom status was last updated.
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"assetcustomstatus,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAssetsResponse parses an HTTP response from a GetAssetsWithResponse call
func ParseGetAssetsResponse(rsp *http.Response) (*GetAssetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Assets []struct {
				// AssetTypes List of asset types (expand with query parameter)
				AssetTypes *[]string `json:"assetTypes,omitempty"`

				// Barcode String encoded barcode (expand with query parameter)
				Barcode *string `json:"barcode,omitempty"`

				// CreatedAt Date & time at which the asset was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId ID of the asset creator
				CreatorId *int `json:"creatorId"`

				// CriticalityId ID of the criticality of the asset
				CriticalityId *int `json:"criticalityId"`

				// Depreciation Depreciation information of the asset (expand with query parameter)
				Depreciation *struct {
					// AccumulatedDepreciation Accumulated depreciation of the asset.
					AccumulatedDepreciation *float64 `json:"accumulatedDepreciation"`

					// AnnualDepreciation Annual depreciation of the asset.
					AnnualDepreciation *float64 `json:"annualDepreciation"`

					// ArchivedAt Date & time at which the asset depreciation was archived.
					ArchivedAt *time.Time `json:"archivedAt"`

					// CreatedAt Date & time at which the asset depreciation was created.
					CreatedAt *time.Time `json:"createdAt"`

					// CurrentBookValue Current book value of the asset.
					CurrentBookValue *float64 `json:"currentBookValue"`

					// DepreciationStartDate Date at which the asset depreciation started.
					DepreciationStartDate *time.Time `json:"depreciationStartDate"`

					// Id Global ID of the asset depreciation.
					Id *float32 `json:"id,omitempty"`

					// PurchaseDate Date & time at which the asset was purchased.
					PurchaseDate *time.Time `json:"purchaseDate"`

					// PurchasePrice Purchase price of the asset.
					PurchasePrice *float64 `json:"purchasePrice"`

					// SalvageValue Salvage value of the asset.
					SalvageValue *float64 `json:"salvageValue"`

					// UsefulLifeYears Useful life of the asset in years.
					UsefulLifeYears *float64 `json:"usefulLifeYears"`

					// YearsDepreciated Years depreciated of the asset.
					YearsDepreciated *float64 `json:"yearsDepreciated"`
				} `json:"depreciation,omitempty"`
				Description *string `json:"description"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "My Custom Field") (expand with query parameter)
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the asset
				Id int `json:"id"`

				// LocationId ID of the location where the asset is located
				LocationId *int `json:"locationId"`

				// Manufacturer Name of the manufacturer of the asset (expand with query parameter)
				Manufacturer *string `json:"manufacturer,omitempty"`

				// Model Name of the model of the asset (expand with query parameter)
				Model *string `json:"model,omitempty"`
				Name  string  `json:"name"`

				// ParentId ID of the parent asset
				ParentId *int `json:"parentId"`

				// SerialNumber Serial number of the asset
				SerialNumber *string `json:"serialNumber"`

				// Status Status information of the asset (expand with query parameter)
				Status *struct {
					// CreatedAt Date & time at which the asset status was created.
					CreatedAt *time.Time `json:"createdAt,omitempty"`

					// CustomStatus Custom status assigned to asset.
					CustomStatus *struct {
						// CreatedAt Date & time at which the asset custom status was created.
						CreatedAt *time.Time `json:"createdAt,omitempty"`

						// DeletedAt Date at which the asset custom status was deleted.
						DeletedAt *time.Time `json:"deletedAt"`
						Id        *float32   `json:"id,omitempty"`
						Label     string     `json:"label"`

						// UpdatedAt Date & time at which the asset custom status was last updated.
						UpdatedAt *time.Time `json:"updatedAt,omitempty"`
					} `json:"customStatus"`

					// DeletedAt Date & time at which the asset status was deleted.
					DeletedAt    *time.Time                            `json:"deletedAt"`
					Description  *string                               `json:"description"`
					DowntimeType *GetAssets200AssetsStatusDowntimeType `json:"downtimeType"`

					// EndedAt Asset status effective end date.
					EndedAt *time.Time `json:"endedAt"`

					// Id Global ID of the asset status.
					Id *float32 `json:"id,omitempty"`

					// StartedAt Asset status effective start date.
					StartedAt *time.Time `json:"startedAt,omitempty"`

					// Status Asset status value.
					Status *GetAssets200AssetsStatusStatus `json:"status,omitempty"`

					// UpdatedAt Date & time at which the asset status was last updated.
					UpdatedAt *time.Time `json:"updatedAt,omitempty"`
				} `json:"status,omitempty"`

				// TeamIds List of teams responsible for the asset (expand with query parameter)
				TeamIds *[]int `json:"teamIds,omitempty"`

				// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`

				// VendorIds Vendor IDs (expand with query parameter)
				VendorIds *[]float32 `json:"vendorIds,omitempty"`
			} `json:"assets"`

			// NextCursor The cursor to retrieve the next page of Assets.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Assets.
			NextPageUrl *string `json:"nextPageUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostAssetsResponse parses an HTTP response from a PostAssetsWithResponse call
func ParsePostAssetsResponse(rsp *http.Response) (*PostAssetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the asset
			Id int `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                            `json:"error"`
				FieldPath  *string                           `json:"fieldPath"`
				FieldValue *PostAssets_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostAssetsAssetIdStatusResponse parses an HTTP response from a PostAssetsAssetIdStatusWithResponse call
func ParsePostAssetsAssetIdStatusResponse(rsp *http.Response) (*PostAssetsAssetIdStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAssetsAssetIdStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			AssetStatus struct {
				// CustomStatusId Id of the custom status assigned to asset.
				CustomStatusId *float32                                           `json:"customStatusId"`
				DowntimeType   *PostAssetsAssetIdStatus201AssetStatusDowntimeType `json:"downtimeType"`

				// Id Global ID of the asset status.
				Id float32 `json:"id"`

				// StartedAt Asset status effective start date.
				StartedAt time.Time `json:"startedAt"`

				// Status Asset status value.
				Status PostAssetsAssetIdStatus201AssetStatusStatus `json:"status"`

				// UpdatedAt Date & time at which the asset status was last updated.
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"assetStatus"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                         `json:"error"`
				FieldPath  *string                                        `json:"fieldPath"`
				FieldValue *PostAssetsAssetIdStatus_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAssetsIdResponse parses an HTTP response from a DeleteAssetsIdWithResponse call
func ParseDeleteAssetsIdResponse(rsp *http.Response) (*DeleteAssetsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAssetsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                `json:"error"`
				FieldPath  *string                               `json:"fieldPath"`
				FieldValue *DeleteAssetsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAssetsIdResponse parses an HTTP response from a GetAssetsIdWithResponse call
func ParseGetAssetsIdResponse(rsp *http.Response) (*GetAssetsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Asset struct {
				// AssetTypes List of asset types
				AssetTypes *[]string `json:"assetTypes,omitempty"`

				// Attachments List of attachments linked to the asset
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// Barcode String encoded barcode
				Barcode *string `json:"barcode"`

				// ChildrenIds IDs of the asset's children
				ChildrenIds *[]float32 `json:"childrenIds"`

				// CreatedAt Date & time at which the asset was created
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// CreatorId ID of the asset creator
				CreatorId *int `json:"creatorId"`

				// CriticalityId ID of the criticality of the asset
				CriticalityId *int `json:"criticalityId"`

				// CurrentOwnerId Organization id that currently has the active version of this asset
				CurrentOwnerId *float32 `json:"currentOwnerId,omitempty"`

				// DeletedAt Date at which the asset was deleted
				DeletedAt *time.Time `json:"deletedAt"`

				// Depreciation Depreciation information of the asset
				Depreciation *struct {
					// AccumulatedDepreciation Accumulated depreciation of the asset.
					AccumulatedDepreciation *float64 `json:"accumulatedDepreciation"`

					// AnnualDepreciation Annual depreciation of the asset.
					AnnualDepreciation *float64 `json:"annualDepreciation"`

					// ArchivedAt Date & time at which the asset depreciation was archived.
					ArchivedAt *time.Time `json:"archivedAt"`

					// CreatedAt Date & time at which the asset depreciation was created.
					CreatedAt *time.Time `json:"createdAt"`

					// CurrentBookValue Current book value of the asset.
					CurrentBookValue *float64 `json:"currentBookValue"`

					// DepreciationStartDate Date at which the asset depreciation started.
					DepreciationStartDate *time.Time `json:"depreciationStartDate"`

					// Id Global ID of the asset depreciation.
					Id *float32 `json:"id,omitempty"`

					// PurchaseDate Date & time at which the asset was purchased.
					PurchaseDate *time.Time `json:"purchaseDate"`

					// PurchasePrice Purchase price of the asset.
					PurchasePrice *float64 `json:"purchasePrice"`

					// SalvageValue Salvage value of the asset.
					SalvageValue *float64 `json:"salvageValue"`

					// UsefulLifeYears Useful life of the asset in years.
					UsefulLifeYears *float64 `json:"usefulLifeYears"`

					// YearsDepreciated Years depreciated of the asset.
					YearsDepreciated *float64 `json:"yearsDepreciated"`
				} `json:"depreciation"`
				Description *string `json:"description"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "My Custom Field")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// GlobalUuid Global unique identifier of the asset used to identify assets as they are being transferred
				GlobalUuid *string `json:"globalUuid"`

				// Id Global ID of the asset
				Id int `json:"id"`

				// LocationId ID of the location where the asset is located
				LocationId *int `json:"locationId"`

				// Manufacturer Name of the manufacturer of the asset
				Manufacturer *string `json:"manufacturer"`

				// Model Name of the model of the asset
				Model *string `json:"model"`
				Name  string  `json:"name"`

				// ParentId ID of the parent asset
				ParentId *int `json:"parentId"`

				// SerialNumber Serial number of the asset
				SerialNumber *string `json:"serialNumber"`

				// Status Status information of the asset
				Status *struct {
					// CreatedAt Date & time at which the asset status was created.
					CreatedAt *time.Time `json:"createdAt,omitempty"`

					// CustomStatus Custom status assigned to asset.
					CustomStatus *struct {
						// CreatedAt Date & time at which the asset custom status was created.
						CreatedAt *time.Time `json:"createdAt,omitempty"`

						// DeletedAt Date at which the asset custom status was deleted.
						DeletedAt *time.Time `json:"deletedAt"`

						// DowntimeType Downtime type on asset custom statuses will always return null. Use downtime type on asset status instead.
						// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
						DowntimeType *GetAssetsId200AssetStatusCustomStatusDowntimeType `json:"downtimeType"`
						Id           *float32                                           `json:"id,omitempty"`
						Label        string                                             `json:"label"`

						// UpdatedAt Date & time at which the asset custom status was last updated.
						UpdatedAt *time.Time `json:"updatedAt,omitempty"`
					} `json:"customStatus"`

					// CustomStatusId Please use customStatus instead.
					// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
					CustomStatusId *float32 `json:"customStatusId"`

					// DeletedAt Date & time at which the asset status was deleted.
					DeletedAt    *time.Time                             `json:"deletedAt"`
					Description  *string                                `json:"description"`
					DowntimeType *GetAssetsId200AssetStatusDowntimeType `json:"downtimeType"`

					// EndedAt Asset status effective end date.
					EndedAt *time.Time `json:"endedAt"`

					// Id Global ID of the asset status.
					Id *float32 `json:"id,omitempty"`

					// StartedAt Asset status effective start date.
					StartedAt *time.Time `json:"startedAt,omitempty"`

					// Status Asset status value.
					Status *GetAssetsId200AssetStatusStatus `json:"status,omitempty"`

					// UpdatedAt Date & time at which the asset status was last updated.
					UpdatedAt *time.Time `json:"updatedAt,omitempty"`
				} `json:"status"`

				// TeamIds List of teams responsible for the asset
				TeamIds   *[]int `json:"teamIds,omitempty"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`

				// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`

				// VendorIds Vendor IDs
				VendorIds *[]float32 `json:"vendorIds,omitempty"`
			} `json:"asset"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchAssetsIdResponse parses an HTTP response from a PatchAssetsIdWithResponse call
func ParsePatchAssetsIdResponse(rsp *http.Response) (*PatchAssetsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchAssetsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Asset struct {
				// AssetTypes List of asset types
				AssetTypes *[]string `json:"assetTypes,omitempty"`

				// Attachments List of attachments linked to the asset
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// Barcode String encoded barcode
				Barcode *string `json:"barcode"`

				// ChildrenIds IDs of the asset's children
				ChildrenIds *[]float32 `json:"childrenIds"`

				// CreatedAt Date & time at which the asset was created
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// CreatorId ID of the asset creator
				CreatorId *int `json:"creatorId"`

				// CriticalityId ID of the criticality of the asset
				CriticalityId *int `json:"criticalityId"`

				// CurrentOwnerId Organization id that currently has the active version of this asset
				CurrentOwnerId *float32 `json:"currentOwnerId,omitempty"`

				// DeletedAt Date at which the asset was deleted
				DeletedAt *time.Time `json:"deletedAt"`

				// Depreciation Depreciation information of the asset
				Depreciation *struct {
					// AccumulatedDepreciation Accumulated depreciation of the asset.
					AccumulatedDepreciation *float64 `json:"accumulatedDepreciation"`

					// AnnualDepreciation Annual depreciation of the asset.
					AnnualDepreciation *float64 `json:"annualDepreciation"`

					// ArchivedAt Date & time at which the asset depreciation was archived.
					ArchivedAt *time.Time `json:"archivedAt"`

					// CreatedAt Date & time at which the asset depreciation was created.
					CreatedAt *time.Time `json:"createdAt"`

					// CurrentBookValue Current book value of the asset.
					CurrentBookValue *float64 `json:"currentBookValue"`

					// DepreciationStartDate Date at which the asset depreciation started.
					DepreciationStartDate *time.Time `json:"depreciationStartDate"`

					// Id Global ID of the asset depreciation.
					Id *float32 `json:"id,omitempty"`

					// PurchaseDate Date & time at which the asset was purchased.
					PurchaseDate *time.Time `json:"purchaseDate"`

					// PurchasePrice Purchase price of the asset.
					PurchasePrice *float64 `json:"purchasePrice"`

					// SalvageValue Salvage value of the asset.
					SalvageValue *float64 `json:"salvageValue"`

					// UsefulLifeYears Useful life of the asset in years.
					UsefulLifeYears *float64 `json:"usefulLifeYears"`

					// YearsDepreciated Years depreciated of the asset.
					YearsDepreciated *float64 `json:"yearsDepreciated"`
				} `json:"depreciation"`
				Description *string `json:"description"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "My Custom Field")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// GlobalUuid Global unique identifier of the asset used to identify assets as they are being transferred
				GlobalUuid *string `json:"globalUuid"`

				// Id Global ID of the asset
				Id int `json:"id"`

				// LocationId ID of the location where the asset is located
				LocationId *int `json:"locationId"`

				// Manufacturer Name of the manufacturer of the asset
				Manufacturer *string `json:"manufacturer"`

				// Model Name of the model of the asset
				Model *string `json:"model"`
				Name  string  `json:"name"`

				// ParentId ID of the parent asset
				ParentId *int `json:"parentId"`

				// SerialNumber Serial number of the asset
				SerialNumber *string `json:"serialNumber"`

				// TeamIds List of teams responsible for the asset
				TeamIds   *[]int `json:"teamIds,omitempty"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`

				// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`

				// VendorIds Vendor IDs
				VendorIds *[]float32 `json:"vendorIds,omitempty"`
			} `json:"asset"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                               `json:"error"`
				FieldPath  *string                              `json:"fieldPath"`
				FieldValue *PatchAssetsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAssetsIdAttachmentsFilenameResponse parses an HTTP response from a DeleteAssetsIdAttachmentsFilenameWithResponse call
func ParseDeleteAssetsIdAttachmentsFilenameResponse(rsp *http.Response) (*DeleteAssetsIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAssetsIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutAssetsIdAttachmentsFilenameResponse parses an HTTP response from a PutAssetsIdAttachmentsFilenameWithResponse call
func ParsePutAssetsIdAttachmentsFilenameResponse(rsp *http.Response) (*PutAssetsIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAssetsIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParsePutAssetsIdThumbnailFilenameResponse parses an HTTP response from a PutAssetsIdThumbnailFilenameWithResponse call
func ParsePutAssetsIdThumbnailFilenameResponse(rsp *http.Response) (*PutAssetsIdThumbnailFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAssetsIdThumbnailFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                              `json:"error"`
				FieldPath  *string                                             `json:"fieldPath"`
				FieldValue *PutAssetsIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseGetAssetstatusesResponse parses an HTTP response from a GetAssetstatusesWithResponse call
func ParseGetAssetstatusesResponse(rsp *http.Response) (*GetAssetstatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetstatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AssetStatuses []struct {
				// AssetId Global Parent asset ID of the asset status.
				AssetId *float32 `json:"assetId,omitempty"`

				// CreatedAt Date & time at which the asset status was created. This is the default sort by field, by descending (newest firsts)
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// CreatorId The Creator ID of the asset status.
				CreatorId *float32 `json:"creatorId,omitempty"`

				// CustomStatusId Id of the custom status assigned to asset.
				CustomStatusId *float32 `json:"customStatusId"`

				// DeletedAt Date & time at which the asset status was deleted.
				DeletedAt *time.Time `json:"deletedAt"`

				// Description Description of the asset status.
				Description *string `json:"description"`

				// DowntimeType Downtime type of the asset status.
				DowntimeType *GetAssetstatuses200AssetStatusesDowntimeType `json:"downtimeType"`

				// EndedAt Date & time at which the asset status ended at. Null means this status is still active, and is the current one.
				EndedAt *time.Time `json:"endedAt"`

				// Id Global ID of the asset status.
				Id *float32 `json:"id,omitempty"`

				// OrganizationId The Organization ID of the asset status.
				OrganizationId *float32 `json:"organizationId,omitempty"`

				// StartedAt Date & time at which the asset status was started at.
				StartedAt *time.Time `json:"startedAt,omitempty"`

				// Status Asset status value.
				Status *GetAssetstatuses200AssetStatusesStatus `json:"status,omitempty"`

				// UpdatedAt Date & time at which the asset status was last updated.
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`

				// UpdaterId The Updater ID of the asset status.
				UpdaterId *float32 `json:"updaterId"`
			} `json:"assetStatuses"`

			// NextCursor The cursor to retrieve the next page of Asset Statuses.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Asset Statuses.
			NextPageUrl *string `json:"nextPageUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePatchAssetstatusesIdResponse parses an HTTP response from a PatchAssetstatusesIdWithResponse call
func ParsePatchAssetstatusesIdResponse(rsp *http.Response) (*PatchAssetstatusesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchAssetstatusesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AssetStatus struct {
				// CreatedAt Date & time at which the asset status was created.
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// CustomStatusId Id of the custom status assigned to asset.
				CustomStatusId *float32 `json:"customStatusId"`

				// DeletedAt Date & time at which the asset status was deleted.
				DeletedAt    *time.Time                                      `json:"deletedAt"`
				Description  *string                                         `json:"description"`
				DowntimeType *PatchAssetstatusesId200AssetStatusDowntimeType `json:"downtimeType"`

				// EndedAt Asset status effective end date.
				EndedAt *time.Time `json:"endedAt"`

				// Id Global ID of the asset status.
				Id float32 `json:"id"`

				// StartedAt Asset status effective start date.
				StartedAt time.Time `json:"startedAt"`

				// Status Asset status value.
				Status *PatchAssetstatusesId200AssetStatusStatus `json:"status,omitempty"`

				// UpdatedAt Date & time at which the asset status was last updated.
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`
			} `json:"assetStatus"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                      `json:"error"`
				FieldPath  *string                                     `json:"fieldPath"`
				FieldValue *PatchAssetstatusesId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                      `json:"error"`
				FieldPath  *string                                     `json:"fieldPath"`
				FieldValue *PatchAssetstatusesId_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCategoriesResponse parses an HTTP response from a GetCategoriesWithResponse call
func ParseGetCategoriesResponse(rsp *http.Response) (*GetCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Categories []struct {
				// Description Description field for additional information.
				Description *string `json:"description,omitempty"`

				// Id Global ID of the category.
				Id int `json:"id"`

				// Label Label used when displaying the category.
				Label string `json:"label"`
			} `json:"categories"`

			// NextCursor The cursor to retrieve the next page of Categories.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Categories.
			NextPageUrl *string `json:"nextPageUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostCategoriesResponse parses an HTTP response from a PostCategoriesWithResponse call
func ParsePostCategoriesResponse(rsp *http.Response) (*PostCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the category.
			Id int `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                `json:"error"`
				FieldPath  *string                               `json:"fieldPath"`
				FieldValue *PostCategories_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteCategoriesIdResponse parses an HTTP response from a DeleteCategoriesIdWithResponse call
func ParseDeleteCategoriesIdResponse(rsp *http.Response) (*DeleteCategoriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCategoriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                    `json:"error"`
				FieldPath  *string                                   `json:"fieldPath"`
				FieldValue *DeleteCategoriesId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCategoriesIdResponse parses an HTTP response from a GetCategoriesIdWithResponse call
func ParseGetCategoriesIdResponse(rsp *http.Response) (*GetCategoriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Category struct {
				// Description Description field for additional information.
				Description *string `json:"description,omitempty"`

				// Id Global ID of the category.
				Id int `json:"id"`

				// Label Label used when displaying the category.
				Label string `json:"label"`

				// UpdatedAt Date & time at which the category was last updated.
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`

				// WorkOrderCount The amount of work order using that category in your organization.
				WorkOrderCount *int `json:"workOrderCount,omitempty"`
			} `json:"category"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchCategoriesIdResponse parses an HTTP response from a PatchCategoriesIdWithResponse call
func ParsePatchCategoriesIdResponse(rsp *http.Response) (*PatchCategoriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchCategoriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Category struct {
				// Description Description field for additional information.
				Description *string `json:"description,omitempty"`

				// Id Global ID of the category.
				Id *int `json:"id,omitempty"`

				// Label Label used when displaying the category.
				Label string `json:"label"`

				// UpdatedAt Date & time at which the category was last updated.
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`

				// WorkOrderCount The amount of work order using that category in your organization.
				WorkOrderCount *int `json:"workOrderCount,omitempty"`
			} `json:"category"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                   `json:"error"`
				FieldPath  *string                                  `json:"fieldPath"`
				FieldValue *PatchCategoriesId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetConversationsResponse parses an HTTP response from a GetConversationsWithResponse call
func ParseGetConversationsResponse(rsp *http.Response) (*GetConversationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConversationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Conversations []struct {
				// Id Global ID of the conversation
				Id float32 `json:"id"`

				// Name Display name of the conversation
				Name *string `json:"name"`

				// Type Type of conversation
				Type GetConversations200ConversationsType `json:"type"`
			} `json:"conversations"`

			// NextCursor The cursor to retrieve the next page of Conversations.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Conversations.
			NextPageUrl *string `json:"nextPageUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetConversationsIdMembersResponse parses an HTTP response from a GetConversationsIdMembersWithResponse call
func ParseGetConversationsIdMembersResponse(rsp *http.Response) (*GetConversationsIdMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConversationsIdMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Members []struct {
				FirstName string `json:"firstName"`

				// Id Global ID of the user
				Id       int    `json:"id"`
				LastName string `json:"lastName"`
			} `json:"members"`

			// NextCursor The cursor to retrieve the next page of Members.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Members.
			NextPageUrl *string `json:"nextPageUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostConversationsIdMessagesResponse parses an HTTP response from a PostConversationsIdMessagesWithResponse call
func ParsePostConversationsIdMessagesResponse(rsp *http.Response) (*PostConversationsIdMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostConversationsIdMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the message
			Id float32 `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                             `json:"error"`
				FieldPath  *string                                            `json:"fieldPath"`
				FieldValue *PostConversationsIdMessages_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCustomfieldsEntityResponse parses an HTTP response from a GetCustomfieldsEntityWithResponse call
func ParseGetCustomfieldsEntityResponse(rsp *http.Response) (*GetCustomfieldsEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomfieldsEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Id ID of the custom field
			Id float32 `json:"id"`

			// Label The label of the custom field
			Label string `json:"label"`

			// Options The possible choices to the field (if applicable).
			Options *[]string `json:"options,omitempty"`

			// Required This field is marked as required. This only affect the frontend.
			Required *bool `json:"required"`

			// SortOrder A weighted value used to sort the custom fields. Fields are sorted lowest to highest. This is different from sortIndex.
			SortOrder int                          `json:"sortOrder"`
			Type      GetCustomfieldsEntity200Type `json:"type"`

			// Unlisted This field is marked as unlisted. Once unlisted it will only be editable through the Rest API. When the custom field contains data, it will be displayed in the frontend; otherwise, it will remain hidden.
			Unlisted *bool `json:"unlisted"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                       `json:"error"`
				FieldPath  *string                                      `json:"fieldPath"`
				FieldValue *GetCustomfieldsEntity_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostCustomfieldsEntityResponse parses an HTTP response from a PostCustomfieldsEntityWithResponse call
func ParsePostCustomfieldsEntityResponse(rsp *http.Response) (*PostCustomfieldsEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomfieldsEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Id ID of the custom field
			Id float32 `json:"id"`

			// Label The label of the custom field
			Label string `json:"label"`

			// Options The possible choices to the field (if applicable).
			Options *[]string `json:"options,omitempty"`

			// SortOrder The order which the field will be displayed in the UI
			SortOrder int                           `json:"sortOrder"`
			Type      PostCustomfieldsEntity200Type `json:"type"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                        `json:"error"`
				FieldPath  *string                                       `json:"fieldPath"`
				FieldValue *PostCustomfieldsEntity_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                        `json:"error"`
				FieldPath  *string                                       `json:"fieldPath"`
				FieldValue *PostCustomfieldsEntity_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteCustomfieldsEntityIdResponse parses an HTTP response from a DeleteCustomfieldsEntityIdWithResponse call
func ParseDeleteCustomfieldsEntityIdResponse(rsp *http.Response) (*DeleteCustomfieldsEntityIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomfieldsEntityIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                            `json:"error"`
				FieldPath  *string                                           `json:"fieldPath"`
				FieldValue *DeleteCustomfieldsEntityId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchCustomfieldsEntityIdResponse parses an HTTP response from a PatchCustomfieldsEntityIdWithResponse call
func ParsePatchCustomfieldsEntityIdResponse(rsp *http.Response) (*PatchCustomfieldsEntityIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchCustomfieldsEntityIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                           `json:"error"`
				FieldPath  *string                                          `json:"fieldPath"`
				FieldValue *PatchCustomfieldsEntityId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                           `json:"error"`
				FieldPath  *string                                          `json:"fieldPath"`
				FieldValue *PatchCustomfieldsEntityId_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLocationsResponse parses an HTTP response from a GetLocationsWithResponse call
func ParseGetLocationsResponse(rsp *http.Response) (*GetLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Locations []struct {
				// Address Postal address of the location
				Address *string `json:"address"`

				// Barcode String encoded barcode (expand with query parameter)
				Barcode *string `json:"barcode,omitempty"`

				// CreatedAt Date & time at which the location was created
				CreatedAt   *time.Time `json:"createdAt,omitempty"`
				Description *string    `json:"description"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Department") (expand with query parameter)
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the location
				Id   int    `json:"id"`
				Name string `json:"name"`

				// ParentId ID of the parent location
				ParentId *int `json:"parentId"`

				// TeamIds Team IDs (expand with query parameter)
				TeamIds *[]float32 `json:"teamIds,omitempty"`

				// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`

				// VendorIds Vendor IDs (expand with query parameter)
				VendorIds *[]float32 `json:"vendorIds,omitempty"`
			} `json:"locations"`

			// NextCursor The cursor to retrieve the next page of Locations.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Locations.
			NextPageUrl *string `json:"nextPageUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostLocationsResponse parses an HTTP response from a PostLocationsWithResponse call
func ParsePostLocationsResponse(rsp *http.Response) (*PostLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id Global ID of the location
			Id int `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                               `json:"error"`
				FieldPath  *string                              `json:"fieldPath"`
				FieldValue *PostLocations_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteLocationsIdResponse parses an HTTP response from a DeleteLocationsIdWithResponse call
func ParseDeleteLocationsIdResponse(rsp *http.Response) (*DeleteLocationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLocationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                   `json:"error"`
				FieldPath  *string                                  `json:"fieldPath"`
				FieldValue *DeleteLocationsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLocationsIdResponse parses an HTTP response from a GetLocationsIdWithResponse call
func ParseGetLocationsIdResponse(rsp *http.Response) (*GetLocationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Location struct {
				// Address Postal address of the location
				Address *string `json:"address"`

				// Attachments List of attachments linked to the location
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// Barcode String encoded barcode
				Barcode *string `json:"barcode"`

				// ChildrenIds IDs of the location's children
				ChildrenIds *[]float32 `json:"childrenIds"`

				// CreatedAt Date & time at which the location was created
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// DeletedAt Date at which the location was deleted
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Department")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the location
				Id   int    `json:"id"`
				Name string `json:"name"`

				// ParentId ID of the parent location
				ParentId *int `json:"parentId"`

				// TeamIds Team IDs
				TeamIds   *[]float32 `json:"teamIds,omitempty"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`

				// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`

				// VendorIds Vendor IDs
				VendorIds *[]float32 `json:"vendorIds,omitempty"`
			} `json:"location"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchLocationsIdResponse parses an HTTP response from a PatchLocationsIdWithResponse call
func ParsePatchLocationsIdResponse(rsp *http.Response) (*PatchLocationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLocationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Location struct {
				// Address Postal address of the location
				Address *string `json:"address"`

				// Attachments List of attachments linked to the location
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// Barcode String encoded barcode
				Barcode *string `json:"barcode"`

				// ChildrenIds IDs of the location's children
				ChildrenIds *[]float32 `json:"childrenIds"`

				// CreatedAt Date & time at which the location was created
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// DeletedAt Date at which the location was deleted
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Department")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the location
				Id   int    `json:"id"`
				Name string `json:"name"`

				// ParentId ID of the parent location
				ParentId *int `json:"parentId"`

				// TeamIds Team IDs
				TeamIds   *[]float32 `json:"teamIds,omitempty"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`

				// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`

				// VendorIds Vendor IDs
				VendorIds *[]float32 `json:"vendorIds,omitempty"`
			} `json:"location"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                  `json:"error"`
				FieldPath  *string                                 `json:"fieldPath"`
				FieldValue *PatchLocationsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteLocationsIdAttachmentsFilenameResponse parses an HTTP response from a DeleteLocationsIdAttachmentsFilenameWithResponse call
func ParseDeleteLocationsIdAttachmentsFilenameResponse(rsp *http.Response) (*DeleteLocationsIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLocationsIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutLocationsIdAttachmentsFilenameResponse parses an HTTP response from a PutLocationsIdAttachmentsFilenameWithResponse call
func ParsePutLocationsIdAttachmentsFilenameResponse(rsp *http.Response) (*PutLocationsIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutLocationsIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParsePutLocationsIdThumbnailFilenameResponse parses an HTTP response from a PutLocationsIdThumbnailFilenameWithResponse call
func ParsePutLocationsIdThumbnailFilenameResponse(rsp *http.Response) (*PutLocationsIdThumbnailFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutLocationsIdThumbnailFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                                 `json:"error"`
				FieldPath  *string                                                `json:"fieldPath"`
				FieldValue *PutLocationsIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParsePostMeterreadingsResponse parses an HTTP response from a PostMeterreadingsWithResponse call
func ParsePostMeterreadingsResponse(rsp *http.Response) (*PostMeterreadingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMeterreadingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []struct {
			// CreatedAt Meter Reading creation/processing date.
			CreatedAt string `json:"createdAt"`

			// MeterId Global ID of the meter.
			MeterId float32 `json:"meterId"`

			// ReadingDate Date at which the meter was read. This date can be set in the past, but cannot be further than 3 days for IoT meters.
			ReadingDate *string `json:"readingDate"`

			// Value The reading value given by the meter.
			Value float32 `json:"value"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                   `json:"error"`
				FieldPath  *string                                  `json:"fieldPath"`
				FieldValue *PostMeterreadings_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                   `json:"error"`
				FieldPath  *string                                  `json:"fieldPath"`
				FieldValue *PostMeterreadings_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetMetersResponse parses an HTTP response from a GetMetersWithResponse call
func ParseGetMetersResponse(rsp *http.Response) (*GetMetersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meters []struct {
				// Asset Asset linked to the element (expand with query parameter)
				Asset *struct {
					// CreatedAt Date & time at which the asset was created
					CreatedAt time.Time `json:"createdAt"`

					// CreatorId ID of the asset creator
					CreatorId *int `json:"creatorId"`

					// CriticalityId ID of the criticality of the asset
					CriticalityId *int    `json:"criticalityId"`
					Description   *string `json:"description"`

					// Id Global ID of the asset
					Id int `json:"id"`

					// LocationId ID of the location where the asset is located
					LocationId *int   `json:"locationId"`
					Name       string `json:"name"`

					// ParentId ID of the parent asset
					ParentId *int `json:"parentId"`

					// SerialNumber Serial number of the asset
					SerialNumber *string `json:"serialNumber"`

					// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"asset"`

				// Id Global ID of the meter.
				Id float32 `json:"id"`

				// LastReading Last reading of a meter (expand with query parameter)
				LastReading *struct {
					// CreatedAt Meter Reading creation/processing date.
					CreatedAt string `json:"createdAt"`

					// Id Global ID of the reading.
					// IoT meters will produce IDs with the format '{meterId}-{uuid}', while manual meters will produce numbered IDs.
					Id string `json:"id"`

					// MeterId Global ID of the meter.
					MeterId float32 `json:"meterId"`

					// ReadingDate Date at which the meter was read. This date can be set in the past, but cannot be further than 3 days for IoT meters.
					ReadingDate *string `json:"readingDate"`

					// Value The reading value given by the meter.
					Value float32 `json:"value"`
				} `json:"lastReading"`

				// Location Location linked to the element (expand with query parameter)
				Location *struct {
					// Address Postal address of the location
					Address *string `json:"address"`

					// CreatedAt Date & time at which the location was created
					CreatedAt   *time.Time `json:"createdAt,omitempty"`
					Description *string    `json:"description"`

					// Id Global ID of the location
					Id   int    `json:"id"`
					Name string `json:"name"`

					// ParentId ID of the parent location
					ParentId *int `json:"parentId"`

					// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
					UpdatedAt *time.Time `json:"updatedAt,omitempty"`
				} `json:"location"`

				// MeasurementType Represents the Type of meter. <br><br><code>Manual</code>: They are made to be used in the MaintainX app and to retain manually entered values and are limited to 10 distinct readings creation requests per 24 hours over REST API. Batched readings requests only count as one toward the rate limit. <br><br><code>Automated</code>: (Enterprise Plan) Automated meters store high frequency readings sent from integrations and have normal rate limiting. <br><br>~~<code>IoT Device</code>~~: IoT Device meters are deprecated and should no longer be used in the future. Creating an IoT Device meter will mimic automated meters in terms of behavior to avoid breaking changes.
				MeasurementType GetMeters200MetersMeasurementType `json:"measurementType"`

				// Name Name of the meters
				Name string `json:"name"`

				// Unit Measurement unit for the readings. Any string is accepted. However, if applicable, we recommed you to use the following units as it may carry extra functionality: <br><ul>
				//             <li>Distance:
				//               <ul>
				//                 <li><code>Miles</code></li><li><code>Feet</code></li><li><code>Inches</code></li><li><code>Kilometers</code></li><li><code>Meters</code></li><li><code>Centimeters</code></li><li><code>Millimeters</code></li>
				//               </ul>
				//             </li>
				//             <li>Volume:
				//               <ul>
				//                 <li><code>Gallons</code></li><li><code>Liters</code></li><li><code>Milliliters</code></li><li><code>Cubic Meters</code></li>
				//               </ul>
				//             </li>
				//             <li>Temperature:
				//               <ul>
				//                 <li><code>Celsius</code></li><li><code>Fahrenheit</code></li><li><code>Kelvin</code></li>
				//               </ul>
				//             </li>
				//             <li>Other:
				//               <ul>
				//                 <li><code>Hours</code></li><li><code>Cycles</code></li><li><code>PSI</code></li><li><code>Kilograms</code></li><li><code>Grams</code></li><li><code>dBm</code></li><li><code>Nm</code></li>
				//               </ul>
				//             </li>
				//             <li>Velocity:
				//               <ul>
				//                 <li><code>MetersPerSecond</code></li><li><code>InchesPerSecond</code></li><li><code>MillimetersPerSecond</code></li>
				//               </ul>
				//             </li>
				//             <li>Acceleration:
				//               <ul>
				//                 <li><code>G-Force</code></li><li><code>MetersPerSecondSquared</code></li><li><code>FeetPerSecondSquared</code></li>
				//               </ul>
				//             </li>
				//             <li>Electrical:
				//               <ul>
				//                 <li><code>Volts</code></li><li><code>Amps</code></li>
				//               </ul>
				//             </li>
				//       </ul>
				//
				Unit string `json:"unit"`
			} `json:"meters"`

			// NextCursor The cursor to retrieve the next page of Meters.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Meters.
			NextPageUrl *string `json:"nextPageUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostMetersResponse parses an HTTP response from a PostMetersWithResponse call
func ParsePostMetersResponse(rsp *http.Response) (*PostMetersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMetersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the meter.
			Id float32 `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                            `json:"error"`
				FieldPath  *string                           `json:"fieldPath"`
				FieldValue *PostMeters_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseDeleteMetersIdResponse parses an HTTP response from a DeleteMetersIdWithResponse call
func ParseDeleteMetersIdResponse(rsp *http.Response) (*DeleteMetersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMetersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                `json:"error"`
				FieldPath  *string                               `json:"fieldPath"`
				FieldValue *DeleteMetersId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMetersIdResponse parses an HTTP response from a GetMetersIdWithResponse call
func ParseGetMetersIdResponse(rsp *http.Response) (*GetMetersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meter struct {
				// Asset Asset linked to the element (expand with query parameter)
				Asset *struct {
					// CreatedAt Date & time at which the asset was created
					CreatedAt time.Time `json:"createdAt"`

					// CreatorId ID of the asset creator
					CreatorId *int `json:"creatorId"`

					// CriticalityId ID of the criticality of the asset
					CriticalityId *int    `json:"criticalityId"`
					Description   *string `json:"description"`

					// Id Global ID of the asset
					Id int `json:"id"`

					// LocationId ID of the location where the asset is located
					LocationId *int   `json:"locationId"`
					Name       string `json:"name"`

					// ParentId ID of the parent asset
					ParentId *int `json:"parentId"`

					// SerialNumber Serial number of the asset
					SerialNumber *string `json:"serialNumber"`

					// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"asset"`

				// AssetId Global ID of the asset tied to the meter
				AssetId *int `json:"assetId"`

				// CreatedAt Meter creation date.
				CreatedAt string `json:"createdAt"`

				// CreatorId Global ID of the user who created the meter
				CreatorId int `json:"creatorId"`

				// Description Description of the meter
				Description *string `json:"description"`

				// Id Global ID of the meter.
				Id float32 `json:"id"`

				// LastReading Last reading of a meter (expand with query parameter)
				LastReading *struct {
					// CreatedAt Meter Reading creation/processing date.
					CreatedAt string `json:"createdAt"`

					// Id Global ID of the reading.
					// IoT meters will produce IDs with the format '{meterId}-{uuid}', while manual meters will produce numbered IDs.
					Id string `json:"id"`

					// MeterId Global ID of the meter.
					MeterId float32 `json:"meterId"`

					// ReadingDate Date at which the meter was read. This date can be set in the past, but cannot be further than 3 days for IoT meters.
					ReadingDate *string `json:"readingDate"`

					// Value The reading value given by the meter.
					Value float32 `json:"value"`
				} `json:"lastReading"`

				// Location Location linked to the element (expand with query parameter)
				Location *struct {
					// Address Postal address of the location
					Address *string `json:"address"`

					// CreatedAt Date & time at which the location was created
					CreatedAt   *time.Time `json:"createdAt,omitempty"`
					Description *string    `json:"description"`

					// Id Global ID of the location
					Id   int    `json:"id"`
					Name string `json:"name"`

					// ParentId ID of the parent location
					ParentId *int `json:"parentId"`

					// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
					UpdatedAt *time.Time `json:"updatedAt,omitempty"`
				} `json:"location"`

				// LocationId Global ID of the location tied to the meter
				LocationId *int `json:"locationId"`

				// MeasurementType Represents the Type of meter. <br><br><code>Manual</code>: They are made to be used in the MaintainX app and to retain manually entered values and are limited to 10 distinct readings creation requests per 24 hours over REST API. Batched readings requests only count as one toward the rate limit. <br><br><code>Automated</code>: (Enterprise Plan) Automated meters store high frequency readings sent from integrations and have normal rate limiting. <br><br>~~<code>IoT Device</code>~~: IoT Device meters are deprecated and should no longer be used in the future. Creating an IoT Device meter will mimic automated meters in terms of behavior to avoid breaking changes.
				MeasurementType GetMetersId200MeterMeasurementType `json:"measurementType"`

				// Name Name of the meters
				Name string `json:"name"`

				// ReadingFrequency Expected reading frequency of the meter. Mostly useful for manual meters.
				ReadingFrequency *GetMetersId_200_Meter_ReadingFrequency `json:"readingFrequency"`

				// Unit Measurement unit for the readings. Any string is accepted. However, if applicable, we recommed you to use the following units as it may carry extra functionality: <br><ul>
				//             <li>Distance:
				//               <ul>
				//                 <li><code>Miles</code></li><li><code>Feet</code></li><li><code>Inches</code></li><li><code>Kilometers</code></li><li><code>Meters</code></li><li><code>Centimeters</code></li><li><code>Millimeters</code></li>
				//               </ul>
				//             </li>
				//             <li>Volume:
				//               <ul>
				//                 <li><code>Gallons</code></li><li><code>Liters</code></li><li><code>Milliliters</code></li><li><code>Cubic Meters</code></li>
				//               </ul>
				//             </li>
				//             <li>Temperature:
				//               <ul>
				//                 <li><code>Celsius</code></li><li><code>Fahrenheit</code></li><li><code>Kelvin</code></li>
				//               </ul>
				//             </li>
				//             <li>Other:
				//               <ul>
				//                 <li><code>Hours</code></li><li><code>Cycles</code></li><li><code>PSI</code></li><li><code>Kilograms</code></li><li><code>Grams</code></li><li><code>dBm</code></li><li><code>Nm</code></li>
				//               </ul>
				//             </li>
				//             <li>Velocity:
				//               <ul>
				//                 <li><code>MetersPerSecond</code></li><li><code>InchesPerSecond</code></li><li><code>MillimetersPerSecond</code></li>
				//               </ul>
				//             </li>
				//             <li>Acceleration:
				//               <ul>
				//                 <li><code>G-Force</code></li><li><code>MetersPerSecondSquared</code></li><li><code>FeetPerSecondSquared</code></li>
				//               </ul>
				//             </li>
				//             <li>Electrical:
				//               <ul>
				//                 <li><code>Volts</code></li><li><code>Amps</code></li>
				//               </ul>
				//             </li>
				//       </ul>
				//
				Unit string `json:"unit"`

				// UpdatedAt Date that Meter was last modified.
				UpdatedAt string `json:"updatedAt"`

				// UpdaterId Global ID of the last user who updated the meter
				UpdaterId *int `json:"updaterId"`

				// Uuid Universally unique identifier of the meter in the UUID format
				Uuid string `json:"uuid"`
			} `json:"meter"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchMetersIdResponse parses an HTTP response from a PatchMetersIdWithResponse call
func ParsePatchMetersIdResponse(rsp *http.Response) (*PatchMetersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchMetersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meter struct {
				// AssetId Global ID of the asset tied to the meter
				AssetId *int `json:"assetId"`

				// CreatedAt Meter creation date.
				CreatedAt *string `json:"createdAt,omitempty"`

				// CreatorId Global ID of the user who created the meter
				CreatorId *int `json:"creatorId,omitempty"`

				// Description Description of the meter
				Description *string `json:"description"`

				// Id Global ID of the meter.
				Id float32 `json:"id"`

				// LocationId Global ID of the location tied to the meter
				LocationId *int `json:"locationId"`

				// MeasurementType Represents the Type of meter. <br><br><code>Manual</code>: They are made to be used in the MaintainX app and to retain manually entered values and are limited to 10 distinct readings creation requests per 24 hours over REST API. Batched readings requests only count as one toward the rate limit. <br><br><code>Automated</code>: (Enterprise Plan) Automated meters store high frequency readings sent from integrations and have normal rate limiting. <br><br>~~<code>IoT Device</code>~~: IoT Device meters are deprecated and should no longer be used in the future. Creating an IoT Device meter will mimic automated meters in terms of behavior to avoid breaking changes.
				MeasurementType *PatchMetersId200MeterMeasurementType `json:"measurementType,omitempty"`

				// Name Name of the meters
				Name string `json:"name"`

				// ReadingFrequency Expected reading frequency of the meter. Mostly useful for manual meters.
				ReadingFrequency *PatchMetersId_200_Meter_ReadingFrequency `json:"readingFrequency"`

				// Unit Measurement unit for the readings. Any string is accepted. However, if applicable, we recommed you to use the following units as it may carry extra functionality: <br><ul>
				//             <li>Distance:
				//               <ul>
				//                 <li><code>Miles</code></li><li><code>Feet</code></li><li><code>Inches</code></li><li><code>Kilometers</code></li><li><code>Meters</code></li><li><code>Centimeters</code></li><li><code>Millimeters</code></li>
				//               </ul>
				//             </li>
				//             <li>Volume:
				//               <ul>
				//                 <li><code>Gallons</code></li><li><code>Liters</code></li><li><code>Milliliters</code></li><li><code>Cubic Meters</code></li>
				//               </ul>
				//             </li>
				//             <li>Temperature:
				//               <ul>
				//                 <li><code>Celsius</code></li><li><code>Fahrenheit</code></li><li><code>Kelvin</code></li>
				//               </ul>
				//             </li>
				//             <li>Other:
				//               <ul>
				//                 <li><code>Hours</code></li><li><code>Cycles</code></li><li><code>PSI</code></li><li><code>Kilograms</code></li><li><code>Grams</code></li><li><code>dBm</code></li><li><code>Nm</code></li>
				//               </ul>
				//             </li>
				//             <li>Velocity:
				//               <ul>
				//                 <li><code>MetersPerSecond</code></li><li><code>InchesPerSecond</code></li><li><code>MillimetersPerSecond</code></li>
				//               </ul>
				//             </li>
				//             <li>Acceleration:
				//               <ul>
				//                 <li><code>G-Force</code></li><li><code>MetersPerSecondSquared</code></li><li><code>FeetPerSecondSquared</code></li>
				//               </ul>
				//             </li>
				//             <li>Electrical:
				//               <ul>
				//                 <li><code>Volts</code></li><li><code>Amps</code></li>
				//               </ul>
				//             </li>
				//       </ul>
				//
				Unit *string `json:"unit,omitempty"`

				// UpdatedAt Date that Meter was last modified.
				UpdatedAt *string `json:"updatedAt,omitempty"`

				// UpdaterId Global ID of the last user who updated the meter
				UpdaterId *int `json:"updaterId"`

				// Uuid Universally unique identifier of the meter in the UUID format
				Uuid *string `json:"uuid,omitempty"`
			} `json:"meter"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostMetersMeterIdReadingsResponse parses an HTTP response from a PostMetersMeterIdReadingsWithResponse call
func ParsePostMetersMeterIdReadingsResponse(rsp *http.Response) (*PostMetersMeterIdReadingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMetersMeterIdReadingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CreatedAt Reading creation or processing date.
			CreatedAt *string `json:"createdAt,omitempty"`

			// Id Global ID of the reading.
			// IoT meters will produce IDs with the format '{meterId}-{uuid}', while manual meters will produce numbered IDs.
			Id string `json:"id"`

			// ReadingDate Reading date when the meter was read. This date can be set in the past, but cannot go further than 3 days for IoT meters.
			ReadingDate *string `json:"readingDate"`

			// ReadingValue The reading value given by the meter.
			ReadingValue float32 `json:"readingValue"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                           `json:"error"`
				FieldPath  *string                                          `json:"fieldPath"`
				FieldValue *PostMetersMeterIdReadings_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetMetertriggersResponse parses an HTTP response from a GetMetertriggersWithResponse call
func ParseGetMetertriggersResponse(rsp *http.Response) (*GetMetertriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetertriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			MeterTriggers []struct {
				// Id Global ID of the trigger.
				Id float32 `json:"id"`

				// MeterId Global ID of the meter.
				MeterId float32 `json:"meterId"`
				Name    string  `json:"name"`
			} `json:"meterTriggers"`

			// NextCursor The cursor to retrieve the next page of Meter Triggers.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Meter Triggers.
			NextPageUrl *string `json:"nextPageUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostMetertriggersResponse parses an HTTP response from a PostMetertriggersWithResponse call
func ParsePostMetertriggersResponse(rsp *http.Response) (*PostMetertriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMetertriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Id of the meter trigger
			Id float32 `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                   `json:"error"`
				FieldPath  *string                                  `json:"fieldPath"`
				FieldValue *PostMetertriggers_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteMetertriggersIdResponse parses an HTTP response from a DeleteMetertriggersIdWithResponse call
func ParseDeleteMetertriggersIdResponse(rsp *http.Response) (*DeleteMetertriggersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMetertriggersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                       `json:"error"`
				FieldPath  *string                                      `json:"fieldPath"`
				FieldValue *DeleteMetertriggersId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMetertriggersIdResponse parses an HTTP response from a GetMetertriggersIdWithResponse call
func ParseGetMetertriggersIdResponse(rsp *http.Response) (*GetMetertriggersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetertriggersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			MeterTrigger struct {
				// Amount Value used to trigger the condition
				Amount float32 `json:"amount"`

				// Condition Condition of the trigger
				Condition GetMetertriggersId200MeterTriggerCondition `json:"condition"`

				// CreatedAt Date at which the meter was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId Global ID of the meter trigger's creator
				CreatorId  int `json:"creatorId"`
				DataPoints *struct {
					// Denominator The window of points where the condition gets checked
					Denominator *int `json:"denominator,omitempty"`

					// Numerator The number of data points out of "denominator" data points to trigger. E.g: 3 points out of 5 must be in a triggering state
					Numerator *int `json:"numerator,omitempty"`
				} `json:"dataPoints"`

				// DeletedAt Data at which the meter was delated
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// Id Global ID of the meter trigger
				Id int `json:"id"`

				// MeterId Global ID of the meter
				MeterId int `json:"meterId"`

				// MinDateForProcessing Date that the trigger will start to be active
				MinDateForProcessing *time.Time `json:"minDateForProcessing"`

				// Name Name of the trigger
				Name string `json:"name"`

				// NextTriggerValue Can be set to override the first trigger value
				NextTriggerValue *float32 `json:"nextTriggerValue"`

				// OrganizationId Global ID of the organization
				OrganizationId int `json:"organizationId"`

				// Period Window in seconds where the data points can be checked
				Period *int `json:"period"`

				// State State of the trigger
				State GetMetertriggersId200MeterTriggerState `json:"state"`

				// UpdatedAt Date at which the meter was updated
				UpdatedAt time.Time `json:"updatedAt"`

				// WorkOrderTemplate Work Order template used by the meter trigger (expand with query parameter)
				WorkOrderTemplate *struct {
					// CreatedAt Date & time at which the work order template was created
					CreatedAt *time.Time `json:"createdAt,omitempty"`

					// CreatorId ID of the user who created the work order
					CreatorId *int `json:"creatorId"`
					Data      *struct {
						// AssetId Global ID of the asset assigned to the work order
						AssetId *int `json:"assetId"`

						// AssigneeIds Users IDs assigned to the template
						AssigneeIds *[]float32 `json:"assigneeIds,omitempty"`

						// AttachmentIds IDs of the attachments on the template
						AttachmentIds *[]float32 `json:"attachmentIds"`
						Description   *string    `json:"description"`
						DueDate       *struct {
							Offset *float32                                                           `json:"offset,omitempty"`
							Type   *GetMetertriggersId200MeterTriggerWorkOrderTemplateDataDueDateType `json:"type,omitempty"`
						} `json:"dueDate"`

						// LocationId Global ID of the location assigned to the work order
						LocationId *int `json:"locationId"`
						PartsUsed  *[]struct {
							Area *string `json:"area"`

							// AvailableQuantity Quantity currently in stock
							AvailableQuantity *int `json:"availableQuantity,omitempty"`

							// Barcode String encoded barcode
							Barcode *string `json:"barcode"`

							// CopyOnRecurring Indicates if the parts will be copied to the next work order in the chain (if applicable).
							CopyOnRecurring *GetMetertriggersId200MeterTriggerWorkOrderTemplateDataPartsUsedCopyOnRecurring `json:"copyOnRecurring,omitempty"`
							Description     *string                                                                         `json:"description"`
							ExtraFields     *map[string]string                                                              `json:"extraFields,omitempty"`

							// Id Global ID of the part
							Id *int `json:"id,omitempty"`

							// LocationId Global ID of the location of the part
							LocationId *float32 `json:"locationId"`

							// MinimumQuantity Minimum quantity before you should restock
							MinimumQuantity *int    `json:"minimumQuantity,omitempty"`
							Name            *string `json:"name,omitempty"`

							// QuantityUsed Quantity used in the work order.
							QuantityUsed *int `json:"quantityUsed,omitempty"`

							// UnitCost Cost in cents. For example, for $1.20, put 120.
							UnitCost *int `json:"unitCost"`
						} `json:"partsUsed"`
						Priority  *GetMetertriggersId200MeterTriggerWorkOrderTemplateDataPriority `json:"priority,omitempty"`
						Procedure *struct {
							Fields []struct {
								AttachmentId *float32 `json:"attachmentId"`

								// Attachments List of attachments linked to the procedure row
								Attachments *[]struct {
									// CreatedAt Date & time at which the attachment was uploaded
									CreatedAt time.Time `json:"createdAt"`

									// FileName Attachment's file name
									FileName string `json:"fileName"`

									// Height Height if the file is an image
									Height *float32 `json:"height"`

									// Id Global ID of the attachment
									Id float32 `json:"id"`

									// MimeType MIME type of the file
									MimeType string `json:"mimeType"`

									// Url Url of the file
									Url string `json:"url"`

									// Width Width if the file is an image
									Width *float32 `json:"width"`
								} `json:"attachments,omitempty"`
								Choices     *[]string `json:"choices"`
								Description *string   `json:"description"`
								Id          float32   `json:"id"`

								// IsDateAndTime Indicate if a DATE field also contains the time
								IsDateAndTime *bool                                                                     `json:"isDateAndTime"`
								Label         string                                                                    `json:"label"`
								MeterId       *float32                                                                  `json:"meterId"`
								Type          GetMetertriggersId200MeterTriggerWorkOrderTemplateDataProcedureFieldsType `json:"type"`
								Urls          *[]struct {
									// Label Label of the url
									Label *string `json:"label,omitempty"`

									// Link Link
									Link string `json:"link"`
								} `json:"urls,omitempty"`
							} `json:"fields"`
							Title string `json:"title"`
						} `json:"procedure"`

						// TagsIds Categories IDs
						TagsIds *[]float32 `json:"tagsIds,omitempty"`

						// TeamIds Teams IDs
						TeamIds *[]float32 `json:"teamIds,omitempty"`

						// ThumbnailId ID of the attachment used as thumbnail
						ThumbnailId *int `json:"thumbnailId"`

						// Title Use the `title` field outside of the data object instead
						// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
						Title *string `json:"title,omitempty"`

						// VendorIds Vendor IDs
						VendorIds *[]float32 `json:"vendorIds,omitempty"`
					} `json:"data,omitempty"`

					// DeletedAt Time at which the template was deleted
					DeletedAt *time.Time `json:"deletedAt"`

					// Id Global ID of the work order template
					Id *int `json:"id,omitempty"`

					// OrganizationId ID of the organization
					OrganizationId *int `json:"organizationId"`

					// ProcedureTemplateId ID of the procedure template used if in the library
					ProcedureTemplateId *int `json:"procedureTemplateId"`

					// Title Title of the work order that will be generated. Use the meter trigger's name instead
					// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
					Title *string `json:"title,omitempty"`

					// UpdatedAt Time at which the template was updated
					UpdatedAt *time.Time `json:"updatedAt"`
				} `json:"workOrderTemplate"`

				// WorkOrderTemplateId Global ID of the work order template used by the meter trigger
				WorkOrderTemplateId *int `json:"workOrderTemplateId"`
			} `json:"meterTrigger"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchMetertriggersIdResponse parses an HTTP response from a PatchMetertriggersIdWithResponse call
func ParsePatchMetertriggersIdResponse(rsp *http.Response) (*PatchMetertriggersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchMetertriggersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                      `json:"error"`
				FieldPath  *string                                     `json:"fieldPath"`
				FieldValue *PatchMetertriggersId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutMetertriggersIdThumbnailFilenameResponse parses an HTTP response from a PutMetertriggersIdThumbnailFilenameWithResponse call
func ParsePutMetertriggersIdThumbnailFilenameResponse(rsp *http.Response) (*PutMetertriggersIdThumbnailFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutMetertriggersIdThumbnailFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                                     `json:"error"`
				FieldPath  *string                                                    `json:"fieldPath"`
				FieldValue *PutMetertriggersIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParsePatchMetertriggersIdWorkordertemplatesResponse parses an HTTP response from a PatchMetertriggersIdWorkordertemplatesWithResponse call
func ParsePatchMetertriggersIdWorkordertemplatesResponse(rsp *http.Response) (*PatchMetertriggersIdWorkordertemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchMetertriggersIdWorkordertemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                                        `json:"error"`
				FieldPath  *string                                                       `json:"fieldPath"`
				FieldValue *PatchMetertriggersIdWorkordertemplates_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse parses an HTTP response from a DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameWithResponse call
func ParseDeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse(rsp *http.Response) (*DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse parses an HTTP response from a PutMetertriggersIdWorkordertemplatesAttachmentsFilenameWithResponse call
func ParsePutMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse(rsp *http.Response) (*PutMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutMetertriggersIdWorkordertemplatesAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseGetOrganizationsResponse parses an HTTP response from a GetOrganizationsWithResponse call
func ParseGetOrganizationsResponse(rsp *http.Response) (*GetOrganizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor The cursor to retrieve the next page of Organizations.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Organizations.
			NextPageUrl   *string `json:"nextPageUrl"`
			Organizations []struct {
				// Currency Currency of the organization
				Currency *string `json:"currency"`

				// DateFormatLocale Date format locale of the organization
				DateFormatLocale *string `json:"dateFormatLocale"`

				// Id Global ID of the organization
				Id int `json:"id"`

				// ImageUrl URL of the organization image
				ImageUrl *string `json:"imageUrl"`

				// Name Name of the organization
				Name string `json:"name"`

				// TimeZone Time zone of the organization. default: Etc/UTC
				TimeZone *string `json:"timeZone,omitempty"`
			} `json:"organizations"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPartsResponse parses an HTTP response from a GetPartsWithResponse call
func ParseGetPartsResponse(rsp *http.Response) (*GetPartsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPartsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor The cursor to retrieve the next page of Parts.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Parts.
			NextPageUrl *string `json:"nextPageUrl"`
			Parts       []struct {
				// Area Area of the part. Deprecated: for Parts with multiple locations, use the new field in `locations`
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				Area *string `json:"area"`

				// AvailableQuantity Total quantity currently in stock. If your plan includes multi-location parts, this is the quantity across all part locations.
				AvailableQuantity int `json:"availableQuantity"`

				// Barcode String encoded barcode
				Barcode *string `json:"barcode"`

				// CreatedAt Date & time at which the part was created
				CreatedAt   time.Time `json:"createdAt"`
				Description *string   `json:"description"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number") (expand with query parameter)
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the part
				Id int `json:"id"`

				// LocationId ID of the location where the part is located. Deprecated: for Parts with multiple locations, use the new field in `locations`
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				LocationId *int `json:"locationId"`

				// Locations Detailed list of locations where the part is stored, including properties such as available quantity, minimum quantity, reserved quantity, and area within each location.
				Locations []struct {
					Area *string `json:"area"`

					// AvailableQuantity Quantity currently in stock
					AvailableQuantity *int `json:"availableQuantity,omitempty"`

					// LocationId ID of the location where the part is located
					LocationId int `json:"locationId"`

					// MinimumQuantity Minimum quantity before you should restock
					MinimumQuantity *int `json:"minimumQuantity"`

					// ReservedQuantity Quantity currently reserved for work orders
					ReservedQuantity *int `json:"reservedQuantity"`
				} `json:"locations"`

				// MinimumQuantity Total minimum quantity before you should restock. If your plan includes multi-location parts, this is the quantity across all part locations.
				MinimumQuantity int    `json:"minimumQuantity"`
				Name            string `json:"name"`

				// OrderedQuantity Total quantity currently on order from purchase orders. If your plan includes multi-location parts, this is the quantity across all part locations.
				OrderedQuantity int `json:"orderedQuantity"`

				// PartTypes List of part types
				PartTypes []string `json:"partTypes"`

				// ReservedQuantity Total quantity currently reserved for work orders. If your plan includes multi-location parts, this is the quantity across all part locations.
				ReservedQuantity int `json:"reservedQuantity"`

				// UnitCost Cost in cents. For example, for $1.20, put 120.
				UnitCost *int `json:"unitCost"`

				// UpdatedAt Date & time at which the part was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`

				// Vendors List of vendors of the part (expand with query parameter)
				Vendors *[]struct {
					// PartNumber Part number given to the part by this vendor
					PartNumber *string `json:"partNumber,omitempty"`

					// VendorId Id of the vendor
					VendorId *int `json:"vendorId,omitempty"`
				} `json:"vendors,omitempty"`
			} `json:"parts"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostPartsResponse parses an HTTP response from a PostPartsWithResponse call
func ParsePostPartsResponse(rsp *http.Response) (*PostPartsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPartsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the part
			Id int `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                           `json:"error"`
				FieldPath  *string                          `json:"fieldPath"`
				FieldValue *PostParts_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeletePartsIdResponse parses an HTTP response from a DeletePartsIdWithResponse call
func ParseDeletePartsIdResponse(rsp *http.Response) (*DeletePartsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePartsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                               `json:"error"`
				FieldPath  *string                              `json:"fieldPath"`
				FieldValue *DeletePartsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPartsIdResponse parses an HTTP response from a GetPartsIdWithResponse call
func ParseGetPartsIdResponse(rsp *http.Response) (*GetPartsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPartsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Part struct {
				// Area Area of the part. Deprecated: for Parts with multiple locations, use the new field in `locations`
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				Area *string `json:"area"`

				// AssetIds List of asset IDs
				AssetIds *[]int `json:"assetIds,omitempty"`

				// Attachments List of attachments linked to the part
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// AvailableQuantity Total quantity currently in stock. If your plan includes multi-location parts, this is the quantity across all part locations.
				AvailableQuantity *int `json:"availableQuantity,omitempty"`

				// Barcode String encoded barcode
				Barcode *string `json:"barcode"`

				// CreatedAt Date & time at which the part was created
				CreatedAt time.Time `json:"createdAt"`

				// DeletedAt Date at which the part was deleted
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the part
				Id int `json:"id"`

				// LocationId ID of the location where the part is located. Deprecated: for Parts with multiple locations, use the new field in `locations`
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				LocationId *int `json:"locationId"`

				// Locations Detailed list of locations where the part is stored, including properties such as available quantity, minimum quantity, reserved quantity, and area within each location.
				Locations *[]struct {
					Area *string `json:"area"`

					// AvailableQuantity Quantity currently in stock
					AvailableQuantity *int `json:"availableQuantity,omitempty"`

					// LocationId ID of the location where the part is located
					LocationId int `json:"locationId"`

					// MinimumQuantity Minimum quantity before you should restock
					MinimumQuantity *int `json:"minimumQuantity"`

					// ReservedQuantity Quantity currently reserved for work orders
					ReservedQuantity *int `json:"reservedQuantity"`
				} `json:"locations,omitempty"`

				// MinimumQuantity Total minimum quantity before you should restock. If your plan includes multi-location parts, this is the quantity across all part locations.
				MinimumQuantity *int   `json:"minimumQuantity,omitempty"`
				Name            string `json:"name"`

				// OrderedQuantity Total quantity currently on order from purchase orders. If your plan includes multi-location parts, this is the quantity across all part locations.
				OrderedQuantity *int `json:"orderedQuantity,omitempty"`

				// PartTypes List of part types
				PartTypes *[]string `json:"partTypes,omitempty"`

				// ReservedQuantity Total quantity currently reserved for work orders. If your plan includes multi-location parts, this is the quantity across all part locations.
				ReservedQuantity *int `json:"reservedQuantity,omitempty"`

				// TeamIds List of team IDs in charge of the part
				TeamIds   *[]int `json:"teamIds,omitempty"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`

				// UnitCost Cost in cents. For example, for $1.20, put 120.
				UnitCost *int `json:"unitCost"`

				// UpdatedAt Date & time at which the part was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`

				// VendorIds List of vendor IDs
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				VendorIds *[]int `json:"vendorIds,omitempty"`

				// Vendors List of vendors of the part
				Vendors *[]struct {
					// PartNumber Part number given to the part by this vendor
					PartNumber *string `json:"partNumber,omitempty"`

					// VendorId Id of the vendor
					VendorId *int `json:"vendorId,omitempty"`
				} `json:"vendors,omitempty"`
			} `json:"part"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchPartsIdResponse parses an HTTP response from a PatchPartsIdWithResponse call
func ParsePatchPartsIdResponse(rsp *http.Response) (*PatchPartsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchPartsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Part struct {
				// Area Area of the part. Deprecated: for Parts with multiple locations, use the new field in `locations`
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				Area *string `json:"area"`

				// AssetIds List of asset IDs
				AssetIds *[]int `json:"assetIds,omitempty"`

				// Attachments List of attachments linked to the part
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// AvailableQuantity Total quantity currently in stock. If your plan includes multi-location parts, this is the quantity across all part locations.
				AvailableQuantity *int `json:"availableQuantity,omitempty"`

				// Barcode String encoded barcode
				Barcode *string `json:"barcode"`

				// CreatedAt Date & time at which the part was created
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// DeletedAt Date at which the part was deleted
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the part
				Id int `json:"id"`

				// LocationId ID of the location where the part is located. Deprecated: for Parts with multiple locations, use the new field in `locations`
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				LocationId *int `json:"locationId"`

				// Locations Detailed list of locations where the part is stored, including properties such as available quantity, minimum quantity, reserved quantity, and area within each location.
				Locations *[]struct {
					Area *string `json:"area"`

					// AvailableQuantity Quantity currently in stock
					AvailableQuantity *int `json:"availableQuantity,omitempty"`

					// LocationId ID of the location where the part is located
					LocationId int `json:"locationId"`

					// MinimumQuantity Minimum quantity before you should restock
					MinimumQuantity *int `json:"minimumQuantity"`

					// ReservedQuantity Quantity currently reserved for work orders
					ReservedQuantity *int `json:"reservedQuantity"`
				} `json:"locations,omitempty"`

				// MinimumQuantity Total minimum quantity before you should restock. If your plan includes multi-location parts, this is the quantity across all part locations.
				MinimumQuantity *int   `json:"minimumQuantity,omitempty"`
				Name            string `json:"name"`

				// OrderedQuantity Total quantity currently on order from purchase orders. If your plan includes multi-location parts, this is the quantity across all part locations.
				OrderedQuantity *int `json:"orderedQuantity,omitempty"`

				// PartTypes List of part types
				PartTypes *[]string `json:"partTypes,omitempty"`

				// ReservedQuantity Total quantity currently reserved for work orders. If your plan includes multi-location parts, this is the quantity across all part locations.
				ReservedQuantity *int `json:"reservedQuantity,omitempty"`

				// TeamIds List of team IDs in charge of the part
				TeamIds   *[]int `json:"teamIds,omitempty"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`

				// UnitCost Cost in cents. For example, for $1.20, put 120.
				UnitCost *int `json:"unitCost"`

				// UpdatedAt Date & time at which the part was last updated. This doesn't include comments
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`

				// VendorIds List of vendor IDs
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				VendorIds *[]int `json:"vendorIds,omitempty"`

				// Vendors List of vendors of the part
				Vendors *[]struct {
					// PartNumber Part number given to the part by this vendor
					PartNumber *string `json:"partNumber,omitempty"`

					// VendorId Id of the vendor
					VendorId *int `json:"vendorId,omitempty"`
				} `json:"vendors,omitempty"`
			} `json:"part"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                              `json:"error"`
				FieldPath  *string                             `json:"fieldPath"`
				FieldValue *PatchPartsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeletePartsIdAttachmentsFilenameResponse parses an HTTP response from a DeletePartsIdAttachmentsFilenameWithResponse call
func ParseDeletePartsIdAttachmentsFilenameResponse(rsp *http.Response) (*DeletePartsIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePartsIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutPartsIdAttachmentsFilenameResponse parses an HTTP response from a PutPartsIdAttachmentsFilenameWithResponse call
func ParsePutPartsIdAttachmentsFilenameResponse(rsp *http.Response) (*PutPartsIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutPartsIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParsePutPartsIdThumbnailFilenameResponse parses an HTTP response from a PutPartsIdThumbnailFilenameWithResponse call
func ParsePutPartsIdThumbnailFilenameResponse(rsp *http.Response) (*PutPartsIdThumbnailFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutPartsIdThumbnailFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                             `json:"error"`
				FieldPath  *string                                            `json:"fieldPath"`
				FieldValue *PutPartsIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseGetParttransferrequestsResponse parses an HTTP response from a GetParttransferrequestsWithResponse call
func ParseGetParttransferrequestsResponse(rsp *http.Response) (*GetParttransferrequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetParttransferrequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor The cursor to retrieve the next page of Part Transfer Requests.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Part Transfer Requests.
			NextPageUrl          *string `json:"nextPageUrl"`
			PartTransferRequests []struct {
				// DestinationLocations Locations into which the transferred parts were received. (Receiving stocks)
				DestinationLocations *[]struct {
					// LocationId ID of the location in the organization where the part is being received. (Receiving stocks)
					LocationId *int `json:"locationId,omitempty"`

					// Quantity Quantity of parts received.
					Quantity int `json:"quantity"`
				} `json:"destinationLocations,omitempty"`

				// DestinationOrganizationId ID of the organization performing the request. (Requesting/receiving stocks)
				DestinationOrganizationId int `json:"destinationOrganizationId"`

				// DestinationPartId ID of the part that belongs to the organization performing the request. (Receiving stocks)
				DestinationPartId int `json:"destinationPartId"`

				// Id Global ID of the part transfer request.
				Id int `json:"id"`

				// QuantityReceived Quantity of parts received.
				QuantityReceived *int `json:"quantityReceived"`

				// QuantityRequested Quantity of parts requested for transfer.
				QuantityRequested int `json:"quantityRequested"`

				// QuantityTransferred Quantity of parts transferred.
				QuantityTransferred *int `json:"quantityTransferred"`

				// RequestMessage Message to give context surrounding the part transfer request.
				RequestMessage *string `json:"requestMessage"`

				// RequesterId ID of the user performing the request. (Requesting/receiving stocks)
				RequesterId *int `json:"requesterId,omitempty"`

				// ResponseMessage Message to give context surrounding the transfer of the part transfer request.
				ResponseMessage *string `json:"responseMessage"`

				// SourceLocationId ID of the location in the organization from which parts were transferred. (Sending stocks)
				SourceLocationId *int `json:"sourceLocationId,omitempty"`

				// SourceOrganizationId ID of the organization receiving the request. (Sending stocks)
				SourceOrganizationId int `json:"sourceOrganizationId"`

				// SourcePartId ID of the part that belongs to the organization receiving the request. (Sending stocks)
				SourcePartId int `json:"sourcePartId"`

				// Status Status of the part transfer request.
				Status *GetParttransferrequests200PartTransferRequestsStatus `json:"status,omitempty"`

				// TransferrerId ID of the user performing the transfer. (Sending stocks)
				TransferrerId *int `json:"transferrerId"`
			} `json:"partTransferRequests"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostParttransferrequestsResponse parses an HTTP response from a PostParttransferrequestsWithResponse call
func ParsePostParttransferrequestsResponse(rsp *http.Response) (*PostParttransferrequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostParttransferrequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the part transfer request.
			Id int `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                          `json:"error"`
				FieldPath  *string                                         `json:"fieldPath"`
				FieldValue *PostParttransferrequests_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetParttransferrequestsIdResponse parses an HTTP response from a GetParttransferrequestsIdWithResponse call
func ParseGetParttransferrequestsIdResponse(rsp *http.Response) (*GetParttransferrequestsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetParttransferrequestsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			PartTransferRequest struct {
				// DestinationLocations Locations into which the transferred parts were received. (Receiving stocks)
				DestinationLocations *[]struct {
					// LocationId ID of the location in the organization where the part is being received. (Receiving stocks)
					LocationId *int `json:"locationId,omitempty"`

					// Quantity Quantity of parts received.
					Quantity int `json:"quantity"`
				} `json:"destinationLocations,omitempty"`

				// DestinationOrganizationId ID of the organization performing the request. (Requesting/receiving stocks)
				DestinationOrganizationId int `json:"destinationOrganizationId"`

				// DestinationPartId ID of the part that belongs to the organization performing the request. (Receiving stocks)
				DestinationPartId int `json:"destinationPartId"`

				// Id Global ID of the part transfer request.
				Id int `json:"id"`

				// QuantityReceived Quantity of parts received.
				QuantityReceived *int `json:"quantityReceived"`

				// QuantityRequested Quantity of parts requested for transfer.
				QuantityRequested int `json:"quantityRequested"`

				// QuantityTransferred Quantity of parts transferred.
				QuantityTransferred *int `json:"quantityTransferred"`

				// RequestMessage Message to give context surrounding the part transfer request.
				RequestMessage *string `json:"requestMessage"`

				// RequesterId ID of the user performing the request. (Requesting/receiving stocks)
				RequesterId *int `json:"requesterId,omitempty"`

				// ResponseMessage Message to give context surrounding the transfer of the part transfer request.
				ResponseMessage *string `json:"responseMessage"`

				// SourceLocationId ID of the location in the organization from which parts were transferred. (Sending stocks)
				SourceLocationId *int `json:"sourceLocationId,omitempty"`

				// SourceOrganizationId ID of the organization receiving the request. (Sending stocks)
				SourceOrganizationId int `json:"sourceOrganizationId"`

				// SourcePartId ID of the part that belongs to the organization receiving the request. (Sending stocks)
				SourcePartId int `json:"sourcePartId"`

				// Status Status of the part transfer request.
				Status *GetParttransferrequestsId200PartTransferRequestStatus `json:"status,omitempty"`

				// TransferrerId ID of the user performing the transfer. (Sending stocks)
				TransferrerId *int `json:"transferrerId"`
			} `json:"partTransferRequest"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchParttransferrequestsIdResponse parses an HTTP response from a PatchParttransferrequestsIdWithResponse call
func ParsePatchParttransferrequestsIdResponse(rsp *http.Response) (*PatchParttransferrequestsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchParttransferrequestsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			PartTransferRequest struct {
				// DestinationLocations Locations into which the transferred parts were received. (Receiving stocks)
				DestinationLocations *[]struct {
					// LocationId ID of the location in the organization where the part is being received. (Receiving stocks)
					LocationId *int `json:"locationId,omitempty"`

					// Quantity Quantity of parts received.
					Quantity int `json:"quantity"`
				} `json:"destinationLocations,omitempty"`

				// DestinationOrganizationId ID of the organization performing the request. (Requesting/receiving stocks)
				DestinationOrganizationId int `json:"destinationOrganizationId"`

				// DestinationPartId ID of the part that belongs to the organization performing the request. (Receiving stocks)
				DestinationPartId int `json:"destinationPartId"`

				// Id Global ID of the part transfer request.
				Id int `json:"id"`

				// QuantityReceived Quantity of parts received.
				QuantityReceived *int `json:"quantityReceived"`

				// QuantityRequested Quantity of parts requested for transfer.
				QuantityRequested int `json:"quantityRequested"`

				// QuantityTransferred Quantity of parts transferred.
				QuantityTransferred *int `json:"quantityTransferred"`

				// RequestMessage Message to give context surrounding the part transfer request.
				RequestMessage *string `json:"requestMessage"`

				// RequesterId ID of the user performing the request. (Requesting/receiving stocks)
				RequesterId *int `json:"requesterId,omitempty"`

				// ResponseMessage Message to give context surrounding the transfer of the part transfer request.
				ResponseMessage *string `json:"responseMessage"`

				// SourceLocationId ID of the location in the organization from which parts were transferred. (Sending stocks)
				SourceLocationId *int `json:"sourceLocationId,omitempty"`

				// SourceOrganizationId ID of the organization receiving the request. (Sending stocks)
				SourceOrganizationId int `json:"sourceOrganizationId"`

				// SourcePartId ID of the part that belongs to the organization receiving the request. (Sending stocks)
				SourcePartId int `json:"sourcePartId"`

				// Status Status of the part transfer request.
				Status *PatchParttransferrequestsId200PartTransferRequestStatus `json:"status,omitempty"`

				// TransferrerId ID of the user performing the transfer. (Sending stocks)
				TransferrerId *int `json:"transferrerId"`
			} `json:"partTransferRequest"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                             `json:"error"`
				FieldPath  *string                                            `json:"fieldPath"`
				FieldValue *PatchParttransferrequestsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteProceduretemplaterowsIdResponse parses an HTTP response from a DeleteProceduretemplaterowsIdWithResponse call
func ParseDeleteProceduretemplaterowsIdResponse(rsp *http.Response) (*DeleteProceduretemplaterowsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProceduretemplaterowsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                               `json:"error"`
				FieldPath  *string                                              `json:"fieldPath"`
				FieldValue *DeleteProceduretemplaterowsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchProceduretemplaterowsIdResponse parses an HTTP response from a PatchProceduretemplaterowsIdWithResponse call
func ParsePatchProceduretemplaterowsIdResponse(rsp *http.Response) (*PatchProceduretemplaterowsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchProceduretemplaterowsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Row struct {
				AttachmentId *float32 `json:"attachmentId"`

				// Attachments List of attachments linked to the procedure row
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`
				Choices     *[]string `json:"choices"`
				Description *string   `json:"description"`
				Id          float32   `json:"id"`

				// IsDateAndTime Indicate if a DATE field also contains the time
				IsDateAndTime *bool                                  `json:"isDateAndTime"`
				Label         string                                 `json:"label"`
				MeterId       *float32                               `json:"meterId"`
				Type          PatchProceduretemplaterowsId200RowType `json:"type"`
				Urls          *[]struct {
					// Label Label of the url
					Label *string `json:"label,omitempty"`

					// Link Link
					Link string `json:"link"`
				} `json:"urls,omitempty"`
			} `json:"row"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                              `json:"error"`
				FieldPath  *string                                             `json:"fieldPath"`
				FieldValue *PatchProceduretemplaterowsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteProceduretemplaterowsIdAttachmentsResponse parses an HTTP response from a DeleteProceduretemplaterowsIdAttachmentsWithResponse call
func ParseDeleteProceduretemplaterowsIdAttachmentsResponse(rsp *http.Response) (*DeleteProceduretemplaterowsIdAttachmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProceduretemplaterowsIdAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutProceduretemplaterowsIdAttachmentsFilenameResponse parses an HTTP response from a PutProceduretemplaterowsIdAttachmentsFilenameWithResponse call
func ParsePutProceduretemplaterowsIdAttachmentsFilenameResponse(rsp *http.Response) (*PutProceduretemplaterowsIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutProceduretemplaterowsIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseGetProceduretemplatesResponse parses an HTTP response from a GetProceduretemplatesWithResponse call
func ParseGetProceduretemplatesResponse(rsp *http.Response) (*GetProceduretemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProceduretemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor The cursor to retrieve the next page of Procedure Templates.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Procedure Templates.
			NextPageUrl        *string `json:"nextPageUrl"`
			ProcedureTemplates []struct {
				// Id Global ID of the procedure template
				Id float32 `json:"id"`

				// Rows (expand with query parameter)
				Rows *[]struct {
					AttachmentId *float32 `json:"attachmentId"`

					// Attachments List of attachments linked to the procedure row
					Attachments *[]struct {
						// CreatedAt Date & time at which the attachment was uploaded
						CreatedAt time.Time `json:"createdAt"`

						// FileName Attachment's file name
						FileName string `json:"fileName"`

						// Height Height if the file is an image
						Height *float32 `json:"height"`

						// Id Global ID of the attachment
						Id float32 `json:"id"`

						// MimeType MIME type of the file
						MimeType string `json:"mimeType"`

						// Url Url of the file
						Url string `json:"url"`

						// Width Width if the file is an image
						Width *float32 `json:"width"`
					} `json:"attachments,omitempty"`
					Choices     *[]string `json:"choices"`
					Description *string   `json:"description"`
					Id          float32   `json:"id"`

					// IsDateAndTime Indicate if a DATE field also contains the time
					IsDateAndTime *bool                                              `json:"isDateAndTime"`
					Label         string                                             `json:"label"`
					MeterId       *float32                                           `json:"meterId"`
					Type          GetProceduretemplates200ProcedureTemplatesRowsType `json:"type"`
					Urls          *[]struct {
						// Label Label of the url
						Label *string `json:"label,omitempty"`

						// Link Link
						Link string `json:"link"`
					} `json:"urls,omitempty"`
				} `json:"rows"`

				// Title Title of the procedure template
				Title string `json:"title"`
			} `json:"procedureTemplates"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostProceduretemplatesResponse parses an HTTP response from a PostProceduretemplatesWithResponse call
func ParsePostProceduretemplatesResponse(rsp *http.Response) (*PostProceduretemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProceduretemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Fields []struct {
				AttachmentId *float32 `json:"attachmentId"`

				// Attachments List of attachments linked to the procedure row
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`
				Choices     *[]string `json:"choices"`
				Description *string   `json:"description"`
				Id          float32   `json:"id"`

				// IsDateAndTime Indicate if a DATE field also contains the time
				IsDateAndTime *bool                               `json:"isDateAndTime"`
				Label         string                              `json:"label"`
				MeterId       *float32                            `json:"meterId"`
				Type          PostProceduretemplates201FieldsType `json:"type"`
				Urls          *[]struct {
					// Label Label of the url
					Label *string `json:"label,omitempty"`

					// Link Link
					Link string `json:"link"`
				} `json:"urls,omitempty"`
			} `json:"fields"`

			// Id Id of the procedure template
			Id float32 `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                        `json:"error"`
				FieldPath  *string                                       `json:"fieldPath"`
				FieldValue *PostProceduretemplates_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteProceduretemplatesIdResponse parses an HTTP response from a DeleteProceduretemplatesIdWithResponse call
func ParseDeleteProceduretemplatesIdResponse(rsp *http.Response) (*DeleteProceduretemplatesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProceduretemplatesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                            `json:"error"`
				FieldPath  *string                                           `json:"fieldPath"`
				FieldValue *DeleteProceduretemplatesId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetProceduretemplatesIdResponse parses an HTTP response from a GetProceduretemplatesIdWithResponse call
func ParseGetProceduretemplatesIdResponse(rsp *http.Response) (*GetProceduretemplatesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProceduretemplatesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ProcedureTemplate struct {
				// CreatedAt Date & time at which the procedure template was created
				CreatedAt time.Time `json:"createdAt"`

				// DeletedAt Date & time at which the procedure template was deleted
				DeletedAt *time.Time `json:"deletedAt"`

				// Id Global ID of the procedure template
				Id float32 `json:"id"`

				// Rows (expand with query parameter)
				Rows *[]struct {
					AttachmentId *float32 `json:"attachmentId"`

					// Attachments List of attachments linked to the procedure row
					Attachments *[]struct {
						// CreatedAt Date & time at which the attachment was uploaded
						CreatedAt time.Time `json:"createdAt"`

						// FileName Attachment's file name
						FileName string `json:"fileName"`

						// Height Height if the file is an image
						Height *float32 `json:"height"`

						// Id Global ID of the attachment
						Id float32 `json:"id"`

						// MimeType MIME type of the file
						MimeType string `json:"mimeType"`

						// Url Url of the file
						Url string `json:"url"`

						// Width Width if the file is an image
						Width *float32 `json:"width"`
					} `json:"attachments,omitempty"`
					Choices     *[]string `json:"choices"`
					Description *string   `json:"description"`
					Id          float32   `json:"id"`

					// IsDateAndTime Indicate if a DATE field also contains the time
					IsDateAndTime *bool                                               `json:"isDateAndTime"`
					Label         string                                              `json:"label"`
					MeterId       *float32                                            `json:"meterId"`
					Type          GetProceduretemplatesId200ProcedureTemplateRowsType `json:"type"`
					Urls          *[]struct {
						// Label Label of the url
						Label *string `json:"label,omitempty"`

						// Link Link
						Link string `json:"link"`
					} `json:"urls,omitempty"`
				} `json:"rows"`

				// Title Title of the procedure template
				Title string `json:"title"`

				// UpdatedAt Date & time at which the procedure template was last updated
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"procedureTemplate"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchProceduretemplatesIdResponse parses an HTTP response from a PatchProceduretemplatesIdWithResponse call
func ParsePatchProceduretemplatesIdResponse(rsp *http.Response) (*PatchProceduretemplatesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchProceduretemplatesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                           `json:"error"`
				FieldPath  *string                                          `json:"fieldPath"`
				FieldValue *PatchProceduretemplatesId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPurchaseordersResponse parses an HTTP response from a GetPurchaseordersWithResponse call
func ParseGetPurchaseordersResponse(rsp *http.Response) (*GetPurchaseordersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPurchaseordersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor The cursor to retrieve the next page of Purchase Orders.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Purchase Orders.
			NextPageUrl    *string `json:"nextPageUrl"`
			PurchaseOrders []struct {
				// Id Global ID of the Purchase Order
				Id float32 `json:"id"`

				// Status Status of the Purchase Order. Supported values are APPROVED, CANCELED, COMPLETED, DECLINED, PARTIALLY_FULFILLED, PENDING, REQUESTED
				Status *string `json:"status"`
			} `json:"purchaseOrders"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostPurchaseordersResponse parses an HTTP response from a PostPurchaseordersWithResponse call
func ParsePostPurchaseordersResponse(rsp *http.Response) (*PostPurchaseordersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPurchaseordersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// ApprovalDate Date the Purchase Order was approved
			ApprovalDate *string `json:"approvalDate"`

			// ApproverId ID of the user who approved the Purchase Order
			ApproverId *float32 `json:"approverId"`

			// Attachments List of attachments linked to the Purchase Order
			Attachments *[]struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"attachments,omitempty"`

			// AutoGeneratedNumber Autogenerated Purchase Order number
			AutoGeneratedNumber *float32 `json:"autoGeneratedNumber"`

			// BillingAddress Billing address in the Purchase Order
			BillingAddress *struct {
				City    string `json:"city"`
				Country string `json:"country"`

				// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
				Label      *string `json:"label"`
				PostalCode string  `json:"postalCode"`
				State      string  `json:"state"`
				Street     string  `json:"street"`
			} `json:"billingAddress"`

			// Costs List of costs in the Purchase Order
			Costs *[]struct {
				Amount float32 `json:"amount"`

				// Id ID of the cost
				Id *float32 `json:"id,omitempty"`

				// Name Description of the cost
				Name string `json:"name"`

				// Type Type of cost in either cents or percent. Accepted types in cents are AMOUNT_TAXABLE and AMOUNT_NON_TAXABLE. For percentage use PERCENT_TAXABLE
				Type PostPurchaseorders201CostsType `json:"type"`
			} `json:"costs,omitempty"`

			// CreatorId ID of the user that created this Purchase Order
			CreatorId *float32 `json:"creatorId,omitempty"`

			// DeletedAt Date at which the Purchase Order was deleted
			DeletedAt *time.Time `json:"deletedAt"`

			// DueDate Due date of Purchase Order
			DueDate *string `json:"dueDate"`

			// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
			ExtraFields *map[string]string `json:"extraFields,omitempty"`

			// Id Global ID of the Purchase Order
			Id float32 `json:"id"`

			// Items List of items in the Purchase Order
			Items []struct {
				// ExtraFields Custom Fields on the entity. Deprecated: Use `lineExtraFields` instead.
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Fulfillments Fulfillment information for the item's fulfillment locations.
				Fulfillments *[]struct {
					// Id ID of the item fulfillment
					Id *float32 `json:"id,omitempty"`

					// IsLegacy Indicates the location is a legacy location. This is used to determine if this fulfillment was done before enablement of the multi-location parts feature.
					IsLegacy *bool `json:"isLegacy,omitempty"`

					// LocationId ID of the location where the item was fulfilled
					LocationId *float32 `json:"locationId"`

					// QuantityReceived Quantity of the item fulfilled to this location
					QuantityReceived *string `json:"quantityReceived,omitempty"`
				} `json:"fulfillments,omitempty"`

				// Id ID of the item
				Id float32 `json:"id"`

				// LineExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
				LineExtraFields *map[string]string `json:"lineExtraFields,omitempty"`
				Name            *string            `json:"name"`

				// PartExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
				PartExtraFields *map[string]string `json:"partExtraFields,omitempty"`

				// PartId ID of the part this item is related to
				PartId     *float32 `json:"partId"`
				PartNumber *string  `json:"partNumber"`

				// Price Total price of items in cents
				Price *float32 `json:"price"`

				// QuantityOrdered Represent the amount of units for this item that were ordered in the purchase order.
				QuantityOrdered float32 `json:"quantityOrdered"`

				// QuantityReceived Represents the total amount of this specific item that has been received to date.
				QuantityReceived *float32 `json:"quantityReceived"`

				// UnitCost Price of a single item in cents
				UnitCost *float32 `json:"unitCost"`
			} `json:"items"`

			// Note Notes left for Purchase Orders
			Note *string `json:"note"`

			// OverrideNumber Custom number/identifier for Purchase Order
			OverrideNumber *string `json:"overrideNumber"`

			// ReviewNote Notes to be left for changes to be made when sending a Purchase Order for revision
			ReviewNote *string `json:"reviewNote"`

			// ShippingAddress Shipping address in the Purchase Order
			ShippingAddress *struct {
				City    string `json:"city"`
				Country string `json:"country"`

				// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
				Label      *string `json:"label"`
				PostalCode string  `json:"postalCode"`
				State      string  `json:"state"`
				Street     string  `json:"street"`
			} `json:"shippingAddress"`

			// Status Status of the Purchase Order. Supported values are APPROVED, CANCELED, COMPLETED, DECLINED, PARTIALLY_FULFILLED, PENDING, REQUESTED
			Status    *string `json:"status"`
			Thumbnail *struct {
				// CreatedAt Date & time at which the attachment was uploaded
				CreatedAt time.Time `json:"createdAt"`

				// FileName Attachment's file name
				FileName string `json:"fileName"`

				// Height Height if the file is an image
				Height *float32 `json:"height"`

				// Id Global ID of the attachment
				Id float32 `json:"id"`

				// MimeType MIME type of the file
				MimeType string `json:"mimeType"`

				// Url Url of the file
				Url string `json:"url"`

				// Width Width if the file is an image
				Width *float32 `json:"width"`
			} `json:"thumbnail"`

			// UpdatedAt Date the Purchase Order was last updated
			UpdatedAt *string `json:"updatedAt"`

			// VendorContactIds List of vendor contact IDs in the Purchase Order
			VendorContactIds *[]float32 `json:"vendorContactIds,omitempty"`

			// VendorId ID of vendor that this Purchase Order is associated with
			VendorId *float32 `json:"vendorId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                    `json:"error"`
				FieldPath  *string                                   `json:"fieldPath"`
				FieldValue *PostPurchaseorders_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                    `json:"error"`
				FieldPath  *string                                   `json:"fieldPath"`
				FieldValue *PostPurchaseorders_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeletePurchaseordersIdResponse parses an HTTP response from a DeletePurchaseordersIdWithResponse call
func ParseDeletePurchaseordersIdResponse(rsp *http.Response) (*DeletePurchaseordersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePurchaseordersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                        `json:"error"`
				FieldPath  *string                                       `json:"fieldPath"`
				FieldValue *DeletePurchaseordersId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPurchaseordersIdResponse parses an HTTP response from a GetPurchaseordersIdWithResponse call
func ParseGetPurchaseordersIdResponse(rsp *http.Response) (*GetPurchaseordersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPurchaseordersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			PurchaseOrder struct {
				// ApprovalDate Date the Purchase Order was approved
				ApprovalDate *string `json:"approvalDate"`

				// ApproverId ID of the user who approved the Purchase Order
				ApproverId *float32 `json:"approverId"`

				// Attachments List of attachments linked to the Purchase Order
				Attachments []struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments"`

				// AutoGeneratedNumber Autogenerated Purchase Order number
				AutoGeneratedNumber *float32 `json:"autoGeneratedNumber"`

				// BillingAddress Billing address in the Purchase Order
				BillingAddress *struct {
					City    string `json:"city"`
					Country string `json:"country"`

					// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
					Label      *string `json:"label"`
					PostalCode string  `json:"postalCode"`
					State      string  `json:"state"`
					Street     string  `json:"street"`
				} `json:"billingAddress"`

				// Costs List of costs in the Purchase Order
				Costs []struct {
					Amount float32 `json:"amount"`

					// Id ID of the cost
					Id *float32 `json:"id,omitempty"`

					// Name Description of the cost
					Name string `json:"name"`

					// Type Type of cost in either cents or percent. Accepted types in cents are AMOUNT_TAXABLE and AMOUNT_NON_TAXABLE. For percentage use PERCENT_TAXABLE
					Type GetPurchaseordersId200PurchaseOrderCostsType `json:"type"`
				} `json:"costs"`

				// CreatorId ID of the user that created this Purchase Order
				CreatorId float32 `json:"creatorId"`

				// DeletedAt Date at which the Purchase Order was deleted
				DeletedAt *time.Time `json:"deletedAt"`

				// DueDate Due date of Purchase Order
				DueDate *string `json:"dueDate"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
				ExtraFields map[string]string `json:"extraFields"`

				// Id Global ID of the Purchase Order
				Id float32 `json:"id"`

				// Items List of items in the Purchase Order
				Items []struct {
					// ExtraFields Custom Fields on the entity. Deprecated: Use `lineExtraFields` instead.
					// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
					ExtraFields *map[string]string `json:"extraFields,omitempty"`

					// Fulfillments Fulfillment information for the item's fulfillment locations.
					Fulfillments *[]struct {
						// Id ID of the item fulfillment
						Id *float32 `json:"id,omitempty"`

						// IsLegacy Indicates the location is a legacy location. This is used to determine if this fulfillment was done before enablement of the multi-location parts feature.
						IsLegacy *bool `json:"isLegacy,omitempty"`

						// LocationId ID of the location where the item was fulfilled
						LocationId *float32 `json:"locationId"`

						// QuantityReceived Quantity of the item fulfilled to this location
						QuantityReceived *string `json:"quantityReceived,omitempty"`
					} `json:"fulfillments,omitempty"`

					// Id ID of the item
					Id float32 `json:"id"`

					// LineExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
					LineExtraFields *map[string]string `json:"lineExtraFields,omitempty"`
					Name            *string            `json:"name"`

					// PartExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
					PartExtraFields *map[string]string `json:"partExtraFields,omitempty"`

					// PartId ID of the part this item is related to
					PartId     *float32 `json:"partId"`
					PartNumber *string  `json:"partNumber"`

					// Price Total price of items in cents
					Price *float32 `json:"price"`

					// QuantityOrdered Represent the amount of units for this item that were ordered in the purchase order.
					QuantityOrdered float32 `json:"quantityOrdered"`

					// QuantityReceived Represents the total amount of this specific item that has been received to date.
					QuantityReceived *float32 `json:"quantityReceived"`

					// UnitCost Price of a single item in cents
					UnitCost *float32 `json:"unitCost"`
				} `json:"items"`

				// Note Notes left for Purchase Orders
				Note *string `json:"note"`

				// OverrideNumber Custom number/identifier for Purchase Order
				OverrideNumber *string `json:"overrideNumber"`

				// ReviewNote Notes to be left for changes to be made when sending a Purchase Order for revision
				ReviewNote *string `json:"reviewNote"`

				// ShippingAddress Shipping address in the Purchase Order
				ShippingAddress *struct {
					City    string `json:"city"`
					Country string `json:"country"`

					// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
					Label      *string `json:"label"`
					PostalCode string  `json:"postalCode"`
					State      string  `json:"state"`
					Street     string  `json:"street"`
				} `json:"shippingAddress"`

				// Status Status of the Purchase Order. Supported values are APPROVED, CANCELED, COMPLETED, DECLINED, PARTIALLY_FULFILLED, PENDING, REQUESTED
				Status    *string `json:"status"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`

				// UpdatedAt Date the Purchase Order was last updated
				UpdatedAt *string `json:"updatedAt"`

				// VendorContactIds List of vendor contact IDs in the Purchase Order
				VendorContactIds []float32 `json:"vendorContactIds"`

				// VendorId ID of vendor that this Purchase Order is associated with
				VendorId *float32 `json:"vendorId"`
			} `json:"purchaseOrder"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchPurchaseordersIdResponse parses an HTTP response from a PatchPurchaseordersIdWithResponse call
func ParsePatchPurchaseordersIdResponse(rsp *http.Response) (*PatchPurchaseordersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchPurchaseordersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			PurchaseOrder struct {
				// ApprovalDate Date the Purchase Order was approved
				ApprovalDate *string `json:"approvalDate"`

				// ApproverId ID of the user who approved the Purchase Order
				ApproverId *float32 `json:"approverId"`

				// Attachments List of attachments linked to the Purchase Order
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// AutoGeneratedNumber Autogenerated Purchase Order number
				AutoGeneratedNumber *float32 `json:"autoGeneratedNumber"`

				// BillingAddress Billing address in the Purchase Order
				BillingAddress *struct {
					City    string `json:"city"`
					Country string `json:"country"`

					// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
					Label      *string `json:"label"`
					PostalCode string  `json:"postalCode"`
					State      string  `json:"state"`
					Street     string  `json:"street"`
				} `json:"billingAddress"`

				// Costs List of costs in the Purchase Order
				Costs *[]struct {
					Amount float32 `json:"amount"`

					// Id ID of the cost
					Id *float32 `json:"id,omitempty"`

					// Name Description of the cost
					Name string `json:"name"`

					// Type Type of cost in either cents or percent. Accepted types in cents are AMOUNT_TAXABLE and AMOUNT_NON_TAXABLE. For percentage use PERCENT_TAXABLE
					Type PatchPurchaseordersId200PurchaseOrderCostsType `json:"type"`
				} `json:"costs,omitempty"`

				// CreatorId ID of the user that created this Purchase Order
				CreatorId *float32 `json:"creatorId,omitempty"`

				// DeletedAt Date at which the Purchase Order was deleted
				DeletedAt *time.Time `json:"deletedAt"`

				// DueDate Due date of Purchase Order
				DueDate *string `json:"dueDate"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the Purchase Order
				Id float32 `json:"id"`

				// Items List of items in the Purchase Order
				Items []struct {
					// ExtraFields Custom Fields on the entity. Deprecated: Use `lineExtraFields` instead.
					// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
					ExtraFields *map[string]string `json:"extraFields,omitempty"`

					// Fulfillments Fulfillment information for the item's fulfillment locations.
					Fulfillments *[]struct {
						// Id ID of the item fulfillment
						Id *float32 `json:"id,omitempty"`

						// IsLegacy Indicates the location is a legacy location. This is used to determine if this fulfillment was done before enablement of the multi-location parts feature.
						IsLegacy *bool `json:"isLegacy,omitempty"`

						// LocationId ID of the location where the item was fulfilled
						LocationId *float32 `json:"locationId"`

						// QuantityReceived Quantity of the item fulfilled to this location
						QuantityReceived *string `json:"quantityReceived,omitempty"`
					} `json:"fulfillments,omitempty"`

					// Id ID of the item
					Id float32 `json:"id"`

					// LineExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
					LineExtraFields *map[string]string `json:"lineExtraFields,omitempty"`
					Name            *string            `json:"name"`

					// PartExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
					PartExtraFields *map[string]string `json:"partExtraFields,omitempty"`

					// PartId ID of the part this item is related to
					PartId     *float32 `json:"partId"`
					PartNumber *string  `json:"partNumber"`

					// Price Total price of items in cents
					Price *float32 `json:"price"`

					// QuantityOrdered Represent the amount of units for this item that were ordered in the purchase order.
					QuantityOrdered float32 `json:"quantityOrdered"`

					// QuantityReceived Represents the total amount of this specific item that has been received to date.
					QuantityReceived *float32 `json:"quantityReceived"`

					// UnitCost Price of a single item in cents
					UnitCost *float32 `json:"unitCost"`
				} `json:"items"`

				// Note Notes left for Purchase Orders
				Note *string `json:"note"`

				// OverrideNumber Custom number/identifier for Purchase Order
				OverrideNumber *string `json:"overrideNumber"`

				// ReviewNote Notes to be left for changes to be made when sending a Purchase Order for revision
				ReviewNote *string `json:"reviewNote"`

				// ShippingAddress Shipping address in the Purchase Order
				ShippingAddress *struct {
					City    string `json:"city"`
					Country string `json:"country"`

					// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
					Label      *string `json:"label"`
					PostalCode string  `json:"postalCode"`
					State      string  `json:"state"`
					Street     string  `json:"street"`
				} `json:"shippingAddress"`

				// Status Status of the Purchase Order. Supported values are APPROVED, CANCELED, COMPLETED, DECLINED, PARTIALLY_FULFILLED, PENDING, REQUESTED
				Status    *string `json:"status"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`

				// UpdatedAt Date the Purchase Order was last updated
				UpdatedAt *string `json:"updatedAt"`

				// VendorContactIds List of vendor contact IDs in the Purchase Order
				VendorContactIds *[]float32 `json:"vendorContactIds,omitempty"`

				// VendorId ID of vendor that this Purchase Order is associated with
				VendorId *float32 `json:"vendorId"`
			} `json:"purchaseOrder"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                       `json:"error"`
				FieldPath  *string                                      `json:"fieldPath"`
				FieldValue *PatchPurchaseordersId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                       `json:"error"`
				FieldPath  *string                                      `json:"fieldPath"`
				FieldValue *PatchPurchaseordersId_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeletePurchaseordersIdAttachmentsFilenameResponse parses an HTTP response from a DeletePurchaseordersIdAttachmentsFilenameWithResponse call
func ParseDeletePurchaseordersIdAttachmentsFilenameResponse(rsp *http.Response) (*DeletePurchaseordersIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePurchaseordersIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutPurchaseordersIdAttachmentsFilenameResponse parses an HTTP response from a PutPurchaseordersIdAttachmentsFilenameWithResponse call
func ParsePutPurchaseordersIdAttachmentsFilenameResponse(rsp *http.Response) (*PutPurchaseordersIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutPurchaseordersIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParsePostPurchaseordersIdCommentsResponse parses an HTTP response from a PostPurchaseordersIdCommentsWithResponse call
func ParsePostPurchaseordersIdCommentsResponse(rsp *http.Response) (*PostPurchaseordersIdCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPurchaseordersIdCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the comment
			Id float32 `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                              `json:"error"`
				FieldPath  *string                                             `json:"fieldPath"`
				FieldValue *PostPurchaseordersIdComments_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostPurchaseordersIdEmailsResponse parses an HTTP response from a PostPurchaseordersIdEmailsWithResponse call
func ParsePostPurchaseordersIdEmailsResponse(rsp *http.Response) (*PostPurchaseordersIdEmailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPurchaseordersIdEmailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the Purchase Order
			Id *int `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                            `json:"error"`
				FieldPath  *string                                           `json:"fieldPath"`
				FieldValue *PostPurchaseordersIdEmails_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                            `json:"error"`
				FieldPath  *string                                           `json:"fieldPath"`
				FieldValue *PostPurchaseordersIdEmails_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchPurchaseordersIdFulfillmentResponse parses an HTTP response from a PatchPurchaseordersIdFulfillmentWithResponse call
func ParsePatchPurchaseordersIdFulfillmentResponse(rsp *http.Response) (*PatchPurchaseordersIdFulfillmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchPurchaseordersIdFulfillmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			PurchaseOrder struct {
				// ApprovalDate Date the Purchase Order was approved
				ApprovalDate *string `json:"approvalDate"`

				// ApproverId ID of the user who approved the Purchase Order
				ApproverId *float32 `json:"approverId"`

				// Attachments List of attachments linked to the Purchase Order
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// AutoGeneratedNumber Autogenerated Purchase Order number
				AutoGeneratedNumber *float32 `json:"autoGeneratedNumber"`

				// BillingAddress Billing address in the Purchase Order
				BillingAddress *struct {
					City    string `json:"city"`
					Country string `json:"country"`

					// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
					Label      *string `json:"label"`
					PostalCode string  `json:"postalCode"`
					State      string  `json:"state"`
					Street     string  `json:"street"`
				} `json:"billingAddress"`

				// Costs List of costs in the Purchase Order
				Costs *[]struct {
					Amount float32 `json:"amount"`

					// Id ID of the cost
					Id *float32 `json:"id,omitempty"`

					// Name Description of the cost
					Name string `json:"name"`

					// Type Type of cost in either cents or percent. Accepted types in cents are AMOUNT_TAXABLE and AMOUNT_NON_TAXABLE. For percentage use PERCENT_TAXABLE
					Type PatchPurchaseordersIdFulfillment200PurchaseOrderCostsType `json:"type"`
				} `json:"costs,omitempty"`

				// CreatorId ID of the user that created this Purchase Order
				CreatorId *float32 `json:"creatorId,omitempty"`

				// DeletedAt Date at which the Purchase Order was deleted
				DeletedAt *time.Time `json:"deletedAt"`

				// DueDate Due date of Purchase Order
				DueDate *string `json:"dueDate"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the Purchase Order
				Id float32 `json:"id"`

				// Items List of items in the Purchase Order
				Items []struct {
					// ExtraFields Custom Fields on the entity. Deprecated: Use `lineExtraFields` instead.
					// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
					ExtraFields *map[string]string `json:"extraFields,omitempty"`

					// Fulfillments Fulfillment information for the item's fulfillment locations.
					Fulfillments *[]struct {
						// Id ID of the item fulfillment
						Id *float32 `json:"id,omitempty"`

						// IsLegacy Indicates the location is a legacy location. This is used to determine if this fulfillment was done before enablement of the multi-location parts feature.
						IsLegacy *bool `json:"isLegacy,omitempty"`

						// LocationId ID of the location where the item was fulfilled
						LocationId *float32 `json:"locationId"`

						// QuantityReceived Quantity of the item fulfilled to this location
						QuantityReceived *string `json:"quantityReceived,omitempty"`
					} `json:"fulfillments,omitempty"`

					// Id ID of the item
					Id float32 `json:"id"`

					// LineExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
					LineExtraFields *map[string]string `json:"lineExtraFields,omitempty"`
					Name            *string            `json:"name"`

					// PartExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
					PartExtraFields *map[string]string `json:"partExtraFields,omitempty"`

					// PartId ID of the part this item is related to
					PartId     *float32 `json:"partId"`
					PartNumber *string  `json:"partNumber"`

					// Price Total price of items in cents
					Price *float32 `json:"price"`

					// QuantityOrdered Represent the amount of units for this item that were ordered in the purchase order.
					QuantityOrdered float32 `json:"quantityOrdered"`

					// QuantityReceived Represents the total amount of this specific item that has been received to date.
					QuantityReceived *float32 `json:"quantityReceived"`

					// UnitCost Price of a single item in cents
					UnitCost *float32 `json:"unitCost"`
				} `json:"items"`

				// Note Notes left for Purchase Orders
				Note *string `json:"note"`

				// OverrideNumber Custom number/identifier for Purchase Order
				OverrideNumber *string `json:"overrideNumber"`

				// ReviewNote Notes to be left for changes to be made when sending a Purchase Order for revision
				ReviewNote *string `json:"reviewNote"`

				// ShippingAddress Shipping address in the Purchase Order
				ShippingAddress *struct {
					City    string `json:"city"`
					Country string `json:"country"`

					// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
					Label      *string `json:"label"`
					PostalCode string  `json:"postalCode"`
					State      string  `json:"state"`
					Street     string  `json:"street"`
				} `json:"shippingAddress"`

				// Status Status of the Purchase Order. Supported values are APPROVED, CANCELED, COMPLETED, DECLINED, PARTIALLY_FULFILLED, PENDING, REQUESTED
				Status    *string `json:"status"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`

				// UpdatedAt Date the Purchase Order was last updated
				UpdatedAt *string `json:"updatedAt"`

				// VendorContactIds List of vendor contact IDs in the Purchase Order
				VendorContactIds *[]float32 `json:"vendorContactIds,omitempty"`

				// VendorId ID of vendor that this Purchase Order is associated with
				VendorId *float32 `json:"vendorId"`
			} `json:"purchaseOrder"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                                  `json:"error"`
				FieldPath  *string                                                 `json:"fieldPath"`
				FieldValue *PatchPurchaseordersIdFulfillment_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                                  `json:"error"`
				FieldPath  *string                                                 `json:"fieldPath"`
				FieldValue *PatchPurchaseordersIdFulfillment_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchPurchaseordersIdStatusResponse parses an HTTP response from a PatchPurchaseordersIdStatusWithResponse call
func ParsePatchPurchaseordersIdStatusResponse(rsp *http.Response) (*PatchPurchaseordersIdStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchPurchaseordersIdStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			PurchaseOrder struct {
				// ApprovalDate Date the Purchase Order was approved
				ApprovalDate *string `json:"approvalDate"`

				// ApproverId ID of the user who approved the Purchase Order
				ApproverId *float32 `json:"approverId"`

				// Attachments List of attachments linked to the Purchase Order
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// AutoGeneratedNumber Autogenerated Purchase Order number
				AutoGeneratedNumber *float32 `json:"autoGeneratedNumber"`

				// BillingAddress Billing address in the Purchase Order
				BillingAddress *struct {
					City    string `json:"city"`
					Country string `json:"country"`

					// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
					Label      *string `json:"label"`
					PostalCode string  `json:"postalCode"`
					State      string  `json:"state"`
					Street     string  `json:"street"`
				} `json:"billingAddress"`

				// Costs List of costs in the Purchase Order
				Costs *[]struct {
					Amount float32 `json:"amount"`

					// Id ID of the cost
					Id *float32 `json:"id,omitempty"`

					// Name Description of the cost
					Name string `json:"name"`

					// Type Type of cost in either cents or percent. Accepted types in cents are AMOUNT_TAXABLE and AMOUNT_NON_TAXABLE. For percentage use PERCENT_TAXABLE
					Type PatchPurchaseordersIdStatus200PurchaseOrderCostsType `json:"type"`
				} `json:"costs,omitempty"`

				// CreatorId ID of the user that created this Purchase Order
				CreatorId *float32 `json:"creatorId,omitempty"`

				// DeletedAt Date at which the Purchase Order was deleted
				DeletedAt *time.Time `json:"deletedAt"`

				// DueDate Due date of Purchase Order
				DueDate *string `json:"dueDate"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the Purchase Order
				Id float32 `json:"id"`

				// Items List of items in the Purchase Order
				Items []struct {
					// ExtraFields Custom Fields on the entity. Deprecated: Use `lineExtraFields` instead.
					// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
					ExtraFields *map[string]string `json:"extraFields,omitempty"`

					// Fulfillments Fulfillment information for the item's fulfillment locations.
					Fulfillments *[]struct {
						// Id ID of the item fulfillment
						Id *float32 `json:"id,omitempty"`

						// IsLegacy Indicates the location is a legacy location. This is used to determine if this fulfillment was done before enablement of the multi-location parts feature.
						IsLegacy *bool `json:"isLegacy,omitempty"`

						// LocationId ID of the location where the item was fulfilled
						LocationId *float32 `json:"locationId"`

						// QuantityReceived Quantity of the item fulfilled to this location
						QuantityReceived *string `json:"quantityReceived,omitempty"`
					} `json:"fulfillments,omitempty"`

					// Id ID of the item
					Id float32 `json:"id"`

					// LineExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Ordered Date")
					LineExtraFields *map[string]string `json:"lineExtraFields,omitempty"`
					Name            *string            `json:"name"`

					// PartExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Part Number")
					PartExtraFields *map[string]string `json:"partExtraFields,omitempty"`

					// PartId ID of the part this item is related to
					PartId     *float32 `json:"partId"`
					PartNumber *string  `json:"partNumber"`

					// Price Total price of items in cents
					Price *float32 `json:"price"`

					// QuantityOrdered Represent the amount of units for this item that were ordered in the purchase order.
					QuantityOrdered float32 `json:"quantityOrdered"`

					// QuantityReceived Represents the total amount of this specific item that has been received to date.
					QuantityReceived *float32 `json:"quantityReceived"`

					// UnitCost Price of a single item in cents
					UnitCost *float32 `json:"unitCost"`
				} `json:"items"`

				// Note Notes left for Purchase Orders
				Note *string `json:"note"`

				// OverrideNumber Custom number/identifier for Purchase Order
				OverrideNumber *string `json:"overrideNumber"`

				// ReviewNote Notes to be left for changes to be made when sending a Purchase Order for revision
				ReviewNote *string `json:"reviewNote"`

				// ShippingAddress Shipping address in the Purchase Order
				ShippingAddress *struct {
					City    string `json:"city"`
					Country string `json:"country"`

					// Label A string to specify how the address will be displayed - Defaults to Street, City, Province/State, Postal Code, Country
					Label      *string `json:"label"`
					PostalCode string  `json:"postalCode"`
					State      string  `json:"state"`
					Street     string  `json:"street"`
				} `json:"shippingAddress"`

				// Status Status of the Purchase Order. Supported values are APPROVED, CANCELED, COMPLETED, DECLINED, PARTIALLY_FULFILLED, PENDING, REQUESTED
				Status    *string `json:"status"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`

				// UpdatedAt Date the Purchase Order was last updated
				UpdatedAt *string `json:"updatedAt"`

				// VendorContactIds List of vendor contact IDs in the Purchase Order
				VendorContactIds *[]float32 `json:"vendorContactIds,omitempty"`

				// VendorId ID of vendor that this Purchase Order is associated with
				VendorId *float32 `json:"vendorId"`
			} `json:"purchaseOrder"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                             `json:"error"`
				FieldPath  *string                                            `json:"fieldPath"`
				FieldValue *PatchPurchaseordersIdStatus_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                             `json:"error"`
				FieldPath  *string                                            `json:"fieldPath"`
				FieldValue *PatchPurchaseordersIdStatus_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutPurchaseordersIdThumbnailFilenameResponse parses an HTTP response from a PutPurchaseordersIdThumbnailFilenameWithResponse call
func ParsePutPurchaseordersIdThumbnailFilenameResponse(rsp *http.Response) (*PutPurchaseordersIdThumbnailFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutPurchaseordersIdThumbnailFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                                      `json:"error"`
				FieldPath  *string                                                     `json:"fieldPath"`
				FieldValue *PutPurchaseordersIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParsePostSubscriptionsResponse parses an HTTP response from a PostSubscriptionsWithResponse call
func ParsePostSubscriptionsResponse(rsp *http.Response) (*PostSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the subscription
			Id int `json:"id"`

			// Secret Secret to hash the Hmac signature
			Secret *string `json:"secret,omitempty"`

			// Status Validation status of the subscription. Contact support if your subscription returns PENDING_APPROVAL before using the subscription.
			Status PostSubscriptions201Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                   `json:"error"`
				FieldPath  *string                                  `json:"fieldPath"`
				FieldValue *PostSubscriptions_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                   `json:"error"`
				FieldPath  *string                                  `json:"fieldPath"`
				FieldValue *PostSubscriptions_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteSubscriptionsIdResponse parses an HTTP response from a DeleteSubscriptionsIdWithResponse call
func ParseDeleteSubscriptionsIdResponse(rsp *http.Response) (*DeleteSubscriptionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscriptionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                       `json:"error"`
				FieldPath  *string                                      `json:"fieldPath"`
				FieldValue *DeleteSubscriptionsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                       `json:"error"`
				FieldPath  *string                                      `json:"fieldPath"`
				FieldValue *DeleteSubscriptionsId_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionsIdResponse parses an HTTP response from a GetSubscriptionsIdWithResponse call
func ParseGetSubscriptionsIdResponse(rsp *http.Response) (*GetSubscriptionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Subscription struct {
				// Id Global ID of the subscription
				Id int `json:"id"`

				// Status Validation status of the subscription. Contact support if your subscription returns PENDING_APPROVAL before using the subscription.
				Status GetSubscriptionsId200SubscriptionStatus `json:"status"`

				// Type Type of event subscribed to
				Type GetSubscriptionsId200SubscriptionType `json:"type"`
				Url  string                                `json:"url"`
			} `json:"subscription"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchSubscriptionsIdResponse parses an HTTP response from a PatchSubscriptionsIdWithResponse call
func ParsePatchSubscriptionsIdResponse(rsp *http.Response) (*PatchSubscriptionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSubscriptionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Subscription struct {
				// Id Global ID of the subscription
				Id int `json:"id"`

				// Status Validation status of the subscription. Contact support if your subscription returns PENDING_APPROVAL before using the subscription.
				Status PatchSubscriptionsId200SubscriptionStatus `json:"status"`

				// Type Type of event subscribed to
				Type PatchSubscriptionsId200SubscriptionType `json:"type"`
				Url  string                                  `json:"url"`
			} `json:"subscription"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                      `json:"error"`
				FieldPath  *string                                     `json:"fieldPath"`
				FieldValue *PatchSubscriptionsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionsIdSecretResponse parses an HTTP response from a GetSubscriptionsIdSecretWithResponse call
func ParseGetSubscriptionsIdSecretResponse(rsp *http.Response) (*GetSubscriptionsIdSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionsIdSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Secret string `json:"secret"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTeamsResponse parses an HTTP response from a GetTeamsWithResponse call
func ParseGetTeamsResponse(rsp *http.Response) (*GetTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor The cursor to retrieve the next page of Teams.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Teams.
			NextPageUrl *string `json:"nextPageUrl"`
			Teams       []struct {
				// Id Global ID of the team
				Id   int    `json:"id"`
				Name string `json:"name"`
			} `json:"teams"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostTeamsResponse parses an HTTP response from a PostTeamsWithResponse call
func ParsePostTeamsResponse(rsp *http.Response) (*PostTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the team
			Id int `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                           `json:"error"`
				FieldPath  *string                          `json:"fieldPath"`
				FieldValue *PostTeams_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteTeamsIdResponse parses an HTTP response from a DeleteTeamsIdWithResponse call
func ParseDeleteTeamsIdResponse(rsp *http.Response) (*DeleteTeamsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                               `json:"error"`
				FieldPath  *string                              `json:"fieldPath"`
				FieldValue *DeleteTeamsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTeamsIdResponse parses an HTTP response from a GetTeamsIdWithResponse call
func ParseGetTeamsIdResponse(rsp *http.Response) (*GetTeamsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Team struct {
				// AssetIds List of asset IDs that the team is responsible for
				AssetIds    *[]int  `json:"assetIds,omitempty"`
				Description *string `json:"description,omitempty"`

				// Id Global ID of the team
				Id int `json:"id"`

				// LocationIds List of location where the team is operating
				LocationIds *[]int `json:"locationIds,omitempty"`

				// MembersCount Number of team members
				MembersCount int    `json:"membersCount"`
				Name         string `json:"name"`
			} `json:"team"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchTeamsIdResponse parses an HTTP response from a PatchTeamsIdWithResponse call
func ParsePatchTeamsIdResponse(rsp *http.Response) (*PatchTeamsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchTeamsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Team struct {
				// AssetIds List of asset IDs that the team is responsible for
				AssetIds    *[]int  `json:"assetIds,omitempty"`
				Description *string `json:"description,omitempty"`

				// Id Global ID of the team
				Id int `json:"id"`

				// LocationIds List of location where the team is operating
				LocationIds *[]int `json:"locationIds,omitempty"`

				// MembersCount Number of team members
				MembersCount int    `json:"membersCount"`
				Name         string `json:"name"`
			} `json:"team"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                              `json:"error"`
				FieldPath  *string                             `json:"fieldPath"`
				FieldValue *PatchTeamsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTeamsIdMembersResponse parses an HTTP response from a GetTeamsIdMembersWithResponse call
func ParseGetTeamsIdMembersResponse(rsp *http.Response) (*GetTeamsIdMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsIdMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Members []struct {
				FirstName *string `json:"firstName,omitempty"`

				// Id Global ID of the user
				Id       int                                 `json:"id"`
				LastName *string                             `json:"lastName,omitempty"`
				TeamRole GetTeamsIdMembers200MembersTeamRole `json:"teamRole"`
			} `json:"members"`

			// NextCursor The cursor to retrieve the next page of Members.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Members.
			NextPageUrl *string `json:"nextPageUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostTeamsIdMembersResponse parses an HTTP response from a PostTeamsIdMembersWithResponse call
func ParsePostTeamsIdMembersResponse(rsp *http.Response) (*PostTeamsIdMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTeamsIdMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the user
			Id int `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                    `json:"error"`
				FieldPath  *string                                   `json:"fieldPath"`
				FieldValue *PostTeamsIdMembers_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteTeamsTeamIdMembersUserIdResponse parses an HTTP response from a DeleteTeamsTeamIdMembersUserIdWithResponse call
func ParseDeleteTeamsTeamIdMembersUserIdResponse(rsp *http.Response) (*DeleteTeamsTeamIdMembersUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamsTeamIdMembersUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                                `json:"error"`
				FieldPath  *string                                               `json:"fieldPath"`
				FieldValue *DeleteTeamsTeamIdMembersUserId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchTeamsTeamIdMembersUserIdResponse parses an HTTP response from a PatchTeamsTeamIdMembersUserIdWithResponse call
func ParsePatchTeamsTeamIdMembersUserIdResponse(rsp *http.Response) (*PatchTeamsTeamIdMembersUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchTeamsTeamIdMembersUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Member struct {
				FirstName *string `json:"firstName,omitempty"`

				// Id Global ID of the user
				Id       int                                            `json:"id"`
				LastName *string                                        `json:"lastName,omitempty"`
				TeamRole PatchTeamsTeamIdMembersUserId200MemberTeamRole `json:"teamRole"`
			} `json:"member"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                               `json:"error"`
				FieldPath  *string                                              `json:"fieldPath"`
				FieldValue *PatchTeamsTeamIdMembersUserId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor The cursor to retrieve the next page of Users.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Users.
			NextPageUrl *string `json:"nextPageUrl"`
			Users       []struct {
				AuthType *GetUsers200UsersAuthType `json:"authType"`
				Email    *string                   `json:"email"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Department") (expand with query parameter)
				ExtraFields *map[string]string `json:"extraFields,omitempty"`
				FirstName   string             `json:"firstName"`

				// HourlyRate Cost in cents. For example, for $1.20, the value will be 120. If the hourly rate is not set specifically for the user, the API will return the default organization hourly rate, if that is also not set, it will return the hourly rate that is specifically set for the user in any work order. Otherwise, it would be `undefined`
				HourlyRate *int `json:"hourlyRate"`

				// Id Global ID of the user
				Id          int     `json:"id"`
				LastName    string  `json:"lastName"`
				PhoneNumber *string `json:"phoneNumber"`

				// Role (expand with query parameter)
				Role *GetUsers200UsersRole `json:"role,omitempty"`
			} `json:"users"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostUsersResponse parses an HTTP response from a PostUsersWithResponse call
func ParsePostUsersResponse(rsp *http.Response) (*PostUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the user
			Id int `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                           `json:"error"`
				FieldPath  *string                          `json:"fieldPath"`
				FieldValue *PostUsers_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                           `json:"error"`
				FieldPath  *string                          `json:"fieldPath"`
				FieldValue *PostUsers_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteUsersIdResponse parses an HTTP response from a DeleteUsersIdWithResponse call
func ParseDeleteUsersIdResponse(rsp *http.Response) (*DeleteUsersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                               `json:"error"`
				FieldPath  *string                              `json:"fieldPath"`
				FieldValue *DeleteUsersId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUsersIdResponse parses an HTTP response from a GetUsersIdWithResponse call
func ParseGetUsersIdResponse(rsp *http.Response) (*GetUsersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			User struct {
				AuthType *GetUsersId200UserAuthType `json:"authType"`

				// CustomRole Custom role name if the user has a custom role assigned
				CustomRole *string `json:"customRole"`
				Email      *string `json:"email"`

				// ExternalData Extra data that can be attached to the user, for example to help reference to a matching record in an external system.
				ExternalData *GetUsersId_200_User_ExternalData `json:"externalData"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Department")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`
				FirstName   string             `json:"firstName"`

				// HourlyRate Cost in cents. For example, for $1.20, the value will be 120. If the hourly rate is not set specifically for the user, the API will return the default organization hourly rate, if that is also not set, it will return the hourly rate that is specifically set for the user in any work order. Otherwise, it would be `undefined`
				HourlyRate *int `json:"hourlyRate"`

				// Id Global ID of the user
				Id                      int                    `json:"id"`
				LastName                string                 `json:"lastName"`
				PhoneNumber             *string                `json:"phoneNumber"`
				RemovedFromOrganization *bool                  `json:"removedFromOrganization,omitempty"`
				Role                    *GetUsersId200UserRole `json:"role"`
			} `json:"user"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchUsersIdResponse parses an HTTP response from a PatchUsersIdWithResponse call
func ParsePatchUsersIdResponse(rsp *http.Response) (*PatchUsersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			User struct {
				AuthType *PatchUsersId200UserAuthType `json:"authType"`

				// CustomRole Custom role name if the user has a custom role assigned
				CustomRole *string `json:"customRole"`
				Email      *string `json:"email"`

				// ExternalData Extra data that can be attached to the user, for example to help reference to a matching record in an external system.
				ExternalData *PatchUsersId_200_User_ExternalData `json:"externalData"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Department")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`
				FirstName   *string            `json:"firstName,omitempty"`

				// HourlyRate Cost in cents. For example, for $1.20, the value will be 120. If the hourly rate is not set specifically for the user, the API will return the default organization hourly rate, if that is also not set, it will return the hourly rate that is specifically set for the user in any work order. Otherwise, it would be `undefined`
				HourlyRate *int `json:"hourlyRate"`

				// Id Global ID of the user
				Id                      int                      `json:"id"`
				LastName                *string                  `json:"lastName,omitempty"`
				PhoneNumber             *string                  `json:"phoneNumber"`
				RemovedFromOrganization *bool                    `json:"removedFromOrganization,omitempty"`
				Role                    *PatchUsersId200UserRole `json:"role"`
			} `json:"user"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                              `json:"error"`
				FieldPath  *string                             `json:"fieldPath"`
				FieldValue *PatchUsersId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                              `json:"error"`
				FieldPath  *string                             `json:"fieldPath"`
				FieldValue *PatchUsersId_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostUsersIdMessagesResponse parses an HTTP response from a PostUsersIdMessagesWithResponse call
func ParsePostUsersIdMessagesResponse(rsp *http.Response) (*PostUsersIdMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUsersIdMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// ConversationId ID of the conversation
			ConversationId float32 `json:"conversationId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                     `json:"error"`
				FieldPath  *string                                    `json:"fieldPath"`
				FieldValue *PostUsersIdMessages_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                     `json:"error"`
				FieldPath  *string                                    `json:"fieldPath"`
				FieldValue *PostUsersIdMessages_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetVendorsResponse parses an HTTP response from a GetVendorsWithResponse call
func ParseGetVendorsResponse(rsp *http.Response) (*GetVendorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVendorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor The cursor to retrieve the next page of Vendors.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Vendors.
			NextPageUrl *string `json:"nextPageUrl"`
			Vendors     []struct {
				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Qualifications") (expand with query parameter)
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the vendor
				Id   int    `json:"id"`
				Name string `json:"name"`
			} `json:"vendors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostVendorsResponse parses an HTTP response from a PostVendorsWithResponse call
func ParsePostVendorsResponse(rsp *http.Response) (*PostVendorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVendorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the vendor
			Id int `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                             `json:"error"`
				FieldPath  *string                            `json:"fieldPath"`
				FieldValue *PostVendors_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteVendorsIdResponse parses an HTTP response from a DeleteVendorsIdWithResponse call
func ParseDeleteVendorsIdResponse(rsp *http.Response) (*DeleteVendorsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVendorsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                 `json:"error"`
				FieldPath  *string                                `json:"fieldPath"`
				FieldValue *DeleteVendorsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetVendorsIdResponse parses an HTTP response from a GetVendorsIdWithResponse call
func ParseGetVendorsIdResponse(rsp *http.Response) (*GetVendorsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVendorsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Vendor struct {
				// Attachments List of attachments linked to the vendor
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// ContactIds List of contact IDs
				ContactIds *[]int `json:"contactIds,omitempty"`

				// DeletedAt Date that the vendor was deleted
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// Emails List of email address
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				Emails *[]string `json:"emails,omitempty"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Qualifications")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the vendor
				Id   int    `json:"id"`
				Name string `json:"name"`

				// PhoneNumbers List of phone number
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				PhoneNumbers *[]string `json:"phoneNumbers,omitempty"`
				Thumbnail    *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`
			} `json:"vendor"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchVendorsIdResponse parses an HTTP response from a PatchVendorsIdWithResponse call
func ParsePatchVendorsIdResponse(rsp *http.Response) (*PatchVendorsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchVendorsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Vendor struct {
				// Attachments List of attachments linked to the vendor
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// ContactIds List of contact IDs
				ContactIds *[]int `json:"contactIds,omitempty"`

				// DeletedAt Date that the vendor was deleted
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// Emails List of email address
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				Emails *[]string `json:"emails,omitempty"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Qualifications")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the vendor
				Id   int    `json:"id"`
				Name string `json:"name"`

				// PhoneNumbers List of phone number
				// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
				PhoneNumbers *[]string `json:"phoneNumbers,omitempty"`
				Thumbnail    *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`
			} `json:"vendor"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                `json:"error"`
				FieldPath  *string                               `json:"fieldPath"`
				FieldValue *PatchVendorsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteVendorsIdAttachmentsFilenameResponse parses an HTTP response from a DeleteVendorsIdAttachmentsFilenameWithResponse call
func ParseDeleteVendorsIdAttachmentsFilenameResponse(rsp *http.Response) (*DeleteVendorsIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVendorsIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutVendorsIdAttachmentsFilenameResponse parses an HTTP response from a PutVendorsIdAttachmentsFilenameWithResponse call
func ParsePutVendorsIdAttachmentsFilenameResponse(rsp *http.Response) (*PutVendorsIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutVendorsIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseGetVendorsIdContactsResponse parses an HTTP response from a GetVendorsIdContactsWithResponse call
func ParseGetVendorsIdContactsResponse(rsp *http.Response) (*GetVendorsIdContactsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVendorsIdContactsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Contacts []struct {
				// Email Email address of contact.
				Email *string `json:"email"`

				// Extension Phone number extension
				Extension *string `json:"extension"`

				// Id Global ID of the contact
				Id   float32 `json:"id"`
				Name string  `json:"name"`

				// PhoneNumber Phone number of contact
				PhoneNumber *string `json:"phoneNumber"`

				// Role Role/Label of the contact.
				Role *string `json:"role"`

				// VendorId ID of vendor that contact will be associated to
				VendorId float32 `json:"vendorId"`
			} `json:"contacts"`

			// NextCursor The cursor to retrieve the next page of Contacts.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Contacts.
			NextPageUrl *string `json:"nextPageUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostVendorsIdContactsResponse parses an HTTP response from a PostVendorsIdContactsWithResponse call
func ParsePostVendorsIdContactsResponse(rsp *http.Response) (*PostVendorsIdContactsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVendorsIdContactsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Email Email address of contact.
			Email *string `json:"email"`

			// Extension Phone number extension
			Extension *string `json:"extension"`

			// Id Global ID of the contact
			Id   float32 `json:"id"`
			Name string  `json:"name"`

			// PhoneNumber Phone number of contact
			PhoneNumber *string `json:"phoneNumber"`

			// Role Role/Label of the contact.
			Role *string `json:"role"`

			// VendorId ID of vendor that contact will be associated to
			VendorId float32 `json:"vendorId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                       `json:"error"`
				FieldPath  *string                                      `json:"fieldPath"`
				FieldValue *PostVendorsIdContacts_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteVendorsIdContactsContactIdResponse parses an HTTP response from a DeleteVendorsIdContactsContactIdWithResponse call
func ParseDeleteVendorsIdContactsContactIdResponse(rsp *http.Response) (*DeleteVendorsIdContactsContactIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVendorsIdContactsContactIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                                  `json:"error"`
				FieldPath  *string                                                 `json:"fieldPath"`
				FieldValue *DeleteVendorsIdContactsContactId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetVendorsIdContactsContactIdResponse parses an HTTP response from a GetVendorsIdContactsContactIdWithResponse call
func ParseGetVendorsIdContactsContactIdResponse(rsp *http.Response) (*GetVendorsIdContactsContactIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVendorsIdContactsContactIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			VendorContact struct {
				// Email Email address of contact.
				Email *string `json:"email"`

				// Extension Phone number extension
				Extension *string `json:"extension"`

				// Id Global ID of the contact
				Id   float32 `json:"id"`
				Name string  `json:"name"`

				// PhoneNumber Phone number of contact
				PhoneNumber *string `json:"phoneNumber"`

				// Role Role/Label of the contact.
				Role *string `json:"role"`

				// VendorId ID of vendor that contact will be associated to
				VendorId float32 `json:"vendorId"`
			} `json:"vendorContact"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                               `json:"error"`
				FieldPath  *string                                              `json:"fieldPath"`
				FieldValue *GetVendorsIdContactsContactId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchVendorsIdContactsContactIdResponse parses an HTTP response from a PatchVendorsIdContactsContactIdWithResponse call
func ParsePatchVendorsIdContactsContactIdResponse(rsp *http.Response) (*PatchVendorsIdContactsContactIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchVendorsIdContactsContactIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Contact struct {
				// Email Email address of contact.
				Email *string `json:"email"`

				// Extension Phone number extension
				Extension *string `json:"extension"`

				// Id Global ID of the contact
				Id   float32 `json:"id"`
				Name string  `json:"name"`

				// PhoneNumber Phone number of contact
				PhoneNumber *string `json:"phoneNumber"`

				// Role Role/Label of the contact.
				Role *string `json:"role"`

				// VendorId ID of vendor that contact will be associated to
				VendorId float32 `json:"vendorId"`
			} `json:"contact"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                                 `json:"error"`
				FieldPath  *string                                                `json:"fieldPath"`
				FieldValue *PatchVendorsIdContactsContactId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutVendorsIdThumbnailFilenameResponse parses an HTTP response from a PutVendorsIdThumbnailFilenameWithResponse call
func ParsePutVendorsIdThumbnailFilenameResponse(rsp *http.Response) (*PutVendorsIdThumbnailFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutVendorsIdThumbnailFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                               `json:"error"`
				FieldPath  *string                                              `json:"fieldPath"`
				FieldValue *PutVendorsIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseGetVersionsResponse parses an HTTP response from a GetVersionsWithResponse call
func ParseGetVersionsResponse(rsp *http.Response) (*GetVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Version string `json:"version"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostWorkPermitsIdSignResponse parses an HTTP response from a PostWorkPermitsIdSignWithResponse call
func ParsePostWorkPermitsIdSignResponse(rsp *http.Response) (*PostWorkPermitsIdSignResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWorkPermitsIdSignResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Success   bool `json:"success"`
			WorkOrder struct {
				BlockedByWorkPermitReason *string `json:"blockedByWorkPermitReason"`
				Id                        int     `json:"id"`
			} `json:"workOrder"`
			WorkPermit struct {
				Id     int    `json:"id"`
				Status string `json:"status"`
			} `json:"workPermit"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                       `json:"error"`
				FieldPath  *string                                      `json:"fieldPath"`
				FieldValue *PostWorkPermitsIdSign_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                       `json:"error"`
				FieldPath  *string                                      `json:"fieldPath"`
				FieldValue *PostWorkPermitsIdSign_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetWorkordersResponse parses an HTTP response from a GetWorkordersWithResponse call
func ParseGetWorkordersResponse(rsp *http.Response) (*GetWorkordersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkordersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor The cursor to retrieve the next page of Work Orders.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Work Orders.
			NextPageUrl *string `json:"nextPageUrl"`
			WorkOrders  []struct {
				// Asset Asset linked to the element (expand with query parameter)
				Asset *struct {
					// CreatedAt Date & time at which the asset was created
					CreatedAt time.Time `json:"createdAt"`

					// CreatorId ID of the asset creator
					CreatorId *int `json:"creatorId"`

					// CriticalityId ID of the criticality of the asset
					CriticalityId *int    `json:"criticalityId"`
					Description   *string `json:"description"`

					// Id Global ID of the asset
					Id int `json:"id"`

					// LocationId ID of the location where the asset is located
					LocationId *int   `json:"locationId"`
					Name       string `json:"name"`

					// ParentId ID of the parent asset
					ParentId *int `json:"parentId"`

					// SerialNumber Serial number of the asset
					SerialNumber *string `json:"serialNumber"`

					// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"asset"`

				// Assignees Either the teamId, the userId or the user email address (expand with query parameter)
				Assignees *[]struct {
					Id   GetWorkorders_200_WorkOrders_Assignees_Id `json:"id"`
					Type GetWorkorders200WorkOrdersAssigneesType   `json:"type"`
				} `json:"assignees,omitempty"`

				// Categories List of categories that identify the work order (expand with query parameter)
				Categories *[]string `json:"categories,omitempty"`

				// CompletedAt Date & time at which the work order was last marked as DONE
				CompletedAt *time.Time `json:"completedAt"`

				// CompleterId ID of the user who completed the work order
				CompleterId *int `json:"completerId"`

				// CreatedAt Date & time at which the work order was created
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// CreatorId ID of the user who created the work order
				CreatorId *int `json:"creatorId"`

				// DeletedAt Date & time at which the work order was deleted
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// DueDate Date & time at which the work order is due
				DueDate          *time.Time `json:"dueDate"`
				DueDateIsFullDay *bool      `json:"dueDateIsFullDay"`
				Expenditures     *[]struct {
					// CostPerUnit Cost per part in cents or cents per hour
					CostPerUnit *float32 `json:"costPerUnit"`

					// Description Description of the expense or part description
					Description *string `json:"description"`

					// DurationTotal Total duration in seconds
					DurationTotal *float32 `json:"durationTotal,omitempty"`

					// PartId ID of the part used in this cost entry
					PartId *int `json:"partId"`

					// Quantity Number of parts or number of hours
					Quantity *float32 `json:"quantity,omitempty"`

					// RowTotal Total cost in cents
					RowTotal *float32 `json:"rowTotal,omitempty"`

					// Type Type of the entry
					Type *GetWorkorders200WorkOrdersExpendituresType `json:"type,omitempty"`

					// UserId ID of the user who logged the time entry
					UserId *int `json:"userId"`
				} `json:"expenditures,omitempty"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Budget") (expand with query parameter)
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the work order
				Id int `json:"id"`

				// Location Location linked to the element (expand with query parameter)
				Location *struct {
					// Address Postal address of the location
					Address *string `json:"address"`

					// CreatedAt Date & time at which the location was created
					CreatedAt   *time.Time `json:"createdAt,omitempty"`
					Description *string    `json:"description"`

					// Id Global ID of the location
					Id   int    `json:"id"`
					Name string `json:"name"`

					// ParentId ID of the parent location
					ParentId *int `json:"parentId"`

					// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
					UpdatedAt *time.Time `json:"updatedAt,omitempty"`
				} `json:"location"`

				// LocationId Global ID of the location assigned to the work order
				LocationId     *int     `json:"locationId"`
				NextId         *int     `json:"nextId"`
				OrganizationId *float32 `json:"organizationId,omitempty"`

				// Parts Parts attached to the work order (expand with query parameter)
				Parts *[]struct {
					Area *string `json:"area"`

					// AvailableQuantity Quantity currently in stock
					AvailableQuantity int `json:"availableQuantity"`

					// Barcode String encoded barcode
					Barcode *string `json:"barcode"`

					// CopyOnRecurring Indicates if the parts will be copied to the next work order in the chain (if applicable).
					CopyOnRecurring GetWorkorders200WorkOrdersPartsCopyOnRecurring `json:"copyOnRecurring"`
					Description     *string                                        `json:"description"`
					ExtraFields     *map[string]string                             `json:"extraFields,omitempty"`

					// Id Global ID of the part
					Id int `json:"id"`

					// LocationId Global ID of the location of the part
					LocationId *float32 `json:"locationId"`

					// MinimumQuantity Minimum quantity before you should restock
					MinimumQuantity int    `json:"minimumQuantity"`
					Name            string `json:"name"`

					// QuantityUsed Quantity used in the work order.
					QuantityUsed int `json:"quantityUsed"`

					// UnitCost Cost in cents. For example, for $1.20, put 120.
					UnitCost *int `json:"unitCost"`
				} `json:"parts,omitempty"`
				PreviousId *int                                `json:"previousId"`
				Priority   *GetWorkorders200WorkOrdersPriority `json:"priority,omitempty"`

				// Procedure Procedure attached to the work order (expand with query parameter)
				Procedure *struct {
					Fields []struct {
						Assignees *struct {
							TeamIds *[]float32 `json:"teamIds,omitempty"`
							UserIds *[]float32 `json:"userIds,omitempty"`
						} `json:"assignees"`

						// Description Description of the procedure field
						Description *string `json:"description"`

						// Id ID of the procedure field
						Id float32 `json:"id"`

						// IsDateAndTime Indicate if a DATE field also contains the time
						IsDateAndTime *bool `json:"isDateAndTime"`

						// Label Label of a procedure field
						Label string `json:"label"`

						// MaxScore Maximum score of a procedure field
						MaxScore *float32 `json:"maxScore,omitempty"`

						// Meter Meter of a procedure field. Will be filled if the type of the field is meter
						Meter *struct {
							// Id Global ID of the meter.
							Id *float32 `json:"id,omitempty"`

							// Name Name of the meters
							Name *string `json:"name,omitempty"`
						} `json:"meter"`

						// ParentId ID of the parent of the current procedure field
						ParentId *float32 `json:"parentId"`

						// Required Indicate if field is required to be filled.
						Required bool `json:"required"`

						// Score Score of a procedure field
						Score *float32 `json:"score,omitempty"`

						// Type Type of procedure field
						Type GetWorkorders200WorkOrdersProcedureFieldsType `json:"type"`

						// Value Current value of a procedure field
						Value struct {
							// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
							Attachment *struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachment,omitempty"`
							Attachments *[]struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachments,omitempty"`
							HasAttachments *bool `json:"hasAttachments"`

							// Notes Note added to a procedure field
							Notes *struct {
								Text *string `json:"text,omitempty"`
							} `json:"notes"`
							Text *string `json:"text"`
						} `json:"value"`
					} `json:"fields"`

					// Id ID representing a procedure
					Id *float32 `json:"id,omitempty"`

					// MaxScore Maximum score of a procedure
					MaxScore *float32 `json:"maxScore,omitempty"`

					// Score Score of a procedure
					Score *float32 `json:"score,omitempty"`

					// TemplateIds IDs of the procedure template of the procedure
					TemplateIds *[]float32 `json:"templateIds"`

					// Title Title of the procedure
					Title string `json:"title"`
				} `json:"procedure,omitempty"`
				RecurrenceInfo *GetWorkorders_200_WorkOrders_RecurrenceInfo `json:"recurrenceInfo"`

				// RequesterId ID of the user who requested the work order through the Work Request feature
				RequesterId *int `json:"requesterId"`

				// SequentialId Organization specific ID of the work order
				SequentialId int `json:"sequentialId"`

				// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
				StartDate *time.Time `json:"startDate"`

				// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
				Status GetWorkorders200WorkOrdersStatus `json:"status"`

				// Thumbnail (expand with query parameter)
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail,omitempty"`
				TimeItems *[]struct {
					// CostPerUnit Cost per part in cents or cents per hour
					CostPerUnit *float32 `json:"costPerUnit"`

					// Description Description of the expense or part description
					Description *string `json:"description"`

					// DurationTotal Total duration in seconds
					DurationTotal *float32 `json:"durationTotal,omitempty"`

					// PartId ID of the part used in this cost entry
					PartId *int `json:"partId"`

					// Quantity Number of parts or number of hours
					Quantity *float32 `json:"quantity,omitempty"`

					// RowTotal Total cost in cents
					RowTotal *float32 `json:"rowTotal,omitempty"`

					// Type Type of the entry
					Type *GetWorkorders200WorkOrdersTimeItemsType `json:"type,omitempty"`

					// UserId ID of the user who logged the time entry
					UserId *int `json:"userId"`
				} `json:"timeItems,omitempty"`
				Times *[]struct {
					// CostPerUnit Cost per part in cents or cents per hour
					CostPerUnit *float32 `json:"costPerUnit"`

					// Description Description of the expense or part description
					Description *string `json:"description"`

					// DurationTotal Total duration in seconds
					DurationTotal *float32 `json:"durationTotal,omitempty"`

					// PartId ID of the part used in this cost entry
					PartId *int `json:"partId"`

					// Quantity Number of parts or number of hours
					Quantity *float32 `json:"quantity,omitempty"`

					// RowTotal Total cost in cents
					RowTotal *float32 `json:"rowTotal,omitempty"`

					// Type Type of the entry
					Type *GetWorkorders200WorkOrdersTimesType `json:"type,omitempty"`

					// UserId ID of the user who logged the time entry
					UserId *int `json:"userId"`
				} `json:"times,omitempty"`
				Title string `json:"title"`

				// Type Valid types of Work Orders, including options that are not available for creation/update. Historical Work Orders may have a null type.
				Type *GetWorkorders200WorkOrdersType `json:"type"`

				// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`

				// VendorIds Vendor IDs
				VendorIds *[]float32 `json:"vendorIds,omitempty"`
			} `json:"workOrders"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostWorkordersResponse parses an HTTP response from a PostWorkordersWithResponse call
func ParsePostWorkordersResponse(rsp *http.Response) (*PostWorkordersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWorkordersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id float32 `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                `json:"error"`
				FieldPath  *string                               `json:"fieldPath"`
				FieldValue *PostWorkorders_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteWorkordersIdResponse parses an HTTP response from a DeleteWorkordersIdWithResponse call
func ParseDeleteWorkordersIdResponse(rsp *http.Response) (*DeleteWorkordersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkordersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                    `json:"error"`
				FieldPath  *string                                   `json:"fieldPath"`
				FieldValue *DeleteWorkordersId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetWorkordersIdResponse parses an HTTP response from a GetWorkordersIdWithResponse call
func ParseGetWorkordersIdResponse(rsp *http.Response) (*GetWorkordersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkordersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			WorkOrder struct {
				// Asset Asset linked to the element (expand with query parameter)
				Asset *struct {
					// CreatedAt Date & time at which the asset was created
					CreatedAt time.Time `json:"createdAt"`

					// CreatorId ID of the asset creator
					CreatorId *int `json:"creatorId"`

					// CriticalityId ID of the criticality of the asset
					CriticalityId *int    `json:"criticalityId"`
					Description   *string `json:"description"`

					// Id Global ID of the asset
					Id int `json:"id"`

					// LocationId ID of the location where the asset is located
					LocationId *int   `json:"locationId"`
					Name       string `json:"name"`

					// ParentId ID of the parent asset
					ParentId *int `json:"parentId"`

					// SerialNumber Serial number of the asset
					SerialNumber *string `json:"serialNumber"`

					// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"asset"`
				AssetId *int `json:"assetId"`

				// AssigneeIds List of user ids assigned to the work order
				AssigneeIds *[]int `json:"assigneeIds,omitempty"`

				// Assignees Either the teamId, the userId or the user email address (expand with query parameter)
				Assignees *[]struct {
					Id   GetWorkordersId_200_WorkOrder_Assignees_Id `json:"id"`
					Type GetWorkordersId200WorkOrderAssigneesType   `json:"type"`
				} `json:"assignees,omitempty"`

				// Attachments List of attachments linked to the work order
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// Categories List of categories that identify the work order
				Categories *[]string `json:"categories,omitempty"`

				// CompletedAt Date & time at which the work order was last marked as DONE
				CompletedAt *time.Time `json:"completedAt"`

				// CompleterId ID of the user who completed the work order
				CompleterId *int `json:"completerId"`

				// CreatedAt Date & time at which the work order was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId ID of the user who created the work order
				CreatorId *int `json:"creatorId"`

				// DeletedAt Date & time at which the work order was deleted
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// DueDate Date & time at which the work order is due
				DueDate          *time.Time `json:"dueDate"`
				DueDateIsFullDay *bool      `json:"dueDateIsFullDay"`

				// EstimatedTime The estimated time taken in seconds to complete the work order (expand with query parameter)
				EstimatedTime *int `json:"estimatedTime"`

				// Expenditures Other cost entries on the Work Order. Grouped by users (expand with query parameter)
				Expenditures *[]struct {
					// CostPerUnit Cost per part in cents or cents per hour
					CostPerUnit *float32 `json:"costPerUnit"`

					// Description Description of the expense or part description
					Description *string `json:"description"`

					// DurationTotal Total duration in seconds
					DurationTotal *float32 `json:"durationTotal,omitempty"`

					// PartId ID of the part used in this cost entry
					PartId *int `json:"partId"`

					// Quantity Number of parts or number of hours
					Quantity *float32 `json:"quantity,omitempty"`

					// RowTotal Total cost in cents
					RowTotal *float32 `json:"rowTotal,omitempty"`

					// Type Type of the entry
					Type *GetWorkordersId200WorkOrderExpendituresType `json:"type,omitempty"`

					// UserId ID of the user who logged the time entry
					UserId *int `json:"userId"`
				} `json:"expenditures,omitempty"`

				// ExternalData Extra data that can be attached to the work order, for example to help reference to a matching record in an external system.
				ExternalData *GetWorkordersId_200_WorkOrder_ExternalData `json:"externalData"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Budget") (expand with query parameter)
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the work order
				Id int `json:"id"`

				// IsParent If this is a parent work order
				IsParent *bool `json:"isParent"`

				// Location Location linked to the element (expand with query parameter)
				Location *struct {
					// Address Postal address of the location
					Address *string `json:"address"`

					// CreatedAt Date & time at which the location was created
					CreatedAt   *time.Time `json:"createdAt,omitempty"`
					Description *string    `json:"description"`

					// Id Global ID of the location
					Id   int    `json:"id"`
					Name string `json:"name"`

					// ParentId ID of the parent location
					ParentId *int `json:"parentId"`

					// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
					UpdatedAt *time.Time `json:"updatedAt,omitempty"`
				} `json:"location"`

				// LocationId Global ID of the location assigned to the work order
				LocationId     *int    `json:"locationId"`
				NextId         *int    `json:"nextId"`
				OrganizationId float32 `json:"organizationId"`

				// ParentId The ID of the parent work order
				ParentId *int `json:"parentId"`

				// Parts Parts attached to the Work Order (expand with query parameter)
				Parts *[]struct {
					Area *string `json:"area"`

					// AvailableQuantity Quantity currently in stock
					AvailableQuantity int `json:"availableQuantity"`

					// Barcode String encoded barcode
					Barcode *string `json:"barcode"`

					// CopyOnRecurring Indicates if the parts will be copied to the next work order in the chain (if applicable).
					CopyOnRecurring GetWorkordersId200WorkOrderPartsCopyOnRecurring `json:"copyOnRecurring"`
					Description     *string                                         `json:"description"`
					ExtraFields     *map[string]string                              `json:"extraFields,omitempty"`

					// Id Global ID of the part
					Id int `json:"id"`

					// LocationId Global ID of the location of the part
					LocationId *float32 `json:"locationId"`

					// MinimumQuantity Minimum quantity before you should restock
					MinimumQuantity int    `json:"minimumQuantity"`
					Name            string `json:"name"`

					// QuantityUsed Quantity used in the work order.
					QuantityUsed int `json:"quantityUsed"`

					// UnitCost Cost in cents. For example, for $1.20, put 120.
					UnitCost *int `json:"unitCost"`
				} `json:"parts,omitempty"`
				PreviousId *int                                 `json:"previousId"`
				Priority   *GetWorkordersId200WorkOrderPriority `json:"priority,omitempty"`

				// Procedure Procedure attached to the work order
				Procedure *struct {
					Fields []struct {
						Assignees *struct {
							TeamIds *[]float32 `json:"teamIds,omitempty"`
							UserIds *[]float32 `json:"userIds,omitempty"`
						} `json:"assignees"`

						// Description Description of the procedure field
						Description *string `json:"description"`

						// Id ID of the procedure field
						Id float32 `json:"id"`

						// IsDateAndTime Indicate if a DATE field also contains the time
						IsDateAndTime *bool `json:"isDateAndTime"`

						// Label Label of a procedure field
						Label string `json:"label"`

						// MaxScore Maximum score of a procedure field
						MaxScore *float32 `json:"maxScore,omitempty"`

						// Meter Meter of a procedure field. Will be filled if the type of the field is meter
						Meter *struct {
							// Id Global ID of the meter.
							Id *float32 `json:"id,omitempty"`

							// Name Name of the meters
							Name *string `json:"name,omitempty"`
						} `json:"meter"`

						// ParentId ID of the parent of the current procedure field
						ParentId *float32 `json:"parentId"`

						// Required Indicate if field is required to be filled.
						Required bool `json:"required"`

						// Score Score of a procedure field
						Score *float32 `json:"score,omitempty"`

						// Type Type of procedure field
						Type GetWorkordersId200WorkOrderProcedureFieldsType `json:"type"`

						// Value Current value of a procedure field
						Value struct {
							// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
							Attachment *struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachment,omitempty"`
							Attachments *[]struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachments,omitempty"`
							HasAttachments *bool `json:"hasAttachments"`

							// Notes Note added to a procedure field
							Notes *struct {
								Text *string `json:"text,omitempty"`
							} `json:"notes"`
							Text *string `json:"text"`
						} `json:"value"`
					} `json:"fields"`

					// Id ID representing a procedure
					Id *float32 `json:"id,omitempty"`

					// MaxScore Maximum score of a procedure
					MaxScore *float32 `json:"maxScore,omitempty"`

					// Score Score of a procedure
					Score *float32 `json:"score,omitempty"`

					// TemplateIds IDs of the procedure template of the procedure
					TemplateIds *[]float32 `json:"templateIds"`

					// Title Title of the procedure
					Title string `json:"title"`
				} `json:"procedure"`

				// Progress Progress information on the work order
				Progress *struct {
					DoneCount       *float32 `json:"doneCount,omitempty"`
					InProgressCount *float32 `json:"inProgressCount,omitempty"`
					OnHoldCount     *float32 `json:"onHoldCount,omitempty"`
					OpenCount       *float32 `json:"openCount,omitempty"`
				} `json:"progress"`
				RecurrenceInfo *GetWorkordersId_200_WorkOrder_RecurrenceInfo `json:"recurrenceInfo"`

				// RequesterId ID of the user who requested the work order through the Work Request feature
				RequesterId *int `json:"requesterId"`

				// SequentialId Organization specific ID of the work order
				SequentialId int `json:"sequentialId"`

				// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
				StartDate *time.Time `json:"startDate"`

				// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
				Status GetWorkordersId200WorkOrderStatus `json:"status"`

				// TeamIds List of team ids assigned to the work order
				TeamIds   *[]int `json:"teamIds,omitempty"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`

				// TimeItems Time entries on the Work Order. (expand with query parameter)
				TimeItems *[]struct {
					// CostPerUnit Cost per part in cents or cents per hour
					CostPerUnit *float32 `json:"costPerUnit"`

					// Description Description of the expense or part description
					Description *string `json:"description"`

					// DurationTotal Total duration in seconds
					DurationTotal *float32 `json:"durationTotal,omitempty"`

					// PartId ID of the part used in this cost entry
					PartId *int `json:"partId"`

					// Quantity Number of parts or number of hours
					Quantity *float32 `json:"quantity,omitempty"`

					// RowTotal Total cost in cents
					RowTotal *float32 `json:"rowTotal,omitempty"`

					// Type Type of the entry
					Type *GetWorkordersId200WorkOrderTimeItemsType `json:"type,omitempty"`

					// UserId ID of the user who logged the time entry
					UserId *int `json:"userId"`
				} `json:"timeItems,omitempty"`

				// Times Time entries on the Work Order. Grouped by users (expand with query parameter)
				Times *[]struct {
					// CostPerUnit Cost per part in cents or cents per hour
					CostPerUnit *float32 `json:"costPerUnit"`

					// Description Description of the expense or part description
					Description *string `json:"description"`

					// DurationTotal Total duration in seconds
					DurationTotal *float32 `json:"durationTotal,omitempty"`

					// PartId ID of the part used in this cost entry
					PartId *int `json:"partId"`

					// Quantity Number of parts or number of hours
					Quantity *float32 `json:"quantity,omitempty"`

					// RowTotal Total cost in cents
					RowTotal *float32 `json:"rowTotal,omitempty"`

					// Type Type of the entry
					Type *GetWorkordersId200WorkOrderTimesType `json:"type,omitempty"`

					// UserId ID of the user who logged the time entry
					UserId *int `json:"userId"`
				} `json:"times,omitempty"`
				Title string `json:"title"`

				// Type Valid types of Work Orders, including options that are not available for creation/update. Historical Work Orders may have a null type.
				Type *GetWorkordersId200WorkOrderType `json:"type"`

				// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`

				// VendorIds Vendor IDs
				VendorIds *[]float32 `json:"vendorIds,omitempty"`
			} `json:"workOrder"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchWorkordersIdResponse parses an HTTP response from a PatchWorkordersIdWithResponse call
func ParsePatchWorkordersIdResponse(rsp *http.Response) (*PatchWorkordersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchWorkordersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			WorkOrder *struct {
				AssetId *int `json:"assetId"`

				// AssigneeIds List of user ids assigned to the work order
				AssigneeIds *[]int `json:"assigneeIds,omitempty"`

				// Attachments List of attachments linked to the work order
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// Categories List of categories that identify the work order
				Categories *[]string `json:"categories,omitempty"`

				// CompletedAt Date & time at which the work order was last marked as DONE
				CompletedAt *time.Time `json:"completedAt"`

				// CompleterId ID of the user who completed the work order
				CompleterId *int `json:"completerId"`

				// CreatedAt Date & time at which the work order was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId ID of the user who created the work order
				CreatorId *int `json:"creatorId"`

				// DeletedAt Date & time at which the work order was deleted
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// DueDate Date & time at which the work order is due
				DueDate          *time.Time `json:"dueDate"`
				DueDateIsFullDay *bool      `json:"dueDateIsFullDay"`

				// EstimatedTime The estimated time taken in seconds to complete the work order
				EstimatedTime *int `json:"estimatedTime"`

				// ExternalData Extra data that can be attached to the work order, for example to help reference to a matching record in an external system.
				ExternalData *PatchWorkordersId_200_WorkOrder_ExternalData `json:"externalData"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Time Allotted")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the work order
				Id int `json:"id"`

				// IsParent If this is a parent work order
				IsParent *bool `json:"isParent"`

				// LocationId Global ID of the location assigned to the work order
				LocationId     *int    `json:"locationId"`
				NextId         *int    `json:"nextId"`
				OrganizationId float32 `json:"organizationId"`

				// ParentId The ID of the parent work order
				ParentId   *int                                   `json:"parentId"`
				PreviousId *int                                   `json:"previousId"`
				Priority   *PatchWorkordersId200WorkOrderPriority `json:"priority,omitempty"`

				// Procedure Procedure attached to the work order
				Procedure *struct {
					Fields []struct {
						Assignees *struct {
							TeamIds *[]float32 `json:"teamIds,omitempty"`
							UserIds *[]float32 `json:"userIds,omitempty"`
						} `json:"assignees"`

						// Description Description of the procedure field
						Description *string `json:"description"`

						// Id ID of the procedure field
						Id float32 `json:"id"`

						// IsDateAndTime Indicate if a DATE field also contains the time
						IsDateAndTime *bool `json:"isDateAndTime"`

						// Label Label of a procedure field
						Label string `json:"label"`

						// MaxScore Maximum score of a procedure field
						MaxScore *float32 `json:"maxScore,omitempty"`

						// Meter Meter of a procedure field. Will be filled if the type of the field is meter
						Meter *struct {
							// Id Global ID of the meter.
							Id *float32 `json:"id,omitempty"`

							// Name Name of the meters
							Name *string `json:"name,omitempty"`
						} `json:"meter"`

						// ParentId ID of the parent of the current procedure field
						ParentId *float32 `json:"parentId"`

						// Required Indicate if field is required to be filled.
						Required bool `json:"required"`

						// Score Score of a procedure field
						Score *float32 `json:"score,omitempty"`

						// Type Type of procedure field
						Type PatchWorkordersId200WorkOrderProcedureFieldsType `json:"type"`

						// Value Current value of a procedure field
						Value struct {
							// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
							Attachment *struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachment,omitempty"`
							Attachments *[]struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachments,omitempty"`
							HasAttachments *bool `json:"hasAttachments"`

							// Notes Note added to a procedure field
							Notes *struct {
								Text *string `json:"text,omitempty"`
							} `json:"notes"`
							Text *string `json:"text"`
						} `json:"value"`
					} `json:"fields"`

					// Id ID representing a procedure
					Id *float32 `json:"id,omitempty"`

					// MaxScore Maximum score of a procedure
					MaxScore *float32 `json:"maxScore,omitempty"`

					// Score Score of a procedure
					Score *float32 `json:"score,omitempty"`

					// TemplateIds IDs of the procedure template of the procedure
					TemplateIds *[]float32 `json:"templateIds"`

					// Title Title of the procedure
					Title string `json:"title"`
				} `json:"procedure"`

				// Progress Progress information on the work order
				Progress *struct {
					DoneCount       *float32 `json:"doneCount,omitempty"`
					InProgressCount *float32 `json:"inProgressCount,omitempty"`
					OnHoldCount     *float32 `json:"onHoldCount,omitempty"`
					OpenCount       *float32 `json:"openCount,omitempty"`
				} `json:"progress"`
				RecurrenceInfo *PatchWorkordersId_200_WorkOrder_RecurrenceInfo `json:"recurrenceInfo"`

				// RequesterId ID of the user who requested the work order through the Work Request feature
				RequesterId *int `json:"requesterId"`

				// SequentialId Organization specific ID of the work order
				SequentialId int `json:"sequentialId"`

				// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
				StartDate *time.Time `json:"startDate"`

				// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
				Status PatchWorkordersId200WorkOrderStatus `json:"status"`

				// TeamIds List of team ids assigned to the work order
				TeamIds   *[]int `json:"teamIds,omitempty"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`
				Title string `json:"title"`

				// Type Valid types of Work Orders, including options that are not available for creation/update. Historical Work Orders may have a null type.
				Type *PatchWorkordersId200WorkOrderType `json:"type"`

				// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`

				// VendorIds Vendor IDs
				VendorIds *[]float32 `json:"vendorIds,omitempty"`
			} `json:"workOrder,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                   `json:"error"`
				FieldPath  *string                                  `json:"fieldPath"`
				FieldValue *PatchWorkordersId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteWorkordersIdAttachmentsFilenameResponse parses an HTTP response from a DeleteWorkordersIdAttachmentsFilenameWithResponse call
func ParseDeleteWorkordersIdAttachmentsFilenameResponse(rsp *http.Response) (*DeleteWorkordersIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkordersIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutWorkordersIdAttachmentsFilenameResponse parses an HTTP response from a PutWorkordersIdAttachmentsFilenameWithResponse call
func ParsePutWorkordersIdAttachmentsFilenameResponse(rsp *http.Response) (*PutWorkordersIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutWorkordersIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseGetWorkordersIdCommentsResponse parses an HTTP response from a GetWorkordersIdCommentsWithResponse call
func ParseGetWorkordersIdCommentsResponse(rsp *http.Response) (*GetWorkordersIdCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkordersIdCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Comments []struct {
				// AuthorId ID of the user who created the comment
				AuthorId float32 `json:"authorId"`

				// Content Content of the comment to post
				Content string `json:"content"`

				// CreatedAt Date & time at which the comment was created
				CreatedAt time.Time `json:"createdAt"`

				// Id Global ID of the comment
				Id float32 `json:"id"`
			} `json:"comments"`

			// NextCursor The cursor to retrieve the next page of Comments.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Comments.
			NextPageUrl *string `json:"nextPageUrl"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostWorkordersIdCommentsResponse parses an HTTP response from a PostWorkordersIdCommentsWithResponse call
func ParsePostWorkordersIdCommentsResponse(rsp *http.Response) (*PostWorkordersIdCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWorkordersIdCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the comment
			Id float32 `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                          `json:"error"`
				FieldPath  *string                                         `json:"fieldPath"`
				FieldValue *PostWorkordersIdComments_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetWorkordersIdCostsResponse parses an HTTP response from a GetWorkordersIdCostsWithResponse call
func ParseGetWorkordersIdCostsResponse(rsp *http.Response) (*GetWorkordersIdCostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkordersIdCostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Costs struct {
				Rows []struct {
					// CostPerUnit Cost per part in cents or cents per hour
					CostPerUnit *float32 `json:"costPerUnit"`

					// Description Description of the expense or part description
					Description *string `json:"description"`

					// DurationTotal Total duration in seconds
					DurationTotal *float32 `json:"durationTotal,omitempty"`

					// PartId ID of the part used in this cost entry
					PartId *int `json:"partId"`

					// Quantity Number of parts or number of hours
					Quantity *float32 `json:"quantity,omitempty"`

					// RowTotal Total cost in cents
					RowTotal *float32 `json:"rowTotal,omitempty"`

					// Type Type of the entry
					Type *GetWorkordersIdCosts200CostsRowsType `json:"type,omitempty"`

					// UserId ID of the user who logged the time entry
					UserId *int `json:"userId"`
				} `json:"rows"`

				// Total Total cost in cents of the Work order
				Total float32 `json:"total"`
			} `json:"costs"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostWorkordersIdCostsResponse parses an HTTP response from a PostWorkordersIdCostsWithResponse call
func ParsePostWorkordersIdCostsResponse(rsp *http.Response) (*PostWorkordersIdCostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWorkordersIdCostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CostPerUnit Cost per part in cents or cents per hour
			CostPerUnit *float32 `json:"costPerUnit"`

			// Description Description of the expense or part description
			Description *string `json:"description"`

			// DurationTotal Total duration in seconds
			DurationTotal *float32 `json:"durationTotal,omitempty"`

			// Id Created cost Id
			Id float32 `json:"id"`

			// PartId ID of the part used in this cost entry
			PartId *int `json:"partId"`

			// Quantity Number of parts or number of hours
			Quantity *float32 `json:"quantity,omitempty"`

			// RowTotal Total cost in cents
			RowTotal *float32 `json:"rowTotal,omitempty"`

			// Total Total cost in cents of the Work order
			Total float32 `json:"total"`

			// Type Type of the entry
			Type *PostWorkordersIdCosts201Type `json:"type,omitempty"`

			// UserId ID of the user who logged the time entry
			UserId *int `json:"userId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                       `json:"error"`
				FieldPath  *string                                      `json:"fieldPath"`
				FieldValue *PostWorkordersIdCosts_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostWorkordersIdEmailsResponse parses an HTTP response from a PostWorkordersIdEmailsWithResponse call
func ParsePostWorkordersIdEmailsResponse(rsp *http.Response) (*PostWorkordersIdEmailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWorkordersIdEmailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the work order
			Id *int `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                        `json:"error"`
				FieldPath  *string                                       `json:"fieldPath"`
				FieldValue *PostWorkordersIdEmails_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                        `json:"error"`
				FieldPath  *string                                       `json:"fieldPath"`
				FieldValue *PostWorkordersIdEmails_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteWorkordersIdProcedureResponse parses an HTTP response from a DeleteWorkordersIdProcedureWithResponse call
func ParseDeleteWorkordersIdProcedureResponse(rsp *http.Response) (*DeleteWorkordersIdProcedureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkordersIdProcedureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                             `json:"error"`
				FieldPath  *string                                            `json:"fieldPath"`
				FieldValue *DeleteWorkordersIdProcedure_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteWorkordersIdProcedureFieldsIndexAttachmentResponse parses an HTTP response from a DeleteWorkordersIdProcedureFieldsIndexAttachmentWithResponse call
func ParseDeleteWorkordersIdProcedureFieldsIndexAttachmentResponse(rsp *http.Response) (*DeleteWorkordersIdProcedureFieldsIndexAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkordersIdProcedureFieldsIndexAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutWorkordersIdProcedureFieldsIndexAttachmentFilenameResponse parses an HTTP response from a PutWorkordersIdProcedureFieldsIndexAttachmentFilenameWithResponse call
func ParsePutWorkordersIdProcedureFieldsIndexAttachmentFilenameResponse(rsp *http.Response) (*PutWorkordersIdProcedureFieldsIndexAttachmentFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutWorkordersIdProcedureFieldsIndexAttachmentFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParsePatchWorkordersIdStatusResponse parses an HTTP response from a PatchWorkordersIdStatusWithResponse call
func ParsePatchWorkordersIdStatusResponse(rsp *http.Response) (*PatchWorkordersIdStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchWorkordersIdStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			WorkOrder *struct {
				AssetId *int `json:"assetId"`

				// AssigneeIds List of user ids assigned to the work order
				AssigneeIds *[]int `json:"assigneeIds,omitempty"`

				// Attachments List of attachments linked to the work order
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// Categories List of categories that identify the work order
				Categories *[]string `json:"categories,omitempty"`

				// CompletedAt Date & time at which the work order was last marked as DONE
				CompletedAt *time.Time `json:"completedAt"`

				// CompleterId ID of the user who completed the work order
				CompleterId *int `json:"completerId"`

				// CreatedAt Date & time at which the work order was created
				CreatedAt time.Time `json:"createdAt"`

				// CreatorId ID of the user who created the work order
				CreatorId *int `json:"creatorId"`

				// DeletedAt Date & time at which the work order was deleted
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// DueDate Date & time at which the work order is due
				DueDate          *time.Time `json:"dueDate"`
				DueDateIsFullDay *bool      `json:"dueDateIsFullDay"`

				// ExternalData Extra data that can be attached to the work order, for example to help reference to a matching record in an external system.
				ExternalData *PatchWorkordersIdStatus_200_WorkOrder_ExternalData `json:"externalData"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Time Allotted")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the work order
				Id int `json:"id"`

				// LocationId Global ID of the location assigned to the work order
				LocationId     *int                                         `json:"locationId"`
				NextId         *int                                         `json:"nextId"`
				OrganizationId float32                                      `json:"organizationId"`
				PreviousId     *int                                         `json:"previousId"`
				Priority       *PatchWorkordersIdStatus200WorkOrderPriority `json:"priority,omitempty"`

				// Procedure Procedure attached to the work order
				Procedure *struct {
					Fields []struct {
						Assignees *struct {
							TeamIds *[]float32 `json:"teamIds,omitempty"`
							UserIds *[]float32 `json:"userIds,omitempty"`
						} `json:"assignees"`

						// Description Description of the procedure field
						Description *string `json:"description"`

						// Id ID of the procedure field
						Id float32 `json:"id"`

						// IsDateAndTime Indicate if a DATE field also contains the time
						IsDateAndTime *bool `json:"isDateAndTime"`

						// Label Label of a procedure field
						Label string `json:"label"`

						// MaxScore Maximum score of a procedure field
						MaxScore *float32 `json:"maxScore,omitempty"`

						// Meter Meter of a procedure field. Will be filled if the type of the field is meter
						Meter *struct {
							// Id Global ID of the meter.
							Id *float32 `json:"id,omitempty"`

							// Name Name of the meters
							Name *string `json:"name,omitempty"`
						} `json:"meter"`

						// ParentId ID of the parent of the current procedure field
						ParentId *float32 `json:"parentId"`

						// Required Indicate if field is required to be filled.
						Required bool `json:"required"`

						// Score Score of a procedure field
						Score *float32 `json:"score,omitempty"`

						// Type Type of procedure field
						Type PatchWorkordersIdStatus200WorkOrderProcedureFieldsType `json:"type"`

						// Value Current value of a procedure field
						Value struct {
							// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
							Attachment *struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachment,omitempty"`
							Attachments *[]struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachments,omitempty"`
							HasAttachments *bool `json:"hasAttachments"`

							// Notes Note added to a procedure field
							Notes *struct {
								Text *string `json:"text,omitempty"`
							} `json:"notes"`
							Text *string `json:"text"`
						} `json:"value"`
					} `json:"fields"`

					// Id ID representing a procedure
					Id *float32 `json:"id,omitempty"`

					// MaxScore Maximum score of a procedure
					MaxScore *float32 `json:"maxScore,omitempty"`

					// Score Score of a procedure
					Score *float32 `json:"score,omitempty"`

					// TemplateIds IDs of the procedure template of the procedure
					TemplateIds *[]float32 `json:"templateIds"`

					// Title Title of the procedure
					Title string `json:"title"`
				} `json:"procedure"`

				// Progress Progress information on the work order
				Progress *struct {
					DoneCount       *float32 `json:"doneCount,omitempty"`
					InProgressCount *float32 `json:"inProgressCount,omitempty"`
					OnHoldCount     *float32 `json:"onHoldCount,omitempty"`
					OpenCount       *float32 `json:"openCount,omitempty"`
				} `json:"progress"`
				RecurrenceInfo *PatchWorkordersIdStatus_200_WorkOrder_RecurrenceInfo `json:"recurrenceInfo"`

				// RequesterId ID of the user who requested the work order through the Work Request feature
				RequesterId *int `json:"requesterId"`

				// SequentialId Organization specific ID of the work order
				SequentialId int `json:"sequentialId"`

				// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
				StartDate *time.Time `json:"startDate"`

				// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
				Status PatchWorkordersIdStatus200WorkOrderStatus `json:"status"`

				// TeamIds List of team ids assigned to the work order
				TeamIds   *[]int `json:"teamIds,omitempty"`
				Thumbnail *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`
				Title string `json:"title"`

				// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`

				// VendorIds Vendor IDs
				VendorIds *[]float32 `json:"vendorIds,omitempty"`
			} `json:"workOrder,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                         `json:"error"`
				FieldPath  *string                                        `json:"fieldPath"`
				FieldValue *PatchWorkordersIdStatus_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetWorkordersIdSubworkordersResponse parses an HTTP response from a GetWorkordersIdSubworkordersWithResponse call
func ParseGetWorkordersIdSubworkordersResponse(rsp *http.Response) (*GetWorkordersIdSubworkordersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkordersIdSubworkordersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor The cursor to retrieve the next page of Subworkorders.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Subworkorders.
			NextPageUrl   *string `json:"nextPageUrl"`
			Subworkorders []struct {
				// Asset Asset linked to the element (expand with query parameter)
				Asset *struct {
					// CreatedAt Date & time at which the asset was created
					CreatedAt time.Time `json:"createdAt"`

					// CreatorId ID of the asset creator
					CreatorId *int `json:"creatorId"`

					// CriticalityId ID of the criticality of the asset
					CriticalityId *int    `json:"criticalityId"`
					Description   *string `json:"description"`

					// Id Global ID of the asset
					Id int `json:"id"`

					// LocationId ID of the location where the asset is located
					LocationId *int   `json:"locationId"`
					Name       string `json:"name"`

					// ParentId ID of the parent asset
					ParentId *int `json:"parentId"`

					// SerialNumber Serial number of the asset
					SerialNumber *string `json:"serialNumber"`

					// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"asset"`
				AssetId *int `json:"assetId"`

				// Assignees Either the teamId, the userId or the user email address (expand with query parameter)
				Assignees *[]struct {
					Id   GetWorkordersIdSubworkorders_200_Subworkorders_Assignees_Id `json:"id"`
					Type GetWorkordersIdSubworkorders200SubworkordersAssigneesType   `json:"type"`
				} `json:"assignees,omitempty"`

				// Categories List of categories that identify the work order (expand with query parameter)
				Categories *[]string `json:"categories,omitempty"`

				// CompletedAt Date & time at which the work order was last marked as DONE
				CompletedAt *time.Time `json:"completedAt"`

				// CompleterId ID of the user who completed the work order
				CompleterId *int `json:"completerId"`

				// CreatedAt Date & time at which the work order was created
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// CreatorId ID of the user who created the work order
				CreatorId *int `json:"creatorId"`

				// DeletedAt Date & time at which the work order was deleted
				DeletedAt   *time.Time `json:"deletedAt"`
				Description *string    `json:"description"`

				// DueDate Date & time at which the work order is due
				DueDate *time.Time `json:"dueDate"`

				// EstimatedTime The estimated time taken in seconds to complete the work order (expand with query parameter)
				EstimatedTime *int `json:"estimatedTime"`

				// Expenditures Other cost entries on the Work Order. Grouped by users (expand with query parameter)
				Expenditures *[]struct {
					// CostPerUnit Cost per part in cents or cents per hour
					CostPerUnit *float32 `json:"costPerUnit"`

					// Description Description of the expense or part description
					Description *string `json:"description"`

					// DurationTotal Total duration in seconds
					DurationTotal *float32 `json:"durationTotal,omitempty"`

					// PartId ID of the part used in this cost entry
					PartId *int `json:"partId"`

					// Quantity Number of parts or number of hours
					Quantity *float32 `json:"quantity,omitempty"`

					// RowTotal Total cost in cents
					RowTotal *float32 `json:"rowTotal,omitempty"`

					// Type Type of the entry
					Type *GetWorkordersIdSubworkorders200SubworkordersExpendituresType `json:"type,omitempty"`

					// UserId ID of the user who logged the time entry
					UserId *int `json:"userId"`
				} `json:"expenditures,omitempty"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Budget") (expand with query parameter)
				ExtraFields *map[string]string `json:"extraFields"`

				// Id Global ID of the work order
				Id int `json:"id"`

				// Location Location linked to the element (expand with query parameter)
				Location *struct {
					// Address Postal address of the location
					Address *string `json:"address"`

					// CreatedAt Date & time at which the location was created
					CreatedAt   *time.Time `json:"createdAt,omitempty"`
					Description *string    `json:"description"`

					// Id Global ID of the location
					Id   int    `json:"id"`
					Name string `json:"name"`

					// ParentId ID of the parent location
					ParentId *int `json:"parentId"`

					// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
					UpdatedAt *time.Time `json:"updatedAt,omitempty"`
				} `json:"location"`

				// LocationId Global ID of the location assigned to the work order
				LocationId     *int     `json:"locationId"`
				NextId         *int     `json:"nextId"`
				OrganizationId *float32 `json:"organizationId,omitempty"`

				// Parts Parts attached to the Work Order (expand with query parameter)
				Parts *[]struct {
					Area *string `json:"area"`

					// AvailableQuantity Quantity currently in stock
					AvailableQuantity int `json:"availableQuantity"`

					// Barcode String encoded barcode
					Barcode *string `json:"barcode"`

					// CopyOnRecurring Indicates if the parts will be copied to the next work order in the chain (if applicable).
					CopyOnRecurring GetWorkordersIdSubworkorders200SubworkordersPartsCopyOnRecurring `json:"copyOnRecurring"`
					Description     *string                                                          `json:"description"`
					ExtraFields     *map[string]string                                               `json:"extraFields,omitempty"`

					// Id Global ID of the part
					Id int `json:"id"`

					// LocationId Global ID of the location of the part
					LocationId *float32 `json:"locationId"`

					// MinimumQuantity Minimum quantity before you should restock
					MinimumQuantity int    `json:"minimumQuantity"`
					Name            string `json:"name"`

					// QuantityUsed Quantity used in the work order.
					QuantityUsed int `json:"quantityUsed"`

					// UnitCost Cost in cents. For example, for $1.20, put 120.
					UnitCost *int `json:"unitCost"`
				} `json:"parts,omitempty"`
				PreviousId *int                                                  `json:"previousId"`
				Priority   *GetWorkordersIdSubworkorders200SubworkordersPriority `json:"priority,omitempty"`

				// Procedure Procedure attached to the work order (expand with query parameter)
				Procedure *struct {
					Fields []struct {
						Assignees *struct {
							TeamIds *[]float32 `json:"teamIds,omitempty"`
							UserIds *[]float32 `json:"userIds,omitempty"`
						} `json:"assignees"`

						// Description Description of the procedure field
						Description *string `json:"description"`

						// Id ID of the procedure field
						Id float32 `json:"id"`

						// IsDateAndTime Indicate if a DATE field also contains the time
						IsDateAndTime *bool `json:"isDateAndTime"`

						// Label Label of a procedure field
						Label string `json:"label"`

						// MaxScore Maximum score of a procedure field
						MaxScore *float32 `json:"maxScore,omitempty"`

						// Meter Meter of a procedure field. Will be filled if the type of the field is meter
						Meter *struct {
							// Id Global ID of the meter.
							Id *float32 `json:"id,omitempty"`

							// Name Name of the meters
							Name *string `json:"name,omitempty"`
						} `json:"meter"`

						// ParentId ID of the parent of the current procedure field
						ParentId *float32 `json:"parentId"`

						// Required Indicate if field is required to be filled.
						Required bool `json:"required"`

						// Score Score of a procedure field
						Score *float32 `json:"score,omitempty"`

						// Type Type of procedure field
						Type GetWorkordersIdSubworkorders200SubworkordersProcedureFieldsType `json:"type"`

						// Value Current value of a procedure field
						Value struct {
							// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
							Attachment *struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachment,omitempty"`
							Attachments *[]struct {
								// CreatedAt Date & time at which the attachment was uploaded
								CreatedAt time.Time `json:"createdAt"`

								// FileName Attachment's file name
								FileName string `json:"fileName"`

								// Height Height if the file is an image
								Height *float32 `json:"height"`

								// Id Global ID of the attachment
								Id float32 `json:"id"`

								// MimeType MIME type of the file
								MimeType string `json:"mimeType"`

								// Url Url of the file
								Url string `json:"url"`

								// Width Width if the file is an image
								Width *float32 `json:"width"`
							} `json:"attachments,omitempty"`
							HasAttachments *bool `json:"hasAttachments"`

							// Notes Note added to a procedure field
							Notes *struct {
								Text *string `json:"text,omitempty"`
							} `json:"notes"`
							Text *string `json:"text"`
						} `json:"value"`
					} `json:"fields"`

					// Id ID representing a procedure
					Id *float32 `json:"id,omitempty"`

					// MaxScore Maximum score of a procedure
					MaxScore *float32 `json:"maxScore,omitempty"`

					// Score Score of a procedure
					Score *float32 `json:"score,omitempty"`

					// TemplateIds IDs of the procedure template of the procedure
					TemplateIds *[]float32 `json:"templateIds"`

					// Title Title of the procedure
					Title string `json:"title"`
				} `json:"procedure"`

				// RequesterId ID of the user who requested the work order through the Work Request feature
				RequesterId *int `json:"requesterId"`

				// SequentialId Organization specific ID of the work order
				SequentialId int `json:"sequentialId"`

				// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
				StartDate *time.Time `json:"startDate"`

				// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
				Status GetWorkordersIdSubworkorders200SubworkordersStatus `json:"status"`

				// TimeItems Time entries on the Work Order. (expand with query parameter)
				TimeItems *[]struct {
					// CostPerUnit Cost per part in cents or cents per hour
					CostPerUnit *float32 `json:"costPerUnit"`

					// Description Description of the expense or part description
					Description *string `json:"description"`

					// DurationTotal Total duration in seconds
					DurationTotal *float32 `json:"durationTotal,omitempty"`

					// PartId ID of the part used in this cost entry
					PartId *int `json:"partId"`

					// Quantity Number of parts or number of hours
					Quantity *float32 `json:"quantity,omitempty"`

					// RowTotal Total cost in cents
					RowTotal *float32 `json:"rowTotal,omitempty"`

					// Type Type of the entry
					Type *GetWorkordersIdSubworkorders200SubworkordersTimeItemsType `json:"type,omitempty"`

					// UserId ID of the user who logged the time entry
					UserId *int `json:"userId"`
				} `json:"timeItems,omitempty"`

				// Times Time entries on the Work Order. Grouped by users (expand with query parameter)
				Times *[]struct {
					// CostPerUnit Cost per part in cents or cents per hour
					CostPerUnit *float32 `json:"costPerUnit"`

					// Description Description of the expense or part description
					Description *string `json:"description"`

					// DurationTotal Total duration in seconds
					DurationTotal *float32 `json:"durationTotal,omitempty"`

					// PartId ID of the part used in this cost entry
					PartId *int `json:"partId"`

					// Quantity Number of parts or number of hours
					Quantity *float32 `json:"quantity,omitempty"`

					// RowTotal Total cost in cents
					RowTotal *float32 `json:"rowTotal,omitempty"`

					// Type Type of the entry
					Type *GetWorkordersIdSubworkorders200SubworkordersTimesType `json:"type,omitempty"`

					// UserId ID of the user who logged the time entry
					UserId *int `json:"userId"`
				} `json:"times,omitempty"`
				Title string `json:"title"`

				// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
				UpdatedAt time.Time `json:"updatedAt"`
			} `json:"subworkorders"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutWorkordersIdThumbnailFilenameResponse parses an HTTP response from a PutWorkordersIdThumbnailFilenameWithResponse call
func ParsePutWorkordersIdThumbnailFilenameResponse(rsp *http.Response) (*PutWorkordersIdThumbnailFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutWorkordersIdThumbnailFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                                  `json:"error"`
				FieldPath  *string                                                 `json:"fieldPath"`
				FieldValue *PutWorkordersIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseGetWorkrequestportalsResponse parses an HTTP response from a GetWorkrequestportalsWithResponse call
func ParseGetWorkrequestportalsResponse(rsp *http.Response) (*GetWorkrequestportalsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkrequestportalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor The cursor to retrieve the next page of Work Request Portals.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Work Request Portals.
			NextPageUrl        *string `json:"nextPageUrl"`
			WorkRequestPortals []struct {
				// AssetId ID of the asset related to the portal
				AssetId *int `json:"assetId"`

				// ContactInformation Contact of the person creating the portal (email or phone number)
				ContactInformation *string `json:"contactInformation"`

				// DescriptionPlaceholder Placeholder text for the description field
				DescriptionPlaceholder *string `json:"descriptionPlaceholder"`

				// EmailOnly Allow request creation with email only to contact the requester
				EmailOnly *bool `json:"emailOnly"`

				// Id Global ID of the portal
				Id int `json:"id"`

				// LocationId ID of the location where the portal is located
				LocationId *int `json:"locationId"`

				// PortalUrl Url to access the portal
				PortalUrl string `json:"portalUrl"`

				// SendEmailNotification Send email notifications to the portal requesters with status updates on their requests
				SendEmailNotification *bool `json:"sendEmailNotification"`

				// Title Title of the portal
				Title string `json:"title"`

				// WelcomeText Description text describing the portal
				WelcomeText *string `json:"welcomeText"`
			} `json:"workRequestPortals"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostWorkrequestportalsResponse parses an HTTP response from a PostWorkrequestportalsWithResponse call
func ParsePostWorkrequestportalsResponse(rsp *http.Response) (*PostWorkrequestportalsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWorkrequestportalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id Global ID of the portal
			Id int `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                        `json:"error"`
				FieldPath  *string                                       `json:"fieldPath"`
				FieldValue *PostWorkrequestportals_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				Error      string                                        `json:"error"`
				FieldPath  *string                                       `json:"fieldPath"`
				FieldValue *PostWorkrequestportals_403_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteWorkrequestportalsIdResponse parses an HTTP response from a DeleteWorkrequestportalsIdWithResponse call
func ParseDeleteWorkrequestportalsIdResponse(rsp *http.Response) (*DeleteWorkrequestportalsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkrequestportalsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                            `json:"error"`
				FieldPath  *string                                           `json:"fieldPath"`
				FieldValue *DeleteWorkrequestportalsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetWorkrequestportalsIdResponse parses an HTTP response from a GetWorkrequestportalsIdWithResponse call
func ParseGetWorkrequestportalsIdResponse(rsp *http.Response) (*GetWorkrequestportalsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkrequestportalsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			WorkRequestPortal struct {
				// AssetId ID of the asset related to the portal
				AssetId *int `json:"assetId"`

				// ContactInformation Contact of the person creating the portal (email or phone number)
				ContactInformation *string `json:"contactInformation"`

				// DescriptionPlaceholder Placeholder text for the description field
				DescriptionPlaceholder *string `json:"descriptionPlaceholder"`

				// EmailOnly Allow request creation with email only to contact the requester
				EmailOnly *bool `json:"emailOnly"`

				// Id Global ID of the portal
				Id int `json:"id"`

				// LocationId ID of the location where the portal is located
				LocationId *int `json:"locationId"`

				// PortalUrl Url to access the portal
				PortalUrl *string `json:"portalUrl,omitempty"`

				// SendEmailNotification Send email notifications to the portal requesters with status updates on their requests
				SendEmailNotification *bool `json:"sendEmailNotification"`

				// Title Title of the portal
				Title *string `json:"title,omitempty"`

				// WelcomeText Description text describing the portal
				WelcomeText *string `json:"welcomeText"`
			} `json:"workRequestPortal"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchWorkrequestportalsIdResponse parses an HTTP response from a PatchWorkrequestportalsIdWithResponse call
func ParsePatchWorkrequestportalsIdResponse(rsp *http.Response) (*PatchWorkrequestportalsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchWorkrequestportalsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			WorkRequestPortal struct {
				// AssetId ID of the asset related to the portal
				AssetId *int `json:"assetId"`

				// ContactInformation Contact of the person creating the portal (email or phone number)
				ContactInformation *string `json:"contactInformation"`

				// DescriptionPlaceholder Placeholder text for the description field
				DescriptionPlaceholder *string `json:"descriptionPlaceholder"`

				// EmailOnly Allow request creation with email only to contact the requester
				EmailOnly *bool `json:"emailOnly"`

				// Id Global ID of the portal
				Id int `json:"id"`

				// LocationId ID of the location where the portal is located
				LocationId *int `json:"locationId"`

				// PortalUrl Url to access the portal
				PortalUrl *string `json:"portalUrl,omitempty"`

				// SendEmailNotification Send email notifications to the portal requesters with status updates on their requests
				SendEmailNotification *bool `json:"sendEmailNotification"`

				// Title Title of the portal
				Title string `json:"title"`

				// WelcomeText Description text describing the portal
				WelcomeText *string `json:"welcomeText"`
			} `json:"workRequestPortal"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                           `json:"error"`
				FieldPath  *string                                          `json:"fieldPath"`
				FieldValue *PatchWorkrequestportalsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetWorkrequestsResponse parses an HTTP response from a GetWorkrequestsWithResponse call
func ParseGetWorkrequestsResponse(rsp *http.Response) (*GetWorkrequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkrequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextCursor The cursor to retrieve the next page of Work Requests.
			NextCursor *string `json:"nextCursor"`

			// NextPageUrl Path with query parameters that can be used to retrieve the next page of Work Requests.
			NextPageUrl  *string `json:"nextPageUrl"`
			WorkRequests []struct {
				// ApproverTeamId ID of the team that is reponsible for approving the request.
				ApproverTeamId *float32 `json:"approverTeamId"`

				// Asset Asset linked to the element (expand with query parameter)
				Asset *struct {
					// CreatedAt Date & time at which the asset was created
					CreatedAt time.Time `json:"createdAt"`

					// CreatorId ID of the asset creator
					CreatorId *int `json:"creatorId"`

					// CriticalityId ID of the criticality of the asset
					CriticalityId *int    `json:"criticalityId"`
					Description   *string `json:"description"`

					// Id Global ID of the asset
					Id int `json:"id"`

					// LocationId ID of the location where the asset is located
					LocationId *int   `json:"locationId"`
					Name       string `json:"name"`

					// ParentId ID of the parent asset
					ParentId *int `json:"parentId"`

					// SerialNumber Serial number of the asset
					SerialNumber *string `json:"serialNumber"`

					// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"asset,omitempty"`
				AssetId *float32 `json:"assetId"`

				// Attachments List of attachments linked to the Work Request
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// CreatedAt Date & time at which the work request was created
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// CreatorContactInfo The creator's contact information associated with this work order request
				CreatorContactInfo *struct {
					Type  *GetWorkrequests200WorkRequestsCreatorContactInfoType `json:"type,omitempty"`
					Value *string                                               `json:"value,omitempty"`
				} `json:"creatorContactInfo"`
				Description *string `json:"description"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Request Type") (expand with query parameter)
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the work request
				Id float32 `json:"id"`

				// Location Location linked to the element (expand with query parameter)
				Location *struct {
					// Address Postal address of the location
					Address *string `json:"address"`

					// CreatedAt Date & time at which the location was created
					CreatedAt   *time.Time `json:"createdAt,omitempty"`
					Description *string    `json:"description"`

					// Id Global ID of the location
					Id   int    `json:"id"`
					Name string `json:"name"`

					// ParentId ID of the parent location
					ParentId *int `json:"parentId"`

					// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
					UpdatedAt *time.Time `json:"updatedAt,omitempty"`
				} `json:"location,omitempty"`
				LocationId            *float32                                    `json:"locationId"`
				Priority              GetWorkrequests200WorkRequestsPriority      `json:"priority"`
				RequestStatus         GetWorkrequests200WorkRequestsRequestStatus `json:"requestStatus"`
				SendEmailNotification *bool                                       `json:"sendEmailNotification,omitempty"`
				Thumbnail             *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`
				Title string `json:"title"`

				// UpdatedAt Date & time at which the work request was last updated
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`

				// WorkOrder Work Order linked to the element (expand with query parameter)
				WorkOrder *struct {
					AssetId *int `json:"assetId"`

					// AssigneeIds List of user ids assigned to the work order
					AssigneeIds *[]int `json:"assigneeIds,omitempty"`

					// Attachments List of attachments linked to the work order
					Attachments *[]struct {
						// CreatedAt Date & time at which the attachment was uploaded
						CreatedAt time.Time `json:"createdAt"`

						// FileName Attachment's file name
						FileName string `json:"fileName"`

						// Height Height if the file is an image
						Height *float32 `json:"height"`

						// Id Global ID of the attachment
						Id float32 `json:"id"`

						// MimeType MIME type of the file
						MimeType string `json:"mimeType"`

						// Url Url of the file
						Url string `json:"url"`

						// Width Width if the file is an image
						Width *float32 `json:"width"`
					} `json:"attachments,omitempty"`

					// Categories List of categories that identify the work order
					Categories *[]string `json:"categories,omitempty"`

					// CompletedAt Date & time at which the work order was last marked as DONE
					CompletedAt *time.Time `json:"completedAt"`

					// CompleterId ID of the user who completed the work order
					CompleterId *int `json:"completerId"`

					// CreatedAt Date & time at which the work order was created
					CreatedAt time.Time `json:"createdAt"`

					// CreatorId ID of the user who created the work order
					CreatorId *int `json:"creatorId"`

					// DeletedAt Date & time at which the work order was deleted
					DeletedAt   *time.Time `json:"deletedAt"`
					Description *string    `json:"description"`

					// DueDate Date & time at which the work order is due
					DueDate          *time.Time `json:"dueDate"`
					DueDateIsFullDay *bool      `json:"dueDateIsFullDay"`

					// EstimatedTime The estimated time taken in seconds to complete the work order
					EstimatedTime *int `json:"estimatedTime"`

					// ExternalData Extra data that can be attached to the work order, for example to help reference to a matching record in an external system.
					ExternalData *GetWorkrequests_200_WorkRequests_WorkOrder_ExternalData `json:"externalData"`

					// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Time Allotted")
					ExtraFields *map[string]string `json:"extraFields,omitempty"`

					// Id Global ID of the work order
					Id int `json:"id"`

					// IsParent If this is a parent work order
					IsParent *bool `json:"isParent"`

					// LocationId Global ID of the location assigned to the work order
					LocationId     *int    `json:"locationId"`
					NextId         *int    `json:"nextId"`
					OrganizationId float32 `json:"organizationId"`

					// ParentId The ID of the parent work order
					ParentId   *int                                             `json:"parentId"`
					PreviousId *int                                             `json:"previousId"`
					Priority   *GetWorkrequests200WorkRequestsWorkOrderPriority `json:"priority,omitempty"`

					// Procedure Procedure attached to the work order
					Procedure *struct {
						Fields []struct {
							Assignees *struct {
								TeamIds *[]float32 `json:"teamIds,omitempty"`
								UserIds *[]float32 `json:"userIds,omitempty"`
							} `json:"assignees"`

							// Description Description of the procedure field
							Description *string `json:"description"`

							// Id ID of the procedure field
							Id float32 `json:"id"`

							// IsDateAndTime Indicate if a DATE field also contains the time
							IsDateAndTime *bool `json:"isDateAndTime"`

							// Label Label of a procedure field
							Label string `json:"label"`

							// MaxScore Maximum score of a procedure field
							MaxScore *float32 `json:"maxScore,omitempty"`

							// Meter Meter of a procedure field. Will be filled if the type of the field is meter
							Meter *struct {
								// Id Global ID of the meter.
								Id *float32 `json:"id,omitempty"`

								// Name Name of the meters
								Name *string `json:"name,omitempty"`
							} `json:"meter"`

							// ParentId ID of the parent of the current procedure field
							ParentId *float32 `json:"parentId"`

							// Required Indicate if field is required to be filled.
							Required bool `json:"required"`

							// Score Score of a procedure field
							Score *float32 `json:"score,omitempty"`

							// Type Type of procedure field
							Type GetWorkrequests200WorkRequestsWorkOrderProcedureFieldsType `json:"type"`

							// Value Current value of a procedure field
							Value struct {
								// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
								Attachment *struct {
									// CreatedAt Date & time at which the attachment was uploaded
									CreatedAt time.Time `json:"createdAt"`

									// FileName Attachment's file name
									FileName string `json:"fileName"`

									// Height Height if the file is an image
									Height *float32 `json:"height"`

									// Id Global ID of the attachment
									Id float32 `json:"id"`

									// MimeType MIME type of the file
									MimeType string `json:"mimeType"`

									// Url Url of the file
									Url string `json:"url"`

									// Width Width if the file is an image
									Width *float32 `json:"width"`
								} `json:"attachment,omitempty"`
								Attachments *[]struct {
									// CreatedAt Date & time at which the attachment was uploaded
									CreatedAt time.Time `json:"createdAt"`

									// FileName Attachment's file name
									FileName string `json:"fileName"`

									// Height Height if the file is an image
									Height *float32 `json:"height"`

									// Id Global ID of the attachment
									Id float32 `json:"id"`

									// MimeType MIME type of the file
									MimeType string `json:"mimeType"`

									// Url Url of the file
									Url string `json:"url"`

									// Width Width if the file is an image
									Width *float32 `json:"width"`
								} `json:"attachments,omitempty"`
								HasAttachments *bool `json:"hasAttachments"`

								// Notes Note added to a procedure field
								Notes *struct {
									Text *string `json:"text,omitempty"`
								} `json:"notes"`
								Text *string `json:"text"`
							} `json:"value"`
						} `json:"fields"`

						// Id ID representing a procedure
						Id *float32 `json:"id,omitempty"`

						// MaxScore Maximum score of a procedure
						MaxScore *float32 `json:"maxScore,omitempty"`

						// Score Score of a procedure
						Score *float32 `json:"score,omitempty"`

						// TemplateIds IDs of the procedure template of the procedure
						TemplateIds *[]float32 `json:"templateIds"`

						// Title Title of the procedure
						Title string `json:"title"`
					} `json:"procedure"`

					// Progress Progress information on the work order
					Progress *struct {
						DoneCount       *float32 `json:"doneCount,omitempty"`
						InProgressCount *float32 `json:"inProgressCount,omitempty"`
						OnHoldCount     *float32 `json:"onHoldCount,omitempty"`
						OpenCount       *float32 `json:"openCount,omitempty"`
					} `json:"progress"`
					RecurrenceInfo *GetWorkrequests_200_WorkRequests_WorkOrder_RecurrenceInfo `json:"recurrenceInfo"`

					// RequesterId ID of the user who requested the work order through the Work Request feature
					RequesterId *int `json:"requesterId"`

					// SequentialId Organization specific ID of the work order
					SequentialId int `json:"sequentialId"`

					// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
					StartDate *time.Time `json:"startDate"`

					// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
					Status GetWorkrequests200WorkRequestsWorkOrderStatus `json:"status"`

					// TeamIds List of team ids assigned to the work order
					TeamIds   *[]int `json:"teamIds,omitempty"`
					Thumbnail *struct {
						// CreatedAt Date & time at which the attachment was uploaded
						CreatedAt time.Time `json:"createdAt"`

						// FileName Attachment's file name
						FileName string `json:"fileName"`

						// Height Height if the file is an image
						Height *float32 `json:"height"`

						// Id Global ID of the attachment
						Id float32 `json:"id"`

						// MimeType MIME type of the file
						MimeType string `json:"mimeType"`

						// Url Url of the file
						Url string `json:"url"`

						// Width Width if the file is an image
						Width *float32 `json:"width"`
					} `json:"thumbnail"`
					Title string `json:"title"`

					// Type Valid types of Work Orders, including options that are not available for creation/update. Historical Work Orders may have a null type.
					Type *GetWorkrequests200WorkRequestsWorkOrderType `json:"type"`

					// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
					UpdatedAt time.Time `json:"updatedAt"`

					// VendorIds Vendor IDs
					VendorIds *[]float32 `json:"vendorIds,omitempty"`
				} `json:"workOrder,omitempty"`

				// WorkOrderId Global ID of the work order attached to the work request. A work order is created once a work request is approved.
				WorkOrderId *float32 `json:"workOrderId"`
			} `json:"workRequests"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostWorkrequestsResponse parses an HTTP response from a PostWorkrequestsWithResponse call
func ParsePostWorkrequestsResponse(rsp *http.Response) (*PostWorkrequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWorkrequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id Global ID of the work request
			Id float32 `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                  `json:"error"`
				FieldPath  *string                                 `json:"fieldPath"`
				FieldValue *PostWorkrequests_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteWorkrequestsIdResponse parses an HTTP response from a DeleteWorkrequestsIdWithResponse call
func ParseDeleteWorkrequestsIdResponse(rsp *http.Response) (*DeleteWorkrequestsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkrequestsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                      `json:"error"`
				FieldPath  *string                                     `json:"fieldPath"`
				FieldValue *DeleteWorkrequestsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetWorkrequestsIdResponse parses an HTTP response from a GetWorkrequestsIdWithResponse call
func ParseGetWorkrequestsIdResponse(rsp *http.Response) (*GetWorkrequestsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkrequestsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			WorkRequest struct {
				// ApproverTeamId ID of the team that is reponsible for approving the request.
				ApproverTeamId *float32 `json:"approverTeamId"`

				// Asset Asset linked to the element (expand with query parameter)
				Asset *struct {
					// CreatedAt Date & time at which the asset was created
					CreatedAt time.Time `json:"createdAt"`

					// CreatorId ID of the asset creator
					CreatorId *int `json:"creatorId"`

					// CriticalityId ID of the criticality of the asset
					CriticalityId *int    `json:"criticalityId"`
					Description   *string `json:"description"`

					// Id Global ID of the asset
					Id int `json:"id"`

					// LocationId ID of the location where the asset is located
					LocationId *int   `json:"locationId"`
					Name       string `json:"name"`

					// ParentId ID of the parent asset
					ParentId *int `json:"parentId"`

					// SerialNumber Serial number of the asset
					SerialNumber *string `json:"serialNumber"`

					// UpdatedAt Date & time at which the asset was last updated. This doesn't include comments
					UpdatedAt time.Time `json:"updatedAt"`
				} `json:"asset,omitempty"`
				AssetId *float32 `json:"assetId"`

				// Attachments List of attachments linked to the Work Request
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// CreatedAt Date & time at which the work request was created
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// CreatorContactInfo The creator's contact information associated with this work order request
				CreatorContactInfo *struct {
					Type  *GetWorkrequestsId200WorkRequestCreatorContactInfoType `json:"type,omitempty"`
					Value *string                                                `json:"value,omitempty"`
				} `json:"creatorContactInfo"`
				Description *string `json:"description"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Request Type") (expand with query parameter)
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the work request
				Id float32 `json:"id"`

				// Location Location linked to the element (expand with query parameter)
				Location *struct {
					// Address Postal address of the location
					Address *string `json:"address"`

					// CreatedAt Date & time at which the location was created
					CreatedAt   *time.Time `json:"createdAt,omitempty"`
					Description *string    `json:"description"`

					// Id Global ID of the location
					Id   int    `json:"id"`
					Name string `json:"name"`

					// ParentId ID of the parent location
					ParentId *int `json:"parentId"`

					// UpdatedAt Date & time at which the location was last updated. This doesn't include comments
					UpdatedAt *time.Time `json:"updatedAt,omitempty"`
				} `json:"location,omitempty"`
				LocationId            *float32                                     `json:"locationId"`
				Priority              GetWorkrequestsId200WorkRequestPriority      `json:"priority"`
				RequestStatus         GetWorkrequestsId200WorkRequestRequestStatus `json:"requestStatus"`
				SendEmailNotification *bool                                        `json:"sendEmailNotification,omitempty"`
				Thumbnail             *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`
				Title string `json:"title"`

				// UpdatedAt Date & time at which the work request was last updated
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`

				// WorkOrder Work Order linked to the element (expand with query parameter)
				WorkOrder *struct {
					AssetId *int `json:"assetId"`

					// AssigneeIds List of user ids assigned to the work order
					AssigneeIds *[]int `json:"assigneeIds,omitempty"`

					// Attachments List of attachments linked to the work order
					Attachments *[]struct {
						// CreatedAt Date & time at which the attachment was uploaded
						CreatedAt time.Time `json:"createdAt"`

						// FileName Attachment's file name
						FileName string `json:"fileName"`

						// Height Height if the file is an image
						Height *float32 `json:"height"`

						// Id Global ID of the attachment
						Id float32 `json:"id"`

						// MimeType MIME type of the file
						MimeType string `json:"mimeType"`

						// Url Url of the file
						Url string `json:"url"`

						// Width Width if the file is an image
						Width *float32 `json:"width"`
					} `json:"attachments,omitempty"`

					// Categories List of categories that identify the work order
					Categories *[]string `json:"categories,omitempty"`

					// CompletedAt Date & time at which the work order was last marked as DONE
					CompletedAt *time.Time `json:"completedAt"`

					// CompleterId ID of the user who completed the work order
					CompleterId *int `json:"completerId"`

					// CreatedAt Date & time at which the work order was created
					CreatedAt time.Time `json:"createdAt"`

					// CreatorId ID of the user who created the work order
					CreatorId *int `json:"creatorId"`

					// DeletedAt Date & time at which the work order was deleted
					DeletedAt   *time.Time `json:"deletedAt"`
					Description *string    `json:"description"`

					// DueDate Date & time at which the work order is due
					DueDate          *time.Time `json:"dueDate"`
					DueDateIsFullDay *bool      `json:"dueDateIsFullDay"`

					// EstimatedTime The estimated time taken in seconds to complete the work order
					EstimatedTime *int `json:"estimatedTime"`

					// ExternalData Extra data that can be attached to the work order, for example to help reference to a matching record in an external system.
					ExternalData *GetWorkrequestsId_200_WorkRequest_WorkOrder_ExternalData `json:"externalData"`

					// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Estimated Time Allotted")
					ExtraFields *map[string]string `json:"extraFields,omitempty"`

					// Id Global ID of the work order
					Id int `json:"id"`

					// IsParent If this is a parent work order
					IsParent *bool `json:"isParent"`

					// LocationId Global ID of the location assigned to the work order
					LocationId     *int    `json:"locationId"`
					NextId         *int    `json:"nextId"`
					OrganizationId float32 `json:"organizationId"`

					// ParentId The ID of the parent work order
					ParentId   *int                                              `json:"parentId"`
					PreviousId *int                                              `json:"previousId"`
					Priority   *GetWorkrequestsId200WorkRequestWorkOrderPriority `json:"priority,omitempty"`

					// Procedure Procedure attached to the work order
					Procedure *struct {
						Fields []struct {
							Assignees *struct {
								TeamIds *[]float32 `json:"teamIds,omitempty"`
								UserIds *[]float32 `json:"userIds,omitempty"`
							} `json:"assignees"`

							// Description Description of the procedure field
							Description *string `json:"description"`

							// Id ID of the procedure field
							Id float32 `json:"id"`

							// IsDateAndTime Indicate if a DATE field also contains the time
							IsDateAndTime *bool `json:"isDateAndTime"`

							// Label Label of a procedure field
							Label string `json:"label"`

							// MaxScore Maximum score of a procedure field
							MaxScore *float32 `json:"maxScore,omitempty"`

							// Meter Meter of a procedure field. Will be filled if the type of the field is meter
							Meter *struct {
								// Id Global ID of the meter.
								Id *float32 `json:"id,omitempty"`

								// Name Name of the meters
								Name *string `json:"name,omitempty"`
							} `json:"meter"`

							// ParentId ID of the parent of the current procedure field
							ParentId *float32 `json:"parentId"`

							// Required Indicate if field is required to be filled.
							Required bool `json:"required"`

							// Score Score of a procedure field
							Score *float32 `json:"score,omitempty"`

							// Type Type of procedure field
							Type GetWorkrequestsId200WorkRequestWorkOrderProcedureFieldsType `json:"type"`

							// Value Current value of a procedure field
							Value struct {
								// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
								Attachment *struct {
									// CreatedAt Date & time at which the attachment was uploaded
									CreatedAt time.Time `json:"createdAt"`

									// FileName Attachment's file name
									FileName string `json:"fileName"`

									// Height Height if the file is an image
									Height *float32 `json:"height"`

									// Id Global ID of the attachment
									Id float32 `json:"id"`

									// MimeType MIME type of the file
									MimeType string `json:"mimeType"`

									// Url Url of the file
									Url string `json:"url"`

									// Width Width if the file is an image
									Width *float32 `json:"width"`
								} `json:"attachment,omitempty"`
								Attachments *[]struct {
									// CreatedAt Date & time at which the attachment was uploaded
									CreatedAt time.Time `json:"createdAt"`

									// FileName Attachment's file name
									FileName string `json:"fileName"`

									// Height Height if the file is an image
									Height *float32 `json:"height"`

									// Id Global ID of the attachment
									Id float32 `json:"id"`

									// MimeType MIME type of the file
									MimeType string `json:"mimeType"`

									// Url Url of the file
									Url string `json:"url"`

									// Width Width if the file is an image
									Width *float32 `json:"width"`
								} `json:"attachments,omitempty"`
								HasAttachments *bool `json:"hasAttachments"`

								// Notes Note added to a procedure field
								Notes *struct {
									Text *string `json:"text,omitempty"`
								} `json:"notes"`
								Text *string `json:"text"`
							} `json:"value"`
						} `json:"fields"`

						// Id ID representing a procedure
						Id *float32 `json:"id,omitempty"`

						// MaxScore Maximum score of a procedure
						MaxScore *float32 `json:"maxScore,omitempty"`

						// Score Score of a procedure
						Score *float32 `json:"score,omitempty"`

						// TemplateIds IDs of the procedure template of the procedure
						TemplateIds *[]float32 `json:"templateIds"`

						// Title Title of the procedure
						Title string `json:"title"`
					} `json:"procedure"`

					// Progress Progress information on the work order
					Progress *struct {
						DoneCount       *float32 `json:"doneCount,omitempty"`
						InProgressCount *float32 `json:"inProgressCount,omitempty"`
						OnHoldCount     *float32 `json:"onHoldCount,omitempty"`
						OpenCount       *float32 `json:"openCount,omitempty"`
					} `json:"progress"`
					RecurrenceInfo *GetWorkrequestsId_200_WorkRequest_WorkOrder_RecurrenceInfo `json:"recurrenceInfo"`

					// RequesterId ID of the user who requested the work order through the Work Request feature
					RequesterId *int `json:"requesterId"`

					// SequentialId Organization specific ID of the work order
					SequentialId int `json:"sequentialId"`

					// StartDate Date & time at which the work order will show up in the inbox</br>Only valid when <b>dueDate</b> is set
					StartDate *time.Time `json:"startDate"`

					// Status <br /><em>Note:</em> It is also possible to register a webhook to get notified when the status of any work order changes. Please see the <a href="#tag/Subscriptions">Subscriptions</a> section for more information.
					Status GetWorkrequestsId200WorkRequestWorkOrderStatus `json:"status"`

					// TeamIds List of team ids assigned to the work order
					TeamIds   *[]int `json:"teamIds,omitempty"`
					Thumbnail *struct {
						// CreatedAt Date & time at which the attachment was uploaded
						CreatedAt time.Time `json:"createdAt"`

						// FileName Attachment's file name
						FileName string `json:"fileName"`

						// Height Height if the file is an image
						Height *float32 `json:"height"`

						// Id Global ID of the attachment
						Id float32 `json:"id"`

						// MimeType MIME type of the file
						MimeType string `json:"mimeType"`

						// Url Url of the file
						Url string `json:"url"`

						// Width Width if the file is an image
						Width *float32 `json:"width"`
					} `json:"thumbnail"`
					Title string `json:"title"`

					// Type Valid types of Work Orders, including options that are not available for creation/update. Historical Work Orders may have a null type.
					Type *GetWorkrequestsId200WorkRequestWorkOrderType `json:"type"`

					// UpdatedAt Date & time at which the work order was last updated. This doesn't include comments
					UpdatedAt time.Time `json:"updatedAt"`

					// VendorIds Vendor IDs
					VendorIds *[]float32 `json:"vendorIds,omitempty"`
				} `json:"workOrder,omitempty"`

				// WorkOrderId Global ID of the work order attached to the work request. A work order is created once a work request is approved.
				WorkOrderId *float32 `json:"workOrderId"`
			} `json:"workRequest"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Description of error
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchWorkrequestsIdResponse parses an HTTP response from a PatchWorkrequestsIdWithResponse call
func ParsePatchWorkrequestsIdResponse(rsp *http.Response) (*PatchWorkrequestsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchWorkrequestsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			WorkRequest struct {
				// ApproverTeamId ID of the team that is reponsible for approving the request.
				ApproverTeamId *float32 `json:"approverTeamId"`
				AssetId        *float32 `json:"assetId"`

				// Attachments List of attachments linked to the Work Request
				Attachments *[]struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"attachments,omitempty"`

				// CreatedAt Date & time at which the work request was created
				CreatedAt *time.Time `json:"createdAt,omitempty"`

				// CreatorContactInfo The creator's contact information associated with this work order request
				CreatorContactInfo *struct {
					Type  *PatchWorkrequestsId200WorkRequestCreatorContactInfoType `json:"type,omitempty"`
					Value *string                                                  `json:"value,omitempty"`
				} `json:"creatorContactInfo"`
				Description *string `json:"description"`

				// ExtraFields Custom Fields on the entity. The object keys are the exact Custom Field labels, including spaces or special characters. (ie: "Request Type")
				ExtraFields *map[string]string `json:"extraFields,omitempty"`

				// Id Global ID of the work request
				Id                    float32                                        `json:"id"`
				LocationId            *float32                                       `json:"locationId"`
				Priority              PatchWorkrequestsId200WorkRequestPriority      `json:"priority"`
				RequestStatus         PatchWorkrequestsId200WorkRequestRequestStatus `json:"requestStatus"`
				SendEmailNotification *bool                                          `json:"sendEmailNotification,omitempty"`
				Thumbnail             *struct {
					// CreatedAt Date & time at which the attachment was uploaded
					CreatedAt time.Time `json:"createdAt"`

					// FileName Attachment's file name
					FileName string `json:"fileName"`

					// Height Height if the file is an image
					Height *float32 `json:"height"`

					// Id Global ID of the attachment
					Id float32 `json:"id"`

					// MimeType MIME type of the file
					MimeType string `json:"mimeType"`

					// Url Url of the file
					Url string `json:"url"`

					// Width Width if the file is an image
					Width *float32 `json:"width"`
				} `json:"thumbnail"`
				Title string `json:"title"`

				// UpdatedAt Date & time at which the work request was last updated
				UpdatedAt *time.Time `json:"updatedAt,omitempty"`

				// WorkOrderId Global ID of the work order attached to the work request. A work order is created once a work request is approved.
				WorkOrderId *float32 `json:"workOrderId"`
			} `json:"workRequest"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                     `json:"error"`
				FieldPath  *string                                    `json:"fieldPath"`
				FieldValue *PatchWorkrequestsId_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteWorkrequestsIdAttachmentsFilenameResponse parses an HTTP response from a DeleteWorkrequestsIdAttachmentsFilenameWithResponse call
func ParseDeleteWorkrequestsIdAttachmentsFilenameResponse(rsp *http.Response) (*DeleteWorkrequestsIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkrequestsIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutWorkrequestsIdAttachmentsFilenameResponse parses an HTTP response from a PutWorkrequestsIdAttachmentsFilenameWithResponse call
func ParsePutWorkrequestsIdAttachmentsFilenameResponse(rsp *http.Response) (*PutWorkrequestsIdAttachmentsFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutWorkrequestsIdAttachmentsFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParsePutWorkrequestsIdThumbnailFilenameResponse parses an HTTP response from a PutWorkrequestsIdThumbnailFilenameWithResponse call
func ParsePutWorkrequestsIdThumbnailFilenameResponse(rsp *http.Response) (*PutWorkrequestsIdThumbnailFilenameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutWorkrequestsIdThumbnailFilenameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			FileKey   *string `json:"fileKey,omitempty"`
			Filename  *string `json:"filename,omitempty"`
			PublicUrl *string `json:"publicUrl,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				Error      string                                                    `json:"error"`
				FieldPath  *string                                                   `json:"fieldPath"`
				FieldValue *PutWorkrequestsIdThumbnailFilename_400_Errors_FieldValue `json:"fieldValue"`
			} `json:"errors"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest struct {
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}
